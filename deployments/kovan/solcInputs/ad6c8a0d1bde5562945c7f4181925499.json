{
  "language": "Solidity",
  "sources": {
    "contracts/Admin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IncentiveDistribution.sol\";\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\nimport \"./CrossMarginTrading.sol\";\n\n/** \n@title Here we support staking for MFI incentives as well as\nstaking to perform the maintenance role.\n*/\ncontract Admin is RoleAware {\n    /// Margenswap (MFI) token address\n    address public immutable MFI;\n    mapping(address => uint256) public stakes;\n    uint256 public totalStakes;\n\n    uint256 public maintenanceStakePerBlock = 10 ether;\n    mapping(address => address) public nextMaintenanceStaker;\n    mapping(address => mapping(address => bool)) public maintenanceDelegateTo;\n    address public currentMaintenanceStaker;\n    address public prevMaintenanceStaker;\n    uint256 public currentMaintenanceStakerStartBlock;\n    address public immutable lockedMFI;\n\n    constructor(\n        address _MFI,\n        address _lockedMFI,\n        address lockedMFIDelegate,\n        address _roles\n    ) RoleAware(_roles) {\n        MFI = _MFI;\n        maintenanceStakePerBlock = 1 ether;\n        lockedMFI = _lockedMFI;\n\n        // for initialization purposes and to ensure availability of service\n        // the team's locked MFI participate in maintenance staking only\n        // (not in the incentive staking part)\n        // this implies some trust of the team to execute, which we deem reasonable\n        // since the locked stake is temporary and diminishing as well as the fact\n        // that the team is heavily invested in the protocol and incentivized\n        // by fees like any other maintainer\n        // furthermore others could step in to liquidate via the attacker route\n        // and take away the team fees if they were delinquent\n        nextMaintenanceStaker[_lockedMFI] = _lockedMFI;\n        currentMaintenanceStaker = _lockedMFI;\n        prevMaintenanceStaker = _lockedMFI;\n        maintenanceDelegateTo[_lockedMFI][lockedMFIDelegate];\n        currentMaintenanceStakerStartBlock = block.number;\n    }\n\n    /// Maintence stake setter\n    function setMaintenanceStakePerBlock(uint256 amount)\n        external\n        onlyOwnerExec\n    {\n        maintenanceStakePerBlock = amount;\n    }\n\n    function _stake(address holder, uint256 amount) internal {\n        Fund(fund()).depositFor(holder, MFI, amount);\n\n        stakes[holder] += amount;\n        totalStakes += amount;\n\n        IncentiveDistribution(incentiveDistributor()).addToClaimAmount(\n            1,\n            holder,\n            amount\n        );\n    }\n\n    /// Deposit a stake for sender\n    function depositStake(uint256 amount) external {\n        _stake(msg.sender, amount);\n    }\n\n    function _withdrawStake(\n        address holder,\n        uint256 amount,\n        address recipient\n    ) internal {\n        // overflow failure desirable\n        stakes[holder] -= amount;\n        totalStakes -= amount;\n        Fund(fund()).withdraw(MFI, recipient, amount);\n\n        IncentiveDistribution(incentiveDistributor()).subtractFromClaimAmount(\n            1,\n            holder,\n            amount\n        );\n    }\n\n    /// Withdraw stake for sender\n    function withdrawStake(uint256 amount) external {\n        require(\n            !isAuthorizedStaker(msg.sender),\n            \"You can't withdraw while you're authorized staker\"\n        );\n        _withdrawStake(msg.sender, amount, msg.sender);\n    }\n\n    /// Deposit maintenance stake\n    function depositMaintenanceStake(uint256 amount) external {\n        require(\n            amount + stakes[msg.sender] >= maintenanceStakePerBlock,\n            \"Insufficient stake to call even one block\"\n        );\n        _stake(msg.sender, amount);\n        if (nextMaintenanceStaker[msg.sender] == address(0)) {\n            nextMaintenanceStaker[msg.sender] = getUpdatedCurrentStaker();\n            nextMaintenanceStaker[prevMaintenanceStaker] = msg.sender;\n        }\n    }\n\n    function getMaintenanceStakerStake(address staker)\n        public\n        view\n        returns (uint256)\n    {\n        if (staker == lockedMFI) {\n            return IERC20(MFI).balanceOf(lockedMFI) / 2;\n        } else {\n            return stakes[staker];\n        }\n    }\n\n    function getUpdatedCurrentStaker() public returns (address) {\n        uint256 currentStake =\n            getMaintenanceStakerStake(currentMaintenanceStaker);\n        while (\n            (block.number - currentMaintenanceStakerStartBlock) *\n                maintenanceStakePerBlock >=\n            currentStake\n        ) {\n            if (maintenanceStakePerBlock > currentStake) {\n                // delete current from daisy chain\n                address nextOne =\n                    nextMaintenanceStaker[currentMaintenanceStaker];\n                nextMaintenanceStaker[prevMaintenanceStaker] = nextOne;\n                nextMaintenanceStaker[currentMaintenanceStaker] = address(0);\n\n                currentMaintenanceStaker = nextOne;\n            } else {\n                currentMaintenanceStakerStartBlock +=\n                    currentStake /\n                    maintenanceStakePerBlock;\n\n                prevMaintenanceStaker = currentMaintenanceStaker;\n                currentMaintenanceStaker = nextMaintenanceStaker[\n                    currentMaintenanceStaker\n                ];\n            }\n            currentStake = getMaintenanceStakerStake(currentMaintenanceStaker);\n        }\n        return currentMaintenanceStaker;\n    }\n\n    function viewCurrentMaintenanceStaker()\n        public\n        view\n        returns (address staker, uint256 startBlock)\n    {\n        staker = currentMaintenanceStaker;\n        uint256 currentStake = getMaintenanceStakerStake(staker);\n        startBlock = currentMaintenanceStakerStartBlock;\n        while (\n            (block.number - startBlock) * maintenanceStakePerBlock >=\n            currentStake\n        ) {\n            if (maintenanceStakePerBlock > currentStake) {\n                // skip\n                staker = nextMaintenanceStaker[staker];\n                currentStake = getMaintenanceStakerStake(staker);\n            } else {\n                startBlock += currentStake / maintenanceStakePerBlock;\n                staker = nextMaintenanceStaker[staker];\n                currentStake = getMaintenanceStakerStake(staker);\n            }\n        }\n    }\n\n    /// Add a delegate for staker\n    function addDelegate(address forStaker, address delegate) external {\n        require(\n            msg.sender == forStaker ||\n                maintenanceDelegateTo[forStaker][msg.sender],\n            \"msg.sender not authorized to delegate for staker\"\n        );\n        maintenanceDelegateTo[forStaker][delegate] = true;\n    }\n\n    /// Remove a delegate for staker\n    function removeDelegate(address forStaker, address delegate) external {\n        require(\n            msg.sender == forStaker ||\n                maintenanceDelegateTo[forStaker][msg.sender],\n            \"msg.sender not authorized to delegate for staker\"\n        );\n        maintenanceDelegateTo[forStaker][delegate] = false;\n    }\n\n    function isAuthorizedStaker(address caller)\n        public\n        returns (bool isAuthorized)\n    {\n        address currentStaker = getUpdatedCurrentStaker();\n        isAuthorized =\n            currentStaker == caller ||\n            maintenanceDelegateTo[currentStaker][caller];\n    }\n\n    /// Penalize a staker\n    function penalizeMaintenanceStake(\n        address maintainer,\n        uint256 penalty,\n        address recipient\n    ) external returns (uint256 stakeTaken) {\n        require(\n            isStakePenalizer(msg.sender),\n            \"msg.sender not authorized to penalize stakers\"\n        );\n        if (penalty > stakes[maintainer]) {\n            stakeTaken = stakes[maintainer];\n        } else {\n            stakeTaken = penalty;\n        }\n        _withdrawStake(maintainer, stakeTaken, recipient);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/IncentiveDistribution.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RoleAware.sol\";\nimport \"./Fund.sol\";\n\nstruct Claim {\n    uint256 startingRewardRateFP;\n    uint256 amount;\n    uint256 intraDayGain;\n    uint256 intraDayLoss;\n}\n\n/// @title Manage distribution of liquidity stake incentives\n/// Some efforts have been made to reduce gas cost at claim time\n/// and shift gas burden onto those who would want to withdraw\ncontract IncentiveDistribution is RoleAware {\n    // fixed point number factor\n    uint256 internal constant FP32 = 2**32;\n    // the amount of contraction per thousand, per day\n    // of the overal daily incentive distribution\n    // https://en.wikipedia.org/wiki/Per_mil\n    uint256 public constant contractionPerMil = 999;\n    address public immutable MFI;\n\n    constructor(\n        address _MFI,\n        uint256 startingDailyDistributionWithoutDecimals,\n        address _roles\n    ) RoleAware(_roles) {\n        MFI = _MFI;\n        currentDailyDistribution =\n            startingDailyDistributionWithoutDecimals *\n            (1 ether);\n    }\n\n    // how much is going to be distributed, contracts every day\n    uint256 public currentDailyDistribution;\n\n    uint256 public trancheShareTotal;\n    uint256[] public allTranches;\n\n    struct TrancheMeta {\n        // portion of daily distribution per each tranche\n        uint256 rewardShare;\n        uint256 currentDayGains;\n        uint256 currentDayLosses;\n        uint256 tomorrowOngoingTotals;\n        uint256 yesterdayOngoingTotals;\n        // aggregate all the unclaimed intra-days\n        uint256 intraDayGains;\n        uint256 intraDayLosses;\n        uint256 intraDayRewardGains;\n        uint256 intraDayRewardLosses;\n        // how much each claim unit would get if they had staked from the dawn of time\n        // expressed as fixed point number\n        // claim amounts are expressed relative to this ongoing aggregate\n        uint256 aggregateDailyRewardRateFP;\n        uint256 yesterdayRewardRateFP;\n        mapping(address => Claim) claims;\n    }\n\n    mapping(uint256 => TrancheMeta) public trancheMetadata;\n\n    // last updated day\n    uint256 public lastUpdatedDay;\n\n    mapping(address => uint256) public accruedReward;\n\n    /// Set share of tranche\n    function setTrancheShare(uint256 tranche, uint256 share)\n        external\n        onlyOwnerExecActivator\n    {\n        require(\n            trancheMetadata[tranche].rewardShare > 0,\n            \"Tranche is not initialized, please initialize first\"\n        );\n        _setTrancheShare(tranche, share);\n    }\n\n    function _setTrancheShare(uint256 tranche, uint256 share) internal {\n        TrancheMeta storage tm = trancheMetadata[tranche];\n\n        if (share > tm.rewardShare) {\n            trancheShareTotal += share - tm.rewardShare;\n        } else {\n            trancheShareTotal -= tm.rewardShare - share;\n        }\n        tm.rewardShare = share;\n    }\n\n    /// Initialize tranche\n    function initTranche(uint256 tranche, uint256 share)\n        external\n        onlyOwnerExecActivator\n    {\n        TrancheMeta storage tm = trancheMetadata[tranche];\n        require(tm.rewardShare == 0, \"Tranche already initialized\");\n        _setTrancheShare(tranche, share);\n\n        // simply initialize to 1.0\n        tm.aggregateDailyRewardRateFP = FP32;\n        allTranches.push(tranche);\n    }\n\n    /// Start / increase amount of claim\n    function addToClaimAmount(\n        uint256 tranche,\n        address recipient,\n        uint256 claimAmount\n    ) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        if (currentDailyDistribution > 0) {\n            TrancheMeta storage tm = trancheMetadata[tranche];\n            Claim storage claim = tm.claims[recipient];\n\n            uint256 currentDay =\n                claimAmount * (1 days - (block.timestamp % (1 days)));\n\n            tm.currentDayGains += currentDay;\n            claim.intraDayGain += currentDay * currentDailyDistribution;\n\n            tm.tomorrowOngoingTotals += claimAmount * 1 days;\n            updateAccruedReward(tm, recipient, claim);\n\n            claim.amount += claimAmount * (1 days);\n        }\n    }\n\n    /// Decrease amount of claim\n    function subtractFromClaimAmount(\n        uint256 tranche,\n        address recipient,\n        uint256 subtractAmount\n    ) external {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n        uint256 currentDay = subtractAmount * (block.timestamp % (1 days));\n\n        TrancheMeta storage tm = trancheMetadata[tranche];\n        Claim storage claim = tm.claims[recipient];\n\n        tm.currentDayLosses += currentDay;\n        claim.intraDayLoss += currentDay * currentDailyDistribution;\n\n        tm.tomorrowOngoingTotals -= subtractAmount * 1 days;\n\n        updateAccruedReward(tm, recipient, claim);\n        claim.amount -= subtractAmount * (1 days);\n    }\n\n    function updateAccruedReward(\n        TrancheMeta storage tm,\n        address recipient,\n        Claim storage claim\n    ) internal returns (uint256 rewardDelta) {\n        if (claim.startingRewardRateFP > 0) {\n            rewardDelta = calcRewardAmount(tm, claim);\n            accruedReward[recipient] += rewardDelta;\n        }\n        // don't reward for current day (approximately)\n        claim.startingRewardRateFP =\n            tm.yesterdayRewardRateFP +\n            tm.aggregateDailyRewardRateFP;\n    }\n\n    /// @dev additional reward accrued since last update\n    function calcRewardAmount(TrancheMeta storage tm, Claim storage claim)\n        internal\n        view\n        returns (uint256 rewardAmount)\n    {\n        uint256 ours = claim.startingRewardRateFP;\n        uint256 aggregate = tm.aggregateDailyRewardRateFP;\n        if (aggregate > ours) {\n            rewardAmount = (claim.amount * (aggregate - ours)) / FP32;\n        }\n    }\n\n    function applyIntraDay(TrancheMeta storage tm, Claim storage claim)\n        internal\n        view\n        returns (uint256 gainImpact, uint256 lossImpact)\n    {\n        uint256 gain = claim.intraDayGain;\n        uint256 loss = claim.intraDayLoss;\n\n        if (gain + loss > 0) {\n            gainImpact =\n                (gain * tm.intraDayRewardGains) /\n                (tm.intraDayGains + 1);\n            lossImpact =\n                (loss * tm.intraDayRewardLosses) /\n                (tm.intraDayLosses + 1);\n        }\n    }\n\n    /// Get a view of reward amount\n    function viewRewardAmount(uint256 tranche, address claimant)\n        external\n        view\n        returns (uint256)\n    {\n        TrancheMeta storage tm = trancheMetadata[tranche];\n        Claim storage claim = tm.claims[claimant];\n\n        uint256 rewardAmount =\n            accruedReward[claimant] + calcRewardAmount(tm, claim);\n        (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(tm, claim);\n\n        return rewardAmount + gainImpact - lossImpact;\n    }\n\n    /// Withdraw current reward amount\n    function withdrawReward(uint256[] calldata tranches)\n        external\n        returns (uint256 withdrawAmount)\n    {\n        require(\n            isIncentiveReporter(msg.sender),\n            \"Contract not authorized to report incentives\"\n        );\n\n        updateDayTotals();\n\n        withdrawAmount = accruedReward[msg.sender];\n        for (uint256 i; tranches.length > i; i++) {\n            uint256 tranche = tranches[i];\n\n            TrancheMeta storage tm = trancheMetadata[tranche];\n            Claim storage claim = tm.claims[msg.sender];\n\n            withdrawAmount += updateAccruedReward(tm, msg.sender, claim);\n\n            (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(tm, claim);\n\n            withdrawAmount = withdrawAmount + gainImpact - lossImpact;\n\n            tm.intraDayGains -= claim.intraDayGain;\n            tm.intraDayLosses -= claim.intraDayLoss;\n            tm.intraDayRewardGains -= gainImpact;\n            tm.intraDayRewardLosses -= lossImpact;\n\n            claim.intraDayGain = 0;\n        }\n\n        accruedReward[msg.sender] = 0;\n\n        Fund(fund()).withdraw(MFI, msg.sender, withdrawAmount);\n    }\n\n    function updateDayTotals() internal {\n        uint256 nowDay = block.timestamp / (1 days);\n        uint256 dayDiff = nowDay - lastUpdatedDay;\n\n        // shrink the daily distribution for every day that has passed\n        for (uint256 i = 0; i < dayDiff; i++) {\n            _updateTrancheTotals();\n\n            currentDailyDistribution =\n                (currentDailyDistribution * contractionPerMil) /\n                1000;\n\n            lastUpdatedDay += 1;\n        }\n    }\n\n    function _updateTrancheTotals() internal {\n        for (uint256 i; allTranches.length > i; i++) {\n            uint256 tranche = allTranches[i];\n            TrancheMeta storage tm = trancheMetadata[tranche];\n\n            uint256 todayTotal =\n                tm.yesterdayOngoingTotals +\n                    tm.currentDayGains -\n                    tm.currentDayLosses;\n\n            uint256 todayRewardRateFP =\n                (FP32 * (currentDailyDistribution * tm.rewardShare)) /\n                    trancheShareTotal /\n                    todayTotal;\n\n            tm.yesterdayRewardRateFP = todayRewardRateFP;\n\n            tm.aggregateDailyRewardRateFP += todayRewardRateFP;\n\n            tm.intraDayGains += tm.currentDayGains * currentDailyDistribution;\n\n            tm.intraDayLosses += tm.currentDayLosses * currentDailyDistribution;\n\n            tm.intraDayRewardGains +=\n                (tm.currentDayGains * todayRewardRateFP) /\n                FP32;\n\n            tm.intraDayRewardLosses +=\n                (tm.currentDayLosses * todayRewardRateFP) /\n                FP32;\n\n            tm.yesterdayOngoingTotals = tm.tomorrowOngoingTotals;\n            tm.currentDayGains = 0;\n            tm.currentDayLosses = 0;\n        }\n    }\n}\n"
    },
    "contracts/RoleAware.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n/// @title Role management behavior\n/// Main characters are for service discovery\n/// Whereas roles are for access control\ncontract RoleAware {\n    Roles public immutable roles;\n    mapping(uint256 => address) public mainCharacterCache;\n    mapping(address => mapping(uint256 => bool)) public roleCache;\n\n    constructor(address _roles) {\n        require(_roles != address(0), \"Please provide valid roles address\");\n        roles = Roles(_roles);\n    }\n\n    modifier noIntermediary() {\n        require(\n            msg.sender == tx.origin,\n            \"Currently no intermediaries allowed for this function call\"\n        );\n        _;\n    }\n\n    // @dev Throws if called by any account other than the owner or executor\n    modifier onlyOwnerExec() {\n        require(\n            owner() == msg.sender || executor() == msg.sender,\n            \"Roles: caller is not the owner\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerExecDisabler() {\n        require(\n            owner() == msg.sender ||\n                executor() == msg.sender ||\n                disabler() == msg.sender,\n            \"Caller is not the owner, executor or authorized disabler\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerExecActivator() {\n        require(\n            owner() == msg.sender ||\n                executor() == msg.sender ||\n                isTokenActivator(msg.sender),\n            \"Caller is not the owner, executor or authorized activator\"\n        );\n        _;\n    }\n\n    function updateRoleCache(uint256 role, address contr) public virtual {\n        roleCache[contr][role] = roles.getRole(role, contr);\n    }\n\n    function updateMainCharacterCache(uint256 role) public virtual {\n        mainCharacterCache[role] = roles.mainCharacters(role);\n    }\n\n    function owner() internal view returns (address) {\n        return roles.owner();\n    }\n\n    function executor() internal returns (address) {\n        return roles.executor();\n    }\n\n    function disabler() internal view returns (address) {\n        return mainCharacterCache[DISABLER];\n    }\n\n    function fund() internal view returns (address) {\n        return mainCharacterCache[FUND];\n    }\n\n    function lending() internal view returns (address) {\n        return mainCharacterCache[LENDING];\n    }\n\n    function marginRouter() internal view returns (address) {\n        return mainCharacterCache[MARGIN_ROUTER];\n    }\n\n    function crossMarginTrading() internal view returns (address) {\n        return mainCharacterCache[CROSS_MARGIN_TRADING];\n    }\n\n    function feeController() internal view returns (address) {\n        return mainCharacterCache[FEE_CONTROLLER];\n    }\n\n    function price() internal view returns (address) {\n        return mainCharacterCache[PRICE_CONTROLLER];\n    }\n\n    function admin() internal view returns (address) {\n        return mainCharacterCache[ADMIN];\n    }\n\n    function incentiveDistributor() internal view returns (address) {\n        return mainCharacterCache[INCENTIVE_DISTRIBUTION];\n    }\n\n    function tokenAdmin() internal view returns (address) {\n        return mainCharacterCache[TOKEN_ADMIN];\n    }\n\n    function isBorrower(address contr) internal view returns (bool) {\n        return roleCache[contr][BORROWER];\n    }\n\n    function isFundTransferer(address contr) internal view returns (bool) {\n        return roleCache[contr][FUND_TRANSFERER];\n    }\n\n    function isMarginTrader(address contr) internal view returns (bool) {\n        return roleCache[contr][MARGIN_TRADER];\n    }\n\n    function isFeeSource(address contr) internal view returns (bool) {\n        return roleCache[contr][FEE_SOURCE];\n    }\n\n    function isMarginCaller(address contr) internal view returns (bool) {\n        return roleCache[contr][MARGIN_CALLER];\n    }\n\n    function isLiquidator(address contr) internal view returns (bool) {\n        return roleCache[contr][LIQUIDATOR];\n    }\n\n    function isAuthorizedFundTrader(address contr)\n        internal\n        view\n        returns (bool)\n    {\n        return roleCache[contr][AUTHORIZED_FUND_TRADER];\n    }\n\n    function isIncentiveReporter(address contr) internal view returns (bool) {\n        return roleCache[contr][INCENTIVE_REPORTER];\n    }\n\n    function isTokenActivator(address contr) internal view returns (bool) {\n        return roleCache[contr][TOKEN_ACTIVATOR];\n    }\n\n    function isStakePenalizer(address contr) internal view returns (bool) {\n        return roles.getRole(STAKE_PENALIZER, contr);\n    }\n}\n"
    },
    "contracts/Fund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./RoleAware.sol\";\n\n/// @title Manage funding\ncontract Fund is RoleAware {\n    using SafeERC20 for IERC20;\n    /// wrapped ether\n    address public immutable WETH;\n\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\n        WETH = _WETH;\n    }\n\n    /// Deposit an active token\n    function deposit(address depositToken, uint256 depositAmount) external {\n        IERC20(depositToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            depositAmount\n        );\n    }\n\n    /// Deposit token on behalf of `sender`\n    function depositFor(\n        address sender,\n        address depositToken,\n        uint256 depositAmount\n    ) external {\n        require(\n            isFundTransferer(msg.sender),\n            \"Contract not authorized to deposit for user\"\n        );\n        IERC20(depositToken).safeTransferFrom(\n            sender,\n            address(this),\n            depositAmount\n        );\n    }\n\n    /// Deposit to wrapped ether\n    function depositToWETH() external payable {\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    // withdrawers role\n    function withdraw(\n        address withdrawalToken,\n        address recipient,\n        uint256 withdrawalAmount\n    ) external {\n        require(\n            isFundTransferer(msg.sender),\n            \"Contract not authorized to withdraw\"\n        );\n        IERC20(withdrawalToken).safeTransfer(recipient, withdrawalAmount);\n    }\n\n    // withdrawers role\n    function withdrawETH(address recipient, uint256 withdrawalAmount) external {\n        require(isFundTransferer(msg.sender), \"Not authorized to withdraw\");\n        IWETH(WETH).withdraw(withdrawalAmount);\n        Address.sendValue(payable(recipient), withdrawalAmount);\n    }\n}\n"
    },
    "contracts/CrossMarginTrading.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./CrossMarginLiquidation.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\ncontract CrossMarginTrading is CrossMarginLiquidation, IMarginTrading {\n    constructor(address _peg, address _roles)\n        RoleAware(_roles)\n        PriceAware(_peg)\n    {\n        liquidationThresholdPercent = 110;\n        coolingOffPeriod = 20;\n        leveragePercent = 300;\n    }\n\n    /// @dev admin function to set the token cap\n    function setTokenCap(address token, uint256 cap)\n        external\n        onlyOwnerExecActivator\n    {\n        tokenCaps[token] = cap;\n    }\n\n    /// @dev setter for cooling off period for withdrawing funds after deposit\n    function setCoolingOffPeriod(uint256 blocks) external onlyOwnerExec {\n        coolingOffPeriod = blocks;\n    }\n\n    /// @dev admin function to set leverage\n    function setLeverage(uint256 _leveragePercent) external onlyOwnerExec {\n        leveragePercent = _leveragePercent;\n    }\n\n    /// @dev admin function to set liquidation threshold\n    function setLiquidationThresholdPercent(uint256 threshold)\n        external\n        onlyOwnerExec\n    {\n        liquidationThresholdPercent = threshold;\n    }\n\n    /// @dev gets called by router to affirm a deposit to an account\n    function registerDeposit(\n        address trader,\n        address token,\n        uint256 depositAmount\n    ) external override returns (uint256 extinguishableDebt) {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n        account.lastDepositBlock = block.number;\n\n        if (account.borrowed[token] > 0) {\n            extinguishableDebt = min(depositAmount, account.borrowed[token]);\n            extinguishDebt(account, token, extinguishableDebt);\n            totalShort[token] -= extinguishableDebt;\n        }\n\n        // no overflow because depositAmount >= extinguishableDebt\n        uint256 addedHolding = depositAmount - extinguishableDebt;\n        _registerDeposit(account, token, addedHolding);\n    }\n\n    function _registerDeposit(\n        CrossMarginAccount storage account,\n        address token,\n        uint256 addedHolding\n    ) internal {\n        addHolding(account, token, addedHolding);\n\n        totalLong[token] += addedHolding;\n        require(\n            tokenCaps[token] >= totalLong[token],\n            \"Exceeding global exposure cap to token -- try again later\"\n        );\n    }\n\n    /// @dev gets called by router to affirm borrowing event\n    function registerBorrow(\n        address trader,\n        address borrowToken,\n        uint256 borrowAmount\n    ) external override {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n        CrossMarginAccount storage account = marginAccounts[trader];\n        _registerBorrow(account, borrowToken, borrowAmount);\n    }\n\n    function _registerBorrow(\n        CrossMarginAccount storage account,\n        address borrowToken,\n        uint256 borrowAmount\n    ) internal {\n        totalShort[borrowToken] += borrowAmount;\n        totalLong[borrowToken] += borrowAmount;\n        require(\n            tokenCaps[borrowToken] >= totalShort[borrowToken] &&\n                tokenCaps[borrowToken] >= totalLong[borrowToken],\n            \"Exceeding global exposure cap to token -- try again later\"\n        );\n\n        borrow(account, borrowToken, borrowAmount);\n    }\n\n    /// @dev gets called by router to affirm withdrawal of tokens from account\n    function registerWithdrawal(\n        address trader,\n        address withdrawToken,\n        uint256 withdrawAmount\n    ) external override {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n        CrossMarginAccount storage account = marginAccounts[trader];\n        _registerWithdrawal(account, withdrawToken, withdrawAmount);\n    }\n\n    function _registerWithdrawal(\n        CrossMarginAccount storage account,\n        address withdrawToken,\n        uint256 withdrawAmount\n    ) internal {\n        require(\n            block.number > account.lastDepositBlock + coolingOffPeriod,\n            \"To prevent attacks you must wait until your cooling off period is over to withdraw\"\n        );\n\n        totalLong[withdrawToken] -= withdrawAmount;\n        // throws on underflow\n        account.holdings[withdrawToken] =\n            account.holdings[withdrawToken] -\n            withdrawAmount;\n        require(\n            positiveBalance(account),\n            \"Account balance is too low to withdraw\"\n        );\n    }\n\n    /// @dev overcollateralized borrowing on a cross margin account, called by router\n    function registerOvercollateralizedBorrow(\n        address trader,\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    ) external override {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n\n        _registerDeposit(account, depositToken, depositAmount);\n        _registerBorrow(account, borrowToken, withdrawAmount);\n        _registerWithdrawal(account, borrowToken, withdrawAmount);\n\n        account.lastDepositBlock = block.number;\n    }\n\n    /// @dev gets called by router to register a trade and borrow and extinguish as necessary\n    function registerTradeAndBorrow(\n        address trader,\n        address tokenFrom,\n        address tokenTo,\n        uint256 inAmount,\n        uint256 outAmount\n    )\n        external\n        override\n        returns (uint256 extinguishableDebt, uint256 borrowAmount)\n    {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract is not an authorized margin trader agent\"\n        );\n\n        CrossMarginAccount storage account = marginAccounts[trader];\n\n        if (account.borrowed[tokenTo] > 0) {\n            extinguishableDebt = min(outAmount, account.borrowed[tokenTo]);\n            extinguishDebt(account, tokenTo, extinguishableDebt);\n            totalShort[tokenTo] -= extinguishableDebt;\n        }\n        totalLong[tokenFrom] -= inAmount;\n        totalLong[tokenTo] += outAmount - extinguishableDebt;\n        require(\n            tokenCaps[tokenTo] >= totalLong[tokenTo],\n            \"Exceeding global exposure cap to token -- try again later\"\n        );\n\n        uint256 sellAmount = inAmount;\n        if (inAmount > account.holdings[tokenFrom]) {\n            sellAmount = account.holdings[tokenFrom];\n            /// won't overflow\n            borrowAmount = inAmount - sellAmount;\n\n            totalShort[tokenFrom] += borrowAmount;\n            require(\n                tokenCaps[tokenFrom] >= totalShort[tokenFrom],\n                \"Exceeding global exposure cap to token -- try again later\"\n            );\n\n            borrow(account, tokenFrom, borrowAmount);\n        }\n        adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);\n    }\n\n    /// @dev can get called by router to register the dissolution of an account\n    function registerLiquidation(address trader) external override {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract is not an authorized margin trader agent\"\n        );\n        CrossMarginAccount storage account = marginAccounts[trader];\n        require(\n            loanInPeg(account) == 0,\n            \"Can't liquidate currently borrowing account\"\n        );\n\n        deleteAccount(account);\n    }\n\n    /// @dev view function to display account held assets state\n    function getHoldingAmounts(address trader)\n        external\n        view\n        override\n        returns (\n            address[] memory holdingTokens,\n            uint256[] memory holdingAmounts\n        )\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        holdingTokens = account.holdingTokens;\n\n        holdingAmounts = new uint256[](account.holdingTokens.length);\n        for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\n            address tokenAddress = holdingTokens[idx];\n            holdingAmounts[idx] = account.holdings[tokenAddress];\n        }\n    }\n\n    /// @dev view function to display account borrowing state\n    function getBorrowAmounts(address trader)\n        external\n        view\n        override\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts)\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        borrowTokens = account.borrowTokens;\n\n        borrowAmounts = new uint256[](account.borrowTokens.length);\n        for (uint256 idx = 0; borrowTokens.length > idx; idx++) {\n            address tokenAddress = borrowTokens[idx];\n            borrowAmounts[idx] = Lending(lending()).viewWithBorrowInterest(\n                account.borrowed[tokenAddress],\n                tokenAddress,\n                account.borrowedYieldQuotientsFP[tokenAddress]\n            );\n        }\n    }\n\n    /// @dev view function to get loan amount in peg\n    function viewLoanInPeg(address trader)\n        external\n        view\n        returns (uint256 amount)\n    {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        return\n            viewTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP\n            );\n    }\n\n    /// @dev total of assets of account, expressed in reference currency\n    function viewHoldingsInPeg(address trader) external view returns (uint256) {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        return viewTokensInPeg(account.holdingTokens, account.holdings);\n    }\n\n    /// @dev can this trader be liquidated?\n    function canBeLiquidated(address trader) external view returns (bool) {\n        CrossMarginAccount storage account = marginAccounts[trader];\n        uint256 loan =\n            viewTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP\n            );\n\n        uint256 holdings =\n            viewTokensInPeg(account.holdingTokens, account.holdings);\n\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }\n}\n"
    },
    "contracts/Roles.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IDependencyController.sol\";\n\n// we chose not to go with an enum\n// to make this list easy to extend\nuint256 constant FUND_TRANSFERER = 1;\nuint256 constant MARGIN_CALLER = 2;\nuint256 constant BORROWER = 3;\nuint256 constant MARGIN_TRADER = 4;\nuint256 constant FEE_SOURCE = 5;\nuint256 constant LIQUIDATOR = 6;\nuint256 constant AUTHORIZED_FUND_TRADER = 7;\nuint256 constant INCENTIVE_REPORTER = 8;\nuint256 constant TOKEN_ACTIVATOR = 9;\nuint256 constant STAKE_PENALIZER = 10;\n\nuint256 constant FUND = 101;\nuint256 constant LENDING = 102;\nuint256 constant MARGIN_ROUTER = 103;\nuint256 constant CROSS_MARGIN_TRADING = 104;\nuint256 constant FEE_CONTROLLER = 105;\nuint256 constant PRICE_CONTROLLER = 106;\nuint256 constant ADMIN = 107;\nuint256 constant INCENTIVE_DISTRIBUTION = 108;\nuint256 constant TOKEN_ADMIN = 109;\n\nuint256 constant DISABLER = 1001;\nuint256 constant DEPENDENCY_CONTROLLER = 1002;\n\n/// @title Manage permissions of contracts and ownership of everything\n/// owned by a multisig wallet (0xEED9D1c6B4cdEcB3af070D85bfd394E7aF179CBd) during\n/// beta and will then be transfered to governance\n/// https://github.com/marginswap/governance\ncontract Roles is Ownable {\n    mapping(address => mapping(uint256 => bool)) public roles;\n    mapping(uint256 => address) public mainCharacters;\n\n    constructor() Ownable() {\n        // token activation from the get-go\n        roles[msg.sender][TOKEN_ACTIVATOR] = true;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwnerExecDepController() {\n        require(\n            owner() == msg.sender ||\n                executor() == msg.sender ||\n                mainCharacters[DEPENDENCY_CONTROLLER] == msg.sender,\n            \"Roles: caller is not the owner\"\n        );\n        _;\n    }\n\n    function giveRole(uint256 role, address actor)\n        external\n        onlyOwnerExecDepController\n    {\n        roles[actor][role] = true;\n    }\n\n    function removeRole(uint256 role, address actor)\n        external\n        onlyOwnerExecDepController\n    {\n        roles[actor][role] = false;\n    }\n\n    function setMainCharacter(uint256 role, address actor)\n        external\n        onlyOwnerExecDepController\n    {\n        mainCharacters[role] = actor;\n    }\n\n    function getRole(uint256 role, address contr) external view returns (bool) {\n        return roles[contr][role];\n    }\n\n    /// @dev current executor\n    function executor() public returns (address exec) {\n        address depController = mainCharacters[DEPENDENCY_CONTROLLER];\n        if (depController != address(0)) {\n            exec = IDependencyController(depController).currentExecutor();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "interfaces/IDependencyController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IDependencyController {\n    function currentExecutor() external returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/Lending.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Fund.sol\";\nimport \"./HourlyBondSubscriptionLending.sol\";\nimport \"./BondLending.sol\";\nimport \"./IncentivizedHolder.sol\";\n\n// TODO activate bonds for lending\n\n// TODO disburse token if isolated bond issuer\n// and if isolated issuer, allow for haircuts\n\n/// @title Manage lending for a variety of bond issuers\ncontract Lending is\n    RoleAware,\n    BaseLending,\n    HourlyBondSubscriptionLending,\n    BondLending,\n    IncentivizedHolder\n{\n    /// @dev IDs for all bonds held by an address\n    mapping(address => uint256[]) public bondIds;\n\n    /// mapping issuers to tokens\n    /// (in crossmargin, the issuers are tokens  themselves)\n    mapping(address => address) public issuerTokens;\n\n    /// In case of shortfall, adjust debt\n    mapping(address => uint256) public haircuts;\n\n    /// map of available issuers\n    mapping(address => bool) public activeIssuers;\n\n    constructor(address _roles) RoleAware(_roles) {\n        uint256 APR = 899;\n        maxHourlyYieldFP = (FP32 * APR) / 100 / (24 * 365);\n\n        uint256 aprChangePerMil = 3;\n        yieldChangePerSecondFP = (FP32 * aprChangePerMil) / 1000;\n    }\n\n    /// Make a issuer available for protocol\n    function activateIssuer(address issuer) external {\n        activateIssuer(issuer, issuer);\n    }\n\n    /// Make issuer != token available for protocol (isol. margin)\n    function activateIssuer(address issuer, address token)\n        public\n        onlyOwnerExecActivator\n    {\n        activeIssuers[issuer] = true;\n        issuerTokens[issuer] = token;\n    }\n\n    /// Remove a issuer from trading availability\n    function deactivateIssuer(address issuer) external onlyOwnerExecActivator {\n        activeIssuers[issuer] = false;\n    }\n\n    /// Set lending cap\n    function setLendingCap(address issuer, uint256 cap)\n        external\n        onlyOwnerExecActivator\n    {\n        lendingMeta[issuer].lendingCap = cap;\n    }\n\n    /// Set lending buffer\n    function setLendingBuffer(address issuer, uint256 buffer)\n        external\n        onlyOwnerExecActivator\n    {\n        lendingMeta[issuer].lendingBuffer = buffer;\n    }\n\n    /// Set withdrawal window\n    function setWithdrawalWindow(uint256 window) external onlyOwnerExec {\n        withdrawalWindow = window;\n    }\n\n    /// Set hourly yield APR for issuer\n    function setHourlyYieldAPR(address issuer, uint256 aprPercent)\n        external\n        onlyOwnerExecActivator\n    {\n        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];\n\n        if (bondMeta.yieldAccumulator.accumulatorFP == 0) {\n            bondMeta.yieldAccumulator = YieldAccumulator({\n                accumulatorFP: FP32,\n                lastUpdated: block.timestamp,\n                hourlyYieldFP: FP32 + (FP32 * aprPercent) / 100 / (24 * 365)\n            });\n            bondMeta.buyingSpeed = 1;\n            bondMeta.withdrawingSpeed = 1;\n            bondMeta.lastBought = block.timestamp;\n            bondMeta.lastWithdrawn = block.timestamp;\n        } else {\n            YieldAccumulator storage yA =\n                getUpdatedHourlyYield(issuer, bondMeta);\n            yA.hourlyYieldFP = (FP32 * (100 + aprPercent)) / 100 / (24 * 365);\n        }\n    }\n\n    /// Set maximum hourly yield in floating point\n    function setMaxHourlyYieldFP(uint256 maxYieldFP) external onlyOwnerExec {\n        maxHourlyYieldFP = maxYieldFP;\n    }\n\n    /// Set yield change per second in floating point\n    function setYieldChangePerSecondFP(uint256 changePerSecondFP)\n        external\n        onlyOwnerExec\n    {\n        yieldChangePerSecondFP = changePerSecondFP;\n    }\n\n    /// Set runtime yields in floating point\n    function setRuntimeYieldsFP(address issuer, uint256[] memory yieldsFP)\n        external\n        onlyOwnerExec\n    {\n        BondBucketMetadata[] storage bondMetas = bondBucketMetadata[issuer];\n        for (uint256 i; bondMetas.length > i; i++) {\n            bondMetas[i].runtimeYieldFP = yieldsFP[i];\n        }\n    }\n\n    /// Set miniumum runtime\n    function setMinRuntime(uint256 runtime) external onlyOwnerExec {\n        require(runtime > 1 hours, \"Min runtime needs to be at least 1 hour\");\n        require(\n            maxRuntime > runtime,\n            \"Min runtime must be smaller than max runtime\"\n        );\n        minRuntime = runtime;\n    }\n\n    /// Set maximum runtime\n    function setMaxRuntime(uint256 runtime) external onlyOwnerExec {\n        require(\n            runtime > minRuntime,\n            \"Max runtime must be greater than min runtime\"\n        );\n        maxRuntime = runtime;\n    }\n\n    /// Set runtime weights in floating point\n    function setRuntimeWeights(address issuer, uint256[] memory weights)\n        external\n        onlyOwnerExecActivator\n    {\n        BondBucketMetadata[] storage bondMetas = bondBucketMetadata[issuer];\n\n        if (bondMetas.length == 0) {\n            // we are initializing\n\n            uint256 hourlyYieldFP = (110 * FP32) / 100 / (24 * 365);\n            uint256 bucketSize = diffMaxMinRuntime / weights.length;\n\n            for (uint256 i; weights.length > i; i++) {\n                uint256 runtime = minRuntime + bucketSize * i;\n                bondMetas.push(\n                    BondBucketMetadata({\n                        runtimeYieldFP: (hourlyYieldFP * runtime) / (1 hours),\n                        lastBought: block.timestamp,\n                        lastWithdrawn: block.timestamp,\n                        yieldLastUpdated: block.timestamp,\n                        buyingSpeed: 1,\n                        withdrawingSpeed: 1,\n                        runtimeWeight: weights[i],\n                        totalLending: 0\n                    })\n                );\n            }\n        } else {\n            require(\n                weights.length == bondMetas.length,\n                \"Weights don't match buckets\"\n            );\n            for (uint256 i; weights.length > i; i++) {\n                bondMetas[i].runtimeWeight = weights[i];\n            }\n        }\n    }\n\n    /// @dev how much interest has accrued to a borrowed balance over time\n    function applyBorrowInterest(\n        uint256 balance,\n        address issuer,\n        uint256 yieldQuotientFP\n    ) external returns (uint256 balanceWithInterest, uint256 accumulatorFP) {\n        require(isBorrower(msg.sender), \"Not an approved borrower\");\n\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        updateBorrowYieldAccu(yA);\n        accumulatorFP = yA.accumulatorFP;\n\n        balanceWithInterest = applyInterest(\n            balance,\n            accumulatorFP,\n            yieldQuotientFP\n        );\n\n        uint256 deltaAmount = balanceWithInterest - balance;\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalBorrowed += deltaAmount;\n    }\n\n    /// @dev view function to get balance with borrowing interest applied\n    function viewWithBorrowInterest(\n        uint256 balance,\n        address issuer,\n        uint256 yieldQuotientFP\n    ) external view returns (uint256) {\n        uint256 accumulatorFP =\n            viewCumulativeYieldFP(\n                borrowYieldAccumulators[issuer],\n                block.timestamp\n            );\n        return applyInterest(balance, accumulatorFP, yieldQuotientFP);\n    }\n\n    /// @dev gets called by router to register if a trader borrows issuers\n    function registerBorrow(address issuer, uint256 amount) external {\n        require(isBorrower(msg.sender), \"Not an approved borrower\");\n        require(activeIssuers[issuer], \"Not an approved issuer\");\n\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalBorrowed += amount;\n        require(\n            meta.totalLending >= meta.totalBorrowed,\n            \"Insufficient capital to lend, try again later!\"\n        );\n    }\n\n    /// @dev gets called by router if loan is extinguished\n    function payOff(address issuer, uint256 amount) external {\n        require(isBorrower(msg.sender), \"Not an approved borrower\");\n        lendingMeta[issuer].totalBorrowed -= amount;\n    }\n\n    /// @dev get the borrow yield for a specific issuer/token\n    function viewAccumulatedBorrowingYieldFP(address issuer)\n        external\n        view\n        returns (uint256)\n    {\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        return viewCumulativeYieldFP(yA, block.timestamp);\n    }\n\n    function viewAPRPer10k(YieldAccumulator storage yA)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 hourlyYieldFP = yA.hourlyYieldFP;\n\n        uint256 aprFP =\n            ((hourlyYieldFP * 10_000 - FP32 * 10_000) * 365 days) / (1 hours);\n\n        return aprFP / FP32;\n    }\n\n    /// @dev get current borrowing interest per 10k for a token / issuer\n    function viewBorrowAPRPer10k(address issuer)\n        external\n        view\n        returns (uint256)\n    {\n        return viewAPRPer10k(borrowYieldAccumulators[issuer]);\n    }\n\n    /// @dev get current lending APR per 10k for a token / issuer\n    function viewHourlyBondAPRPer10k(address issuer)\n        external\n        view\n        returns (uint256)\n    {\n        return viewAPRPer10k(hourlyBondMetadata[issuer].yieldAccumulator);\n    }\n\n    /// @dev In a liquidity crunch make a fallback bond until liquidity is good again\n    function _makeFallbackBond(\n        address issuer,\n        address holder,\n        uint256 amount\n    ) internal override {\n        _makeHourlyBond(issuer, holder, amount);\n    }\n\n    /// @dev withdraw an hour bond\n    function withdrawHourlyBond(address issuer, uint256 amount) external {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][msg.sender];\n        // apply all interest\n        updateHourlyBondAmount(issuer, bond);\n        super._withdrawHourlyBond(issuer, bond, amount);\n\n        if (bond.amount == 0) {\n            delete hourlyBondAccounts[issuer][msg.sender];\n        }\n\n        disburse(issuer, msg.sender, amount);\n\n        withdrawClaim(msg.sender, issuer, amount);\n    }\n\n    /// Shut down hourly bond account for `issuer`\n    function closeHourlyBondAccount(address issuer) external {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][msg.sender];\n        // apply all interest\n        updateHourlyBondAmount(issuer, bond);\n\n        uint256 amount = bond.amount;\n        super._withdrawHourlyBond(issuer, bond, amount);\n\n        disburse(issuer, msg.sender, amount);\n\n        delete hourlyBondAccounts[issuer][msg.sender];\n\n        withdrawClaim(msg.sender, issuer, amount);\n    }\n\n    /// @dev buy hourly bond subscription\n    function buyHourlyBondSubscription(address issuer, uint256 amount)\n        external\n    {\n        require(activeIssuers[issuer], \"Not an approved issuer\");\n\n        LendingMetadata storage meta = lendingMeta[issuer];\n        if (lendingTarget(meta) >= meta.totalLending + amount) {\n            collectToken(issuer, msg.sender, amount);\n\n            super._makeHourlyBond(issuer, msg.sender, amount);\n\n            stakeClaim(msg.sender, issuer, amount);\n        }\n    }\n\n    /// @dev buy fixed term bond that does not renew\n    function buyBond(\n        address issuer,\n        uint256 runtime,\n        uint256 amount,\n        uint256 minReturn\n    ) external returns (uint256 bondIndex) {\n        require(activeIssuers[issuer], \"Not an approved issuer\");\n\n        LendingMetadata storage meta = lendingMeta[issuer];\n        if (\n            lendingTarget(meta) >= meta.totalLending + amount &&\n            maxRuntime >= runtime &&\n            runtime >= minRuntime\n        ) {\n            bondIndex = super._makeBond(\n                msg.sender,\n                issuer,\n                runtime,\n                amount,\n                minReturn\n            );\n            if (bondIndex > 0) {\n                Fund(fund()).depositFor(msg.sender, issuer, amount);\n                bondIds[msg.sender].push(bondIndex);\n\n                collectToken(issuer, msg.sender, amount);\n                stakeClaim(msg.sender, issuer, amount);\n            }\n        }\n    }\n\n    /// @dev send back funds of bond after maturity\n    function withdrawBond(uint256 bondId) external {\n        Bond storage bond = bonds[bondId];\n        require(msg.sender == bond.holder, \"Not holder of bond\");\n        require(\n            block.timestamp > bond.maturityTimestamp,\n            \"bond is still immature\"\n        );\n        // in case of a shortfall, governance can step in to provide\n        // additonal compensation beyond the usual incentive which\n        // gets withdrawn here\n        withdrawClaim(msg.sender, bond.issuer, bond.originalPrice);\n\n        uint256 withdrawAmount = super._withdrawBond(bondId, bond);\n        disburse(bond.issuer, msg.sender, withdrawAmount);\n    }\n\n    function initBorrowYieldAccumulator(address issuer)\n        external\n        onlyOwnerExecActivator\n    {\n        require(\n            borrowYieldAccumulators[issuer].accumulatorFP == 0,\n            \"trying to re-initialize yield accumulator\"\n        );\n\n        borrowYieldAccumulators[issuer].accumulatorFP = FP32;\n    }\n\n    function setBorrowingFactorPercent(uint256 borrowingFactor)\n        external\n        onlyOwnerExec\n    {\n        borrowingFactorPercent = borrowingFactor;\n    }\n\n    function issuanceBalance(address issuer)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        address token = issuerTokens[issuer];\n        if (token == issuer) {\n            // cross margin\n            return IERC20(token).balanceOf(fund());\n        } else {\n            return lendingMeta[issuer].totalLending - haircuts[issuer];\n        }\n    }\n\n    function disburse(\n        address issuer,\n        address recipient,\n        uint256 amount\n    ) internal {\n        uint256 haircutAmount = haircuts[issuer];\n        if (haircutAmount > 0 && amount > 0) {\n            uint256 totalLending = lendingMeta[issuer].totalLending;\n            uint256 adjustment =\n                (amount * min(totalLending, haircutAmount)) / totalLending;\n            amount = amount - adjustment;\n            haircuts[issuer] -= adjustment;\n        }\n\n        address token = issuerTokens[issuer];\n        Fund(fund()).withdraw(token, recipient, amount);\n    }\n\n    function collectToken(\n        address issuer,\n        address source,\n        uint256 amount\n    ) internal {\n        Fund(fund()).depositFor(source, issuer, amount);\n    }\n\n    function haircut(uint256 amount) external {\n        haircuts[msg.sender] += amount;\n    }\n}\n"
    },
    "contracts/CrossMarginLiquidation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./CrossMarginAccounts.sol\";\n\n/** \n@title Handles liquidation of accounts below maintenance threshold\n@notice Liquidation can be called by the authorized staker, \nas determined in the Admin contract.\nIf the authorized staker is delinquent, other participants can jump\nin and attack, taking their fees and potentially even their stake,\ndepending how delinquent the responsible authorized staker is.\n*/\nabstract contract CrossMarginLiquidation is CrossMarginAccounts {\n    event LiquidationShortfall(uint256 amount);\n    event AccountLiquidated(address account);\n\n    struct Liquidation {\n        uint256 buy;\n        uint256 sell;\n        uint256 blockNum;\n    }\n\n    /// record kept around until a stake attacker can claim their reward\n    struct AccountLiqRecord {\n        uint256 blockNum;\n        address loser;\n        uint256 amount;\n        address stakeAttacker;\n    }\n\n    mapping(address => Liquidation) liquidationAmounts;\n    address[] internal sellTokens;\n    address[] internal buyTokens;\n    address[] internal tradersToLiquidate;\n\n    mapping(address => uint256) public maintenanceFailures;\n    mapping(address => AccountLiqRecord) public stakeAttackRecords;\n    uint256 public avgLiquidationPerCall = 10;\n\n    uint256 public liqStakeAttackWindow = 5;\n    uint256 public MAINTAINER_CUT_PERCENT = 5;\n\n    uint256 public failureThreshold = 10;\n\n    /// Set failure threshold\n    function setFailureThreshold(uint256 threshFactor) external onlyOwnerExec {\n        failureThreshold = threshFactor;\n    }\n\n    /// Set liquidity stake attack window\n    function setLiqStakeAttackWindow(uint256 window) external onlyOwnerExec {\n        liqStakeAttackWindow = window;\n    }\n\n    /// Set maintainer's percent cut\n    function setMaintainerCutPercent(uint256 cut) external onlyOwnerExec {\n        MAINTAINER_CUT_PERCENT = cut;\n    }\n\n    /// @dev calcLiquidationAmounts does a number of tasks in this contract\n    /// and some of them are not straightforward.\n    /// First of all it aggregates liquidation amounts,\n    /// as well as which traders are ripe for liquidation, in storage (not in memory)\n    /// owing to the fact that arrays can't be pushed to and hash maps don't\n    /// exist in memory.\n    /// Then it also returns any stake attack funds if the stake was unsuccessful\n    /// (i.e. current caller is authorized). Also see context below.\n    function calcLiquidationAmounts(\n        address[] memory liquidationCandidates,\n        bool isAuthorized\n    ) internal returns (uint256 attackReturns) {\n        sellTokens = new address[](0);\n        buyTokens = new address[](0);\n        tradersToLiquidate = new address[](0);\n\n        for (\n            uint256 traderIndex = 0;\n            liquidationCandidates.length > traderIndex;\n            traderIndex++\n        ) {\n            address traderAddress = liquidationCandidates[traderIndex];\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\n            if (belowMaintenanceThreshold(account)) {\n                tradersToLiquidate.push(traderAddress);\n                for (\n                    uint256 sellIdx = 0;\n                    account.holdingTokens.length > sellIdx;\n                    sellIdx++\n                ) {\n                    address token = account.holdingTokens[sellIdx];\n                    Liquidation storage liquidation = liquidationAmounts[token];\n\n                    if (liquidation.blockNum != block.number) {\n                        liquidation.sell = account.holdings[token];\n                        liquidation.buy = 0;\n                        liquidation.blockNum = block.number;\n                        sellTokens.push(token);\n                    } else {\n                        liquidation.sell += account.holdings[token];\n                    }\n                }\n                for (\n                    uint256 buyIdx = 0;\n                    account.borrowTokens.length > buyIdx;\n                    buyIdx++\n                ) {\n                    address token = account.borrowTokens[buyIdx];\n                    Liquidation storage liquidation = liquidationAmounts[token];\n\n                    (uint256 loanAmount, ) =\n                        Lending(lending()).applyBorrowInterest(\n                            account.borrowed[token],\n                            token,\n                            account.borrowedYieldQuotientsFP[token]\n                        );\n\n                    Lending(lending()).payOff(token, loanAmount);\n\n                    if (liquidation.blockNum != block.number) {\n                        liquidation.sell = 0;\n                        liquidation.buy = loanAmount;\n                        liquidation.blockNum = block.number;\n                        buyTokens.push(token);\n                    } else {\n                        liquidation.buy += loanAmount;\n                    }\n                }\n            }\n\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[traderAddress];\n            if (isAuthorized) {\n                attackReturns += _disburseLiqAttack(liqAttackRecord);\n            }\n        }\n    }\n\n    function _disburseLiqAttack(AccountLiqRecord storage liqAttackRecord)\n        internal\n        returns (uint256 returnAmount)\n    {\n        if (liqAttackRecord.amount > 0) {\n            // validate attack records, if any\n            uint256 blockDiff =\n                min(\n                    block.number - liqAttackRecord.blockNum,\n                    liqStakeAttackWindow\n                );\n\n            uint256 attackerCut =\n                (liqAttackRecord.amount * blockDiff) / liqStakeAttackWindow;\n\n            Fund(fund()).withdraw(\n                PriceAware.peg,\n                liqAttackRecord.stakeAttacker,\n                attackerCut\n            );\n\n            Admin a = Admin(admin());\n            uint256 penalty =\n                (a.maintenanceStakePerBlock() * attackerCut) /\n                    avgLiquidationPerCall;\n            a.penalizeMaintenanceStake(\n                liqAttackRecord.loser,\n                penalty,\n                liqAttackRecord.stakeAttacker\n            );\n\n            // return remainder, after cut was taken to authorized stakekr\n            returnAmount = liqAttackRecord.amount - attackerCut;\n        }\n    }\n\n    /// Disburse liquidity stake attacks\n    function disburseLiqStakeAttacks(address[] memory liquidatedAccounts)\n        external\n    {\n        for (uint256 i = 0; liquidatedAccounts.length > i; i++) {\n            address liqAccount = liquidatedAccounts[i];\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[liqAccount];\n            if (\n                block.number > liqAttackRecord.blockNum + liqStakeAttackWindow\n            ) {\n                _disburseLiqAttack(liqAttackRecord);\n                delete stakeAttackRecords[liqAccount];\n            }\n        }\n    }\n\n    function liquidateFromPeg() internal returns (uint256 pegAmount) {\n        for (uint256 tokenIdx = 0; buyTokens.length > tokenIdx; tokenIdx++) {\n            address buyToken = buyTokens[tokenIdx];\n            Liquidation storage liq = liquidationAmounts[buyToken];\n            if (liq.buy > liq.sell) {\n                pegAmount += PriceAware.liquidateFromPeg(\n                    buyToken,\n                    liq.buy - liq.sell\n                );\n                delete liquidationAmounts[buyToken];\n            }\n        }\n        delete buyTokens;\n    }\n\n    function liquidateToPeg() internal returns (uint256 pegAmount) {\n        for (\n            uint256 tokenIndex = 0;\n            sellTokens.length > tokenIndex;\n            tokenIndex++\n        ) {\n            address token = sellTokens[tokenIndex];\n            Liquidation storage liq = liquidationAmounts[token];\n            if (liq.sell > liq.buy) {\n                uint256 sellAmount = liq.sell - liq.buy;\n                pegAmount += PriceAware.liquidateToPeg(token, sellAmount);\n                delete liquidationAmounts[token];\n            }\n        }\n        delete sellTokens;\n    }\n\n    function maintainerIsFailing() internal view returns (bool) {\n        (address currentMaintainer, ) =\n            Admin(admin()).viewCurrentMaintenanceStaker();\n        return\n            maintenanceFailures[currentMaintainer] >\n            failureThreshold * avgLiquidationPerCall;\n    }\n\n    /// called by maintenance stakers to liquidate accounts below liquidation threshold\n    function liquidate(address[] memory liquidationCandidates)\n        external\n        noIntermediary\n        returns (uint256 maintainerCut)\n    {\n        bool isAuthorized = Admin(admin()).isAuthorizedStaker(msg.sender);\n        bool canTakeNow = isAuthorized || maintainerIsFailing();\n\n        // calcLiquidationAmounts does a lot of the work here\n        // * aggregates both sell and buy side targets to be liquidated\n        // * returns attacker cuts to them\n        // * aggregates any returned fees from unauthorized (attacking) attempts\n        maintainerCut = calcLiquidationAmounts(\n            liquidationCandidates,\n            isAuthorized\n        );\n\n        uint256 sale2pegAmount = liquidateToPeg();\n        uint256 peg2targetCost = liquidateFromPeg();\n\n        // this may be a bit imprecise, since individual shortfalls may be obscured\n        // by overall returns and the maintainer cut is taken out of the net total,\n        // but it gives us the general picture\n        if (\n            (peg2targetCost * (100 + MAINTAINER_CUT_PERCENT)) / 100 >\n            sale2pegAmount\n        ) {\n            emit LiquidationShortfall(\n                (peg2targetCost * (100 + MAINTAINER_CUT_PERCENT)) /\n                    100 -\n                    sale2pegAmount\n            );\n        }\n\n        address loser = address(0);\n        if (!canTakeNow) {\n            // whoever is the current responsible maintenance staker\n            // and liable to lose their stake\n            loser = Admin(admin()).getUpdatedCurrentStaker();\n        }\n\n        // iterate over traders and send back their money\n        // as well as giving attackers their due, in case caller isn't authorized\n        for (\n            uint256 traderIdx = 0;\n            tradersToLiquidate.length > traderIdx;\n            traderIdx++\n        ) {\n            address traderAddress = tradersToLiquidate[traderIdx];\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\n\n            uint256 holdingsValue = holdingsInPeg(account);\n            uint256 borrowValue = loanInPeg(account);\n            // 5% of value borrowed\n            uint256 maintainerCut4Account =\n                (borrowValue * MAINTAINER_CUT_PERCENT) / 100;\n            maintainerCut += maintainerCut4Account;\n\n            if (!canTakeNow) {\n                // This could theoretically lead to a previous attackers\n                // record being overwritten, but only if the trader restarts\n                // their account and goes back into the red within the short time window\n                // which would be a costly attack requiring collusion without upside\n                AccountLiqRecord storage liqAttackRecord =\n                    stakeAttackRecords[traderAddress];\n                liqAttackRecord.amount = maintainerCut4Account;\n                liqAttackRecord.stakeAttacker = msg.sender;\n                liqAttackRecord.blockNum = block.number;\n                liqAttackRecord.loser = loser;\n            }\n\n            // send back trader money\n            if (holdingsValue >= maintainerCut4Account + borrowValue) {\n                // send remaining funds back to trader\n                Fund(fund()).withdraw(\n                    PriceAware.peg,\n                    traderAddress,\n                    holdingsValue - borrowValue - maintainerCut4Account\n                );\n            }\n\n            emit AccountLiquidated(traderAddress);\n            deleteAccount(account);\n        }\n\n        avgLiquidationPerCall =\n            (avgLiquidationPerCall * 99 + maintainerCut) /\n            100;\n\n        if (canTakeNow) {\n            Fund(fund()).withdraw(PriceAware.peg, msg.sender, maintainerCut);\n        }\n\n        address currentMaintainer = Admin(admin()).getUpdatedCurrentStaker();\n        if (isAuthorized) {\n            if (maintenanceFailures[currentMaintainer] > maintainerCut) {\n                maintenanceFailures[currentMaintainer] -= maintainerCut;\n            } else {\n                maintenanceFailures[currentMaintainer] = 0;\n            }\n        } else {\n            maintenanceFailures[currentMaintainer] += maintainerCut;\n        }\n    }\n}\n"
    },
    "contracts/HourlyBondSubscriptionLending.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./BaseLending.sol\";\n\nstruct HourlyBond {\n    uint256 amount;\n    uint256 yieldQuotientFP;\n    uint256 moduloHour;\n}\n\n/// @title Here we offer subscriptions to auto-renewing hourly bonds\n/// Funds are locked in for an 50 minutes per hour, while interest rates float\nabstract contract HourlyBondSubscriptionLending is BaseLending {\n    struct HourlyBondMetadata {\n        YieldAccumulator yieldAccumulator;\n        uint256 buyingSpeed;\n        uint256 withdrawingSpeed;\n        uint256 lastBought;\n        uint256 lastWithdrawn;\n    }\n\n    mapping(address => HourlyBondMetadata) hourlyBondMetadata;\n\n    uint256 public withdrawalWindow = 10 minutes;\n    // issuer => holder => bond record\n    mapping(address => mapping(address => HourlyBond))\n        public hourlyBondAccounts;\n\n    uint256 public borrowingFactorPercent = 200;\n\n    function _makeHourlyBond(\n        address issuer,\n        address holder,\n        uint256 amount\n    ) internal {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][holder];\n        updateHourlyBondAmount(issuer, bond);\n\n        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];\n        bond.yieldQuotientFP = bondMeta.yieldAccumulator.accumulatorFP;\n        bond.moduloHour = block.timestamp % (1 hours);\n        bond.amount += amount;\n        lendingMeta[issuer].totalLending += amount;\n\n        (bondMeta.buyingSpeed, bondMeta.lastBought) = updateSpeed(\n            bondMeta.buyingSpeed,\n            bondMeta.lastBought,\n            amount,\n            1 hours\n        );\n    }\n\n    function updateHourlyBondAmount(address issuer, HourlyBond storage bond)\n        internal\n    {\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\n        if (yieldQuotientFP > 0) {\n            YieldAccumulator storage yA =\n                getUpdatedHourlyYield(issuer, hourlyBondMetadata[issuer]);\n\n            uint256 oldAmount = bond.amount;\n            bond.amount = applyInterest(\n                bond.amount,\n                yA.accumulatorFP,\n                yieldQuotientFP\n            );\n\n            uint256 deltaAmount = bond.amount - oldAmount;\n            lendingMeta[issuer].totalLending += deltaAmount;\n        }\n    }\n\n    // Retrieves bond balance for issuer and holder\n    function viewHourlyBondAmount(address issuer, address holder)\n        public\n        view\n        returns (uint256)\n    {\n        HourlyBond storage bond = hourlyBondAccounts[issuer][holder];\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\n\n        uint256 cumulativeYield =\n            viewCumulativeYieldFP(\n                hourlyBondMetadata[issuer].yieldAccumulator,\n                block.timestamp\n            );\n\n        if (yieldQuotientFP > 0) {\n            return\n                bond.amount +\n                applyInterest(bond.amount, cumulativeYield, yieldQuotientFP);\n        }\n        return bond.amount + 0;\n    }\n\n    function _withdrawHourlyBond(\n        address issuer,\n        HourlyBond storage bond,\n        uint256 amount\n    ) internal {\n        // how far the current hour has advanced (relative to acccount hourly clock)\n        uint256 currentOffset = (block.timestamp - bond.moduloHour) % (1 hours);\n\n        require(\n            withdrawalWindow >= currentOffset,\n            \"Tried withdrawing outside subscription cancellation time window\"\n        );\n\n        bond.amount -= amount;\n        lendingMeta[issuer].totalLending -= amount;\n\n        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];\n        (bondMeta.withdrawingSpeed, bondMeta.lastWithdrawn) = updateSpeed(\n            bondMeta.withdrawingSpeed,\n            bondMeta.lastWithdrawn,\n            bond.amount,\n            1 hours\n        );\n    }\n\n    function calcCumulativeYieldFP(\n        YieldAccumulator storage yieldAccumulator,\n        uint256 timeDelta\n    ) internal view returns (uint256 accumulatorFP) {\n        uint256 secondsDelta = timeDelta % (1 hours);\n        // linearly interpolate interest for seconds\n        // accumulator * hourly_yield == seconds_per_hour * accumulator * hourly_yield / seconds_per_hour\n        // FP * FP * 1 / (FP * 1) = FP\n        accumulatorFP =\n            (yieldAccumulator.accumulatorFP *\n                yieldAccumulator.hourlyYieldFP *\n                secondsDelta) /\n            (FP32 * 1 hours);\n\n        uint256 hoursDelta = timeDelta / (1 hours);\n        if (hoursDelta > 0) {\n            // This loop should hardly ever 1 or more unless something bad happened\n            // In which case it costs gas but there isn't overflow\n            for (uint256 i = 0; hoursDelta > i; i++) {\n                // FP32 * FP32 / FP32 = FP32\n                accumulatorFP =\n                    (accumulatorFP * yieldAccumulator.hourlyYieldFP) /\n                    FP32;\n            }\n        }\n    }\n\n    /// @dev updates yield accumulators for both borrowing and lending\n    function getUpdatedHourlyYield(\n        address issuer,\n        HourlyBondMetadata storage bondMeta\n    ) internal returns (YieldAccumulator storage accumulator) {\n        accumulator = bondMeta.yieldAccumulator;\n        uint256 lastUpdated = accumulator.lastUpdated;\n        uint256 timeDelta = (block.timestamp - lastUpdated);\n\n        YieldAccumulator storage borrowAccumulator =\n            borrowYieldAccumulators[issuer];\n\n        if (timeDelta > (5 minutes)) {\n            accumulator.accumulatorFP = calcCumulativeYieldFP(\n                accumulator,\n                timeDelta\n            );\n\n            LendingMetadata storage meta = lendingMeta[issuer];\n\n            uint256 yieldGeneratedFP =\n                (borrowAccumulator.hourlyYieldFP * meta.totalBorrowed) /\n                    (1 + meta.totalLending);\n            uint256 _maxHourlyYieldFP = min(maxHourlyYieldFP, yieldGeneratedFP);\n\n            accumulator.hourlyYieldFP = updatedYieldFP(\n                accumulator.hourlyYieldFP,\n                lastUpdated,\n                meta.totalLending,\n                lendingTarget(meta),\n                bondMeta.buyingSpeed,\n                bondMeta.withdrawingSpeed,\n                _maxHourlyYieldFP\n            );\n            accumulator.lastUpdated = block.timestamp;\n        }\n\n        updateBorrowYieldAccu(borrowAccumulator);\n\n        borrowAccumulator.hourlyYieldFP =\n            1 +\n            (borrowingFactorPercent * accumulator.hourlyYieldFP) /\n            100;\n    }\n\n    function updateBorrowYieldAccu(YieldAccumulator storage borrowAccumulator)\n        internal\n    {\n        uint256 timeDelta = block.timestamp - borrowAccumulator.lastUpdated;\n\n        if (timeDelta > (5 minutes)) {\n            borrowAccumulator.accumulatorFP = calcCumulativeYieldFP(\n                borrowAccumulator,\n                timeDelta\n            );\n\n            borrowAccumulator.lastUpdated = block.timestamp;\n        }\n    }\n\n    function getUpdatedBorrowYieldAccuFP(address issuer)\n        external\n        returns (uint256)\n    {\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\n        updateBorrowYieldAccu(yA);\n        return yA.accumulatorFP;\n    }\n\n    function viewCumulativeYieldFP(\n        YieldAccumulator storage yA,\n        uint256 timestamp\n    ) internal view returns (uint256) {\n        uint256 timeDelta = (timestamp - yA.lastUpdated);\n        if (timeDelta > 5 minutes) {\n            return calcCumulativeYieldFP(yA, timeDelta);\n        } else {\n            return yA.accumulatorFP;\n        }\n    }\n}\n"
    },
    "contracts/BondLending.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./BaseLending.sol\";\n\nstruct Bond {\n    address holder;\n    address issuer;\n    uint256 originalPrice;\n    uint256 returnAmount;\n    uint256 maturityTimestamp;\n    uint256 runtime;\n    uint256 yieldFP;\n}\n\n/** \n@title Lending for fixed runtime, fixed interest\nLenders can pick their own bond maturity date\n@dev In order to manage interest rates for the different\nmaturities and create a yield curve we bucket\nbond runtimes into weighted baskets and adjust\nrates individually per bucket, based on supply and demand.\n*/\nabstract contract BondLending is BaseLending {\n    uint256 public minRuntime = 30 days;\n    uint256 public maxRuntime = 365 days;\n    uint256 public diffMaxMinRuntime;\n    /** \n    @dev this is the numerator under runtimeWeights.\n    any excess left over is the weight of hourly bonds\n    */\n    uint256 public constant WEIGHT_TOTAL_10k = 10_000;\n    uint256 public borrowingMarkupFP;\n\n    struct BondBucketMetadata {\n        uint256 runtimeWeight;\n        uint256 buyingSpeed;\n        uint256 lastBought;\n        uint256 withdrawingSpeed;\n        uint256 lastWithdrawn;\n        uint256 yieldLastUpdated;\n        uint256 totalLending;\n        uint256 runtimeYieldFP;\n    }\n\n    mapping(uint256 => Bond) public bonds;\n\n    mapping(address => BondBucketMetadata[]) public bondBucketMetadata;\n\n    uint256 public nextBondIndex = 1;\n\n    event LiquidityWarning(\n        address indexed issuer,\n        address indexed holder,\n        uint256 value\n    );\n\n    function _makeBond(\n        address holder,\n        address issuer,\n        uint256 runtime,\n        uint256 amount,\n        uint256 minReturn\n    ) internal returns (uint256 bondIndex) {\n        uint256 bucketIndex = getBucketIndex(issuer, runtime);\n        BondBucketMetadata storage bondMeta =\n            bondBucketMetadata[issuer][bucketIndex];\n\n        uint256 yieldFP = calcBondYieldFP(issuer, amount, runtime, bondMeta);\n\n        uint256 bondReturn = (yieldFP * amount) / FP32;\n        if (bondReturn >= minReturn) {\n            uint256 interpolatedAmount = (amount + bondReturn) / 2;\n            lendingMeta[issuer].totalLending += interpolatedAmount;\n\n            bondMeta.totalLending += interpolatedAmount;\n\n            bondIndex = nextBondIndex;\n            nextBondIndex++;\n\n            bonds[bondIndex] = Bond({\n                holder: holder,\n                issuer: issuer,\n                originalPrice: amount,\n                returnAmount: bondReturn,\n                maturityTimestamp: block.timestamp + runtime,\n                runtime: runtime,\n                yieldFP: yieldFP\n            });\n\n            (bondMeta.buyingSpeed, bondMeta.lastBought) = updateSpeed(\n                bondMeta.buyingSpeed,\n                bondMeta.lastBought,\n                amount,\n                runtime\n            );\n        }\n    }\n\n    function _withdrawBond(uint256 bondId, Bond storage bond)\n        internal\n        returns (uint256 withdrawAmount)\n    {\n        address issuer = bond.issuer;\n        uint256 bucketIndex = getBucketIndex(issuer, bond.runtime);\n        BondBucketMetadata storage bondMeta =\n            bondBucketMetadata[issuer][bucketIndex];\n\n        uint256 returnAmount = bond.returnAmount;\n        address holder = bond.holder;\n\n        uint256 interpolatedAmount = (bond.originalPrice + returnAmount) / 2;\n\n        LendingMetadata storage meta = lendingMeta[issuer];\n        meta.totalLending -= interpolatedAmount;\n        bondMeta.totalLending -= interpolatedAmount;\n\n        (bondMeta.withdrawingSpeed, bondMeta.lastWithdrawn) = updateSpeed(\n            bondMeta.withdrawingSpeed,\n            bondMeta.lastWithdrawn,\n            bond.originalPrice,\n            bond.runtime\n        );\n\n        delete bonds[bondId];\n        if (\n            meta.totalBorrowed > meta.totalLending ||\n            issuanceBalance(issuer) < returnAmount\n        ) {\n            // apparently there is a liquidity issue\n            emit LiquidityWarning(issuer, holder, returnAmount);\n            _makeFallbackBond(issuer, holder, returnAmount);\n        } else {\n            withdrawAmount = returnAmount;\n        }\n    }\n\n    function calcBondYieldFP(\n        address issuer,\n        uint256 addedAmount,\n        uint256 runtime,\n        BondBucketMetadata storage bucketMeta\n    ) internal view returns (uint256 yieldFP) {\n        uint256 totalLendingInBucket = addedAmount + bucketMeta.totalLending;\n\n        yieldFP = bucketMeta.runtimeYieldFP;\n        uint256 lastUpdated = bucketMeta.yieldLastUpdated;\n\n        LendingMetadata storage meta = lendingMeta[issuer];\n        uint256 bucketTarget =\n            (lendingTarget(meta) * bucketMeta.runtimeWeight) / WEIGHT_TOTAL_10k;\n\n        uint256 buying = bucketMeta.buyingSpeed;\n        uint256 withdrawing = bucketMeta.withdrawingSpeed;\n\n        YieldAccumulator storage borrowAccumulator =\n            borrowYieldAccumulators[issuer];\n\n        uint256 yieldGeneratedFP =\n            (borrowAccumulator.hourlyYieldFP * meta.totalBorrowed) /\n                (1 + meta.totalLending);\n        uint256 _maxHourlyYieldFP = min(maxHourlyYieldFP, yieldGeneratedFP);\n\n        uint256 bucketMaxYield = _maxHourlyYieldFP * (runtime / (1 hours));\n\n        yieldFP = updatedYieldFP(\n            yieldFP,\n            lastUpdated,\n            totalLendingInBucket,\n            bucketTarget,\n            buying,\n            withdrawing,\n            bucketMaxYield\n        );\n    }\n\n    /// Get view of returns on bond\n    function viewBondReturn(\n        address issuer,\n        uint256 runtime,\n        uint256 amount\n    ) external view returns (uint256) {\n        uint256 bucketIndex = getBucketIndex(issuer, runtime);\n        uint256 yieldFP =\n            calcBondYieldFP(\n                issuer,\n                amount + bondBucketMetadata[issuer][bucketIndex].totalLending,\n                runtime,\n                bondBucketMetadata[issuer][bucketIndex]\n            );\n        return (yieldFP * amount) / FP32;\n    }\n\n    function getBucketIndex(address issuer, uint256 runtime)\n        internal\n        view\n        returns (uint256 bucketIndex)\n    {\n        uint256 bucketSize =\n            diffMaxMinRuntime / bondBucketMetadata[issuer].length;\n        bucketIndex = (runtime - minRuntime) / bucketSize;\n    }\n}\n"
    },
    "contracts/IncentivizedHolder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./IncentiveDistribution.sol\";\nimport \"./RoleAware.sol\";\n\n/// @title helper class to facilitate staking and unstaking\n/// within the incentive system.\nabstract contract IncentivizedHolder is RoleAware {\n    /// @dev here we cache incentive tranches to save on a bit of gas\n    mapping(address => uint256) public incentiveTranches;\n\n    /// Set incentive tranche\n    function setIncentiveTranche(address token, uint8 tranche)\n        external\n        onlyOwnerExecActivator\n    {\n        incentiveTranches[token] = tranche;\n    }\n\n    function stakeClaim(\n        address claimant,\n        address token,\n        uint256 amount\n    ) internal {\n        IncentiveDistribution iD =\n            IncentiveDistribution(incentiveDistributor());\n\n        uint256 tranche = incentiveTranches[token];\n\n        iD.addToClaimAmount(tranche, claimant, amount);\n    }\n\n    function withdrawClaim(\n        address claimant,\n        address token,\n        uint256 amount\n    ) internal {\n        uint256 tranche = incentiveTranches[token];\n\n        IncentiveDistribution(incentiveDistributor()).subtractFromClaimAmount(\n            tranche,\n            claimant,\n            amount\n        );\n    }\n}\n"
    },
    "contracts/BaseLending.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./RoleAware.sol\";\n\n/// @title Base lending behavior\nabstract contract BaseLending {\n    uint256 constant FP32 = 2**32;\n    uint256 constant ACCUMULATOR_INIT = 10**18;\n\n    struct YieldAccumulator {\n        uint256 accumulatorFP;\n        uint256 lastUpdated;\n        uint256 hourlyYieldFP;\n    }\n\n    struct LendingMetadata {\n        uint256 totalLending;\n        uint256 totalBorrowed;\n        uint256 lendingBuffer;\n        uint256 lendingCap;\n    }\n    mapping(address => LendingMetadata) public lendingMeta;\n\n    /// @dev accumulate interest per issuer (like compound indices)\n    mapping(address => YieldAccumulator) public borrowYieldAccumulators;\n\n    uint256 public maxHourlyYieldFP;\n    uint256 public yieldChangePerSecondFP;\n\n    /// @dev simple formula for calculating interest relative to accumulator\n    function applyInterest(\n        uint256 balance,\n        uint256 accumulatorFP,\n        uint256 yieldQuotientFP\n    ) internal pure returns (uint256) {\n        // 1 * FP / FP = 1\n        return (balance * accumulatorFP) / yieldQuotientFP;\n    }\n\n    /// update the yield for an asset based on recent supply and demand\n    function updatedYieldFP(\n        // previous yield\n        uint256 _yieldFP,\n        // timestamp\n        uint256 lastUpdated,\n        uint256 totalLendingInBucket,\n        uint256 bucketTarget,\n        uint256 buyingSpeed,\n        uint256 withdrawingSpeed,\n        uint256 bucketMaxYield\n    ) internal view returns (uint256 yieldFP) {\n        yieldFP = _yieldFP;\n        uint256 timeDiff = block.timestamp - lastUpdated;\n        uint256 yieldDiff = timeDiff * yieldChangePerSecondFP;\n\n        if (\n            totalLendingInBucket >= bucketTarget ||\n            buyingSpeed >= withdrawingSpeed\n        ) {\n            yieldFP -= min(yieldFP, yieldDiff);\n        } else {\n            yieldFP += yieldDiff;\n            if (yieldFP > bucketMaxYield) {\n                yieldFP = bucketMaxYield;\n            }\n        }\n    }\n\n    function updateSpeed(\n        uint256 speed,\n        uint256 lastAction,\n        uint256 amount,\n        uint256 runtime\n    ) internal view returns (uint256 newSpeed, uint256 newLastAction) {\n        uint256 timeDiff = block.timestamp - lastAction;\n        uint256 updateAmount = (amount * runtime) / (timeDiff + 1);\n\n        uint256 oldSpeedWeight = (runtime + 120 minutes) / 3;\n        uint256 updateWeight = timeDiff + 1;\n        // scale adjustment relative to runtime\n        newSpeed =\n            (speed * oldSpeedWeight + updateAmount * updateWeight) /\n            (oldSpeedWeight + updateWeight);\n        newLastAction = block.timestamp;\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n\n    function _makeFallbackBond(\n        address issuer,\n        address holder,\n        uint256 amount\n    ) internal virtual;\n\n    function lendingTarget(LendingMetadata storage meta)\n        internal\n        view\n        returns (uint256)\n    {\n        return min(meta.lendingCap, meta.totalBorrowed + meta.lendingBuffer);\n    }\n\n    /// View lending target\n    function viewLendingTarget(address issuer) external view returns (uint256) {\n        LendingMetadata storage meta = lendingMeta[issuer];\n        return lendingTarget(meta);\n    }\n\n    /// Available tokens to this issuance\n    function issuanceBalance(address issuance)\n        internal\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/CrossMarginAccounts.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./PriceAware.sol\";\n\n// Goal: all external functions only accessible to margintrader role\n// except for view functions of course\n\nstruct CrossMarginAccount {\n    uint256 lastDepositBlock;\n    address[] borrowTokens;\n    // borrowed token address => amount\n    mapping(address => uint256) borrowed;\n    // borrowed token => yield quotient\n    mapping(address => uint256) borrowedYieldQuotientsFP;\n    address[] holdingTokens;\n    // token held in portfolio => amount\n    mapping(address => uint256) holdings;\n    // boolean value of whether an account holds a token\n    mapping(address => bool) holdsToken;\n}\n\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\n    /// @dev gets used in calculating how much accounts can borrow\n    uint256 public leveragePercent;\n\n    /// @dev percentage of assets held per assets borrowed at which to liquidate\n    uint256 public liquidationThresholdPercent;\n\n    /// @dev record of all cross margin accounts\n    mapping(address => CrossMarginAccount) internal marginAccounts;\n    /// @dev total token caps\n    mapping(address => uint256) public tokenCaps;\n    /// @dev tracks total of short positions per token\n    mapping(address => uint256) public totalShort;\n    /// @dev tracks total of long positions per token\n    mapping(address => uint256) public totalLong;\n    uint256 public coolingOffPeriod;\n\n    /// @dev add an asset to be held by account\n    function addHolding(\n        CrossMarginAccount storage account,\n        address token,\n        uint256 depositAmount\n    ) internal {\n        if (!hasHoldingToken(account, token)) {\n            account.holdingTokens.push(token);\n        }\n\n        account.holdings[token] += depositAmount;\n    }\n\n    /// @dev adjust account to reflect borrowing of token amount\n    function borrow(\n        CrossMarginAccount storage account,\n        address borrowToken,\n        uint256 borrowAmount\n    ) internal {\n        if (!hasBorrowedToken(account, borrowToken)) {\n            account.borrowTokens.push(borrowToken);\n            account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\n                .getUpdatedBorrowYieldAccuFP(borrowToken);\n\n            account.borrowed[borrowToken] = borrowAmount;\n        } else {\n            (uint256 oldBorrowed, uint256 accumulatorFP) =\n                Lending(lending()).applyBorrowInterest(\n                    account.borrowed[borrowToken],\n                    borrowToken,\n                    account.borrowedYieldQuotientsFP[borrowToken]\n                );\n            account.borrowedYieldQuotientsFP[borrowToken] = accumulatorFP;\n\n            account.borrowed[borrowToken] = oldBorrowed + borrowAmount;\n        }\n\n        addHolding(account, borrowToken, borrowAmount);\n\n        require(positiveBalance(account), \"Can't borrow: insufficient balance\");\n    }\n\n    /// @dev checks whether account is in the black, deposit + earnings relative to borrowed\n    function positiveBalance(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account);\n        uint256 holdings = holdingsInPeg(account);\n        // The following condition should hold:\n        // holdings / loan >= leveragePercent / (leveragePercent - 100)\n        // =>\n        return holdings * (leveragePercent - 100) >= loan * leveragePercent;\n    }\n\n    /// @dev internal function adjusting holding and borrow balances when debt extinguished\n    function extinguishDebt(\n        CrossMarginAccount storage account,\n        address debtToken,\n        uint256 extinguishAmount\n    ) internal {\n        // will throw if insufficient funds\n        (uint256 borrowAmount, uint256 newYieldQuot) =\n            Lending(lending()).applyBorrowInterest(\n                account.borrowed[debtToken],\n                debtToken,\n                account.borrowedYieldQuotientsFP[debtToken]\n            );\n\n        uint256 newBorrowAmount = borrowAmount - extinguishAmount;\n        account.borrowed[debtToken] = newBorrowAmount;\n\n        account.holdings[debtToken] =\n            account.holdings[debtToken] -\n            extinguishAmount;\n\n        if (newBorrowAmount > 0) {\n            account.borrowedYieldQuotientsFP[debtToken] = newYieldQuot;\n        } else {\n            delete account.borrowedYieldQuotientsFP[debtToken];\n\n            bool decrement = false;\n            uint256 len = account.borrowTokens.length;\n            for (uint256 i; len > i; i++) {\n                address currToken = account.borrowTokens[i];\n                if (currToken == debtToken) {\n                    decrement = true;\n                } else if (decrement) {\n                    account.borrowTokens[i - 1] = currToken;\n                }\n            }\n            account.borrowTokens.pop();\n        }\n    }\n\n    /// @dev checks whether an account holds a token\n    function hasHoldingToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.holdsToken[token];\n    }\n\n    /// @dev checks whether an account has borrowed a token\n    function hasBorrowedToken(CrossMarginAccount storage account, address token)\n        internal\n        view\n        returns (bool)\n    {\n        return account.borrowedYieldQuotientsFP[token] > 0;\n    }\n\n    /// @dev calculate total loan in reference currency, including compound interest\n    function loanInPeg(CrossMarginAccount storage account)\n        internal\n        returns (uint256)\n    {\n        return\n            sumTokensInPegWithYield(\n                account.borrowTokens,\n                account.borrowed,\n                account.borrowedYieldQuotientsFP\n            );\n    }\n\n    /// @dev total of assets of account, expressed in reference currency\n    function holdingsInPeg(\n        CrossMarginAccount storage account\n    ) internal returns (uint256) {\n        return\n            sumTokensInPeg(\n                account.holdingTokens,\n                account.holdings\n            );\n    }\n\n    /// @dev check whether an account can/should be liquidated\n    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account);\n        uint256 holdings = holdingsInPeg(account);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function sumTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts\n    ) internal returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.getCurrentPriceInPeg(\n                token,\n                amounts[token]\n            );\n        }\n    }\n\n    /// @dev go through list of tokens and their amounts, summing up\n    function viewTokensInPeg(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts\n    ) internal view returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += PriceAware.viewCurrentPriceInPeg(token, amounts[token]);\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function sumTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += yieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP\n            );\n        }\n    }\n\n    /// @dev go through list of tokens and ammounts, summing up with interest\n    function viewTokensInPegWithYield(\n        address[] storage tokens,\n        mapping(address => uint256) storage amounts,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal view returns (uint256 totalPeg) {\n        uint256 len = tokens.length;\n        for (uint256 tokenId; tokenId < len; tokenId++) {\n            address token = tokens[tokenId];\n            totalPeg += viewYieldTokenInPeg(\n                token,\n                amounts[token],\n                yieldQuotientsFP\n            );\n        }\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function yieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal returns (uint256) {\n        uint256 yieldFP =\n            Lending(lending()).viewAccumulatedBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return\n            PriceAware.getCurrentPriceInPeg(\n                token,\n                amountInToken\n            );\n    }\n\n    /// @dev calculate yield for token amount and convert to reference currency\n    function viewYieldTokenInPeg(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage yieldQuotientsFP\n    ) internal view returns (uint256) {\n        uint256 yieldFP =\n            Lending(lending()).viewAccumulatedBorrowingYieldFP(token);\n        // 1 * FP / FP = 1\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n        return PriceAware.viewCurrentPriceInPeg(token, amountInToken);\n    }\n\n    /// @dev move tokens from one holding to another\n    function adjustAmounts(\n        CrossMarginAccount storage account,\n        address fromToken,\n        address toToken,\n        uint256 soldAmount,\n        uint256 boughtAmount\n    ) internal {\n        account.holdings[fromToken] = account.holdings[fromToken] - soldAmount;\n        addHolding(account, toToken, boughtAmount);\n    }\n\n    /// sets borrow and holding to zero\n    function deleteAccount(CrossMarginAccount storage account) internal {\n        uint256 len = account.borrowTokens.length;\n        for (uint256 borrowIdx; len > borrowIdx; borrowIdx++) {\n            address borrowToken = account.borrowTokens[borrowIdx];\n            totalShort[borrowToken] -= account.borrowed[borrowToken];\n            account.borrowed[borrowToken] = 0;\n            account.borrowedYieldQuotientsFP[borrowToken] = 0;\n        }\n        len = account.holdingTokens.length;\n        for (uint256 holdingIdx; len > holdingIdx; holdingIdx++) {\n            address holdingToken = account.holdingTokens[holdingIdx];\n            totalLong[holdingToken] -= account.holdings[holdingToken];\n            account.holdings[holdingToken] = 0;\n            account.holdsToken[holdingToken] = false;\n        }\n        delete account.borrowTokens;\n        delete account.holdingTokens;\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n}\n"
    },
    "contracts/PriceAware.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"../libraries/UniswapStyleLib.sol\";\n\n/// Stores how many of token you could get for 1k of peg\nstruct TokenPrice {\n    uint256 blockLastUpdated;\n    uint256 tokenPerRefAmount;\n    address[] liquidationTokens;\n    bytes32 amms;\n    address[] inverseLiquidationTokens;\n    bytes32 inverseAmms;\n}\n\n/// @title The protocol features several mechanisms to prevent vulnerability to\n/// price manipulation:\n/// 1) global exposure caps on all tokens which need to be raised gradually\n///    during the process of introducing a new token, making attacks unprofitable\n///    due to lack  of scale\n/// 2) Exponential moving average with cautious price update. Prices for estimating\n///    how much a trader can borrow need not be extremely current and precise, mainly\n///    they must be resilient against extreme manipulation\n/// 3) Liquidators may not call from a contract address, to prevent extreme forms of\n///    of front-running and other price manipulation.\nabstract contract PriceAware is RoleAware {\n    uint256 constant pegDecimals = 6;\n    uint256 constant REFERENCE_PEG_AMOUNT = 100 * (10 ** pegDecimals);\n    address public immutable peg;\n    mapping(address => TokenPrice) public tokenPrices;\n    /// update window in blocks\n    uint16 public priceUpdateWindow = 20;\n    uint256 public UPDATE_RATE_PERMIL = 50;\n\n    constructor(address _peg) {\n        peg = _peg;\n    }\n\n    /// Set window for price updates\n    function setPriceUpdateWindow(uint16 window) external onlyOwnerExec {\n        priceUpdateWindow = window;\n    }\n\n    /// Set rate for updates\n    function setUpdateRate(uint256 rate) external onlyOwnerExec {\n        UPDATE_RATE_PERMIL = rate;\n    }\n\n    /// Get current price of token in peg\n    function getCurrentPriceInPeg(\n        address token,\n        uint256 inAmount\n    ) public returns (uint256) {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n\n            if (block.number - tokenPrice.blockLastUpdated > priceUpdateWindow\n                || tokenPrice.tokenPerRefAmount == 0) {\n                // update the currently cached price\n                getPriceFromAMM(tokenPrice);\n            }\n\n            return (inAmount * REFERENCE_PEG_AMOUNT) / (tokenPrice.tokenPerRefAmount + 1);\n        }\n    }\n\n    /// Get view of current price of token in peg\n    function viewCurrentPriceInPeg(address token, uint256 inAmount)\n        public\n        view\n        returns (uint256)\n    {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n            return (inAmount * REFERENCE_PEG_AMOUNT) / (tokenPrice.tokenPerRefAmount + 1);\n        }\n    }\n\n    /// @dev retrieves the price from the AMM\n    function getPriceFromAMM(TokenPrice storage tokenPrice)\n        internal\n        virtual\n    {\n        (uint256[] memory pathAmounts, ) =\n            UniswapStyleLib.getAmountsIn(\n                REFERENCE_PEG_AMOUNT,\n                tokenPrice.amms,\n                tokenPrice.liquidationTokens\n            );\n        _setPriceVal(tokenPrice, pathAmounts[0], UPDATE_RATE_PERMIL);\n    }\n\n    function _setPriceVal(TokenPrice storage tokenPrice, uint256 updatePerRefAmount, uint256 weightPerMil) internal {\n        tokenPrice.tokenPerRefAmount =\n            (tokenPrice.tokenPerRefAmount *\n                (1000 - weightPerMil) +\n                updatePerRefAmount *\n                weightPerMil) /\n            1000;\n    }\n\n    /// add path from token to current liquidation peg\n    function setLiquidationPath(bytes32 amms, address[] memory tokens)\n        external\n        onlyOwnerExecActivator\n    {\n        address token = tokens[0];\n\n        if (token != peg) {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n\n            tokenPrice.amms = amms;\n\n            tokenPrice.liquidationTokens = tokens;\n            tokenPrice.inverseLiquidationTokens = new address[](tokens.length);\n\n            bytes32 inverseAmms;\n\n            for (uint256 i = 0; tokens.length - 1 > i; i++) {\n                bytes32 shifted =\n                    bytes32(amms[i]) >> ((tokens.length - 2 - i) * 8);\n                inverseAmms = inverseAmms | shifted;\n            }\n\n            tokenPrice.inverseAmms = inverseAmms;\n\n            for (uint256 i = 0; tokens.length > i; i++) {\n                tokenPrice.inverseLiquidationTokens[i] = tokens[\n                    tokens.length - i - 1\n                ];\n            }\n\n            (uint256[] memory pathAmounts, ) =\n                UniswapStyleLib.getAmountsIn(REFERENCE_PEG_AMOUNT, amms, tokens);\n            uint256 inAmount = pathAmounts[0];\n\n            _setPriceVal(tokenPrice, inAmount, 1000);\n        }\n    }\n\n    function liquidateToPeg(address token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return amount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(marginRouter()).authorizedSwapExactT4T(\n                    amount,\n                    0,\n                    tP.amms,\n                    tP.liquidationTokens\n                );\n\n            uint256 outAmount = amounts[amounts.length - 1];\n\n            return outAmount;\n        }\n    }\n\n    function liquidateFromPeg(address token, uint256 targetAmount)\n        internal\n        returns (uint256)\n    {\n        if (token == peg) {\n            return targetAmount;\n        } else {\n            TokenPrice storage tP = tokenPrices[token];\n            uint256[] memory amounts =\n                MarginRouter(marginRouter()).authorizedSwapT4ExactT(\n                    targetAmount,\n                    type(uint256).max,\n                    tP.amms,\n                    tP.inverseLiquidationTokens\n                );\n\n            return amounts[0];\n        }\n    }\n}\n"
    },
    "contracts/MarginRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\n\nimport \"./RoleAware.sol\";\nimport \"../interfaces/IMarginTrading.sol\";\nimport \"./Lending.sol\";\nimport \"./Admin.sol\";\nimport \"./IncentivizedHolder.sol\";\nimport \"./BaseRouter.sol\";\n\n/// @title Top level transaction controller\ncontract MarginRouter is RoleAware, IncentivizedHolder, BaseRouter {\n    /// emitted when a trader depoits on cross margin\n    event CrossDeposit(\n        address trader,\n        address depositToken,\n        uint256 depositAmount\n    );\n    /// emitted whenever a trade happens\n    event CrossTrade(\n        address trader,\n        address inToken,\n        uint256 inTokenAmount,\n        uint256 inTokenBorrow,\n        address outToken,\n        uint256 outTokenAmount,\n        uint256 outTokenExtinguish\n    );\n    /// emitted when a trader withdraws funds\n    event CrossWithdraw(\n        address trader,\n        address withdrawToken,\n        uint256 withdrawAmount\n    );\n    /// emitted upon sucessfully borrowing\n    event CrossBorrow(\n        address trader,\n        address borrowToken,\n        uint256 borrowAmount\n    );\n\n    /// emmited on deposit-borrow-withdraw\n    event CrossOvercollateralizedBorrow(\n        address trader,\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    );\n    uint256 public constant mswapFeesPer10k = 10;\n    address public immutable WETH;\n\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\n        WETH = _WETH;\n    }\n\n    ///////////////////////////\n    // Cross margin endpoints\n    ///////////////////////////\n\n    /// @notice traders call this to deposit funds on cross margin\n    function crossDeposit(address depositToken, uint256 depositAmount)\n        external\n    {\n        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);\n\n        uint256 extinguishAmount =\n            IMarginTrading(crossMarginTrading()).registerDeposit(\n                msg.sender,\n                depositToken,\n                depositAmount\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(depositToken, extinguishAmount);\n            withdrawClaim(msg.sender, depositToken, extinguishAmount);\n        }\n        emit CrossDeposit(msg.sender, depositToken, depositAmount);\n    }\n\n    /// @notice deposit wrapped ehtereum into cross margin account\n    function crossDepositETH() external payable {\n        Fund(fund()).depositToWETH{value: msg.value}();\n        uint256 extinguishAmount =\n            IMarginTrading(crossMarginTrading()).registerDeposit(\n                msg.sender,\n                WETH,\n                msg.value\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(WETH, extinguishAmount);\n            withdrawClaim(msg.sender, WETH, extinguishAmount);\n        }\n        emit CrossDeposit(msg.sender, WETH, msg.value);\n    }\n\n    /// @notice withdraw deposits/earnings from cross margin account\n    function crossWithdraw(address withdrawToken, uint256 withdrawAmount)\n        external\n    {\n        IMarginTrading(crossMarginTrading()).registerWithdrawal(\n            msg.sender,\n            withdrawToken,\n            withdrawAmount\n        );\n        Fund(fund()).withdraw(withdrawToken, msg.sender, withdrawAmount);\n        emit CrossWithdraw(msg.sender, withdrawToken, withdrawAmount);\n    }\n\n    /// @notice withdraw ethereum from cross margin account\n    function crossWithdrawETH(uint256 withdrawAmount) external {\n        IMarginTrading(crossMarginTrading()).registerWithdrawal(\n            msg.sender,\n            WETH,\n            withdrawAmount\n        );\n        Fund(fund()).withdrawETH(msg.sender, withdrawAmount);\n    }\n\n    /// @notice borrow into cross margin trading account\n    function crossBorrow(address borrowToken, uint256 borrowAmount) external {\n        Lending(lending()).registerBorrow(borrowToken, borrowAmount);\n        IMarginTrading(crossMarginTrading()).registerBorrow(\n            msg.sender,\n            borrowToken,\n            borrowAmount\n        );\n\n        stakeClaim(msg.sender, borrowToken, borrowAmount);\n        emit CrossBorrow(msg.sender, borrowToken, borrowAmount);\n    }\n\n    /// @notice convenience function to perform overcollateralized borrowing\n    /// against a cross margin account.\n    /// @dev caution: the account still has to have a positive balaance at the end\n    /// of the withdraw. So an underwater account may not be able to withdraw\n    function crossOvercollateralizedBorrow(\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    ) external {\n        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);\n\n        Lending(lending()).registerBorrow(borrowToken, withdrawAmount);\n        IMarginTrading(crossMarginTrading()).registerOvercollateralizedBorrow(\n            msg.sender,\n            depositToken,\n            depositAmount,\n            borrowToken,\n            withdrawAmount\n        );\n\n        Fund(fund()).withdraw(borrowToken, msg.sender, withdrawAmount);\n        stakeClaim(msg.sender, borrowToken, withdrawAmount);\n        emit CrossOvercollateralizedBorrow(\n            msg.sender,\n            depositToken,\n            depositAmount,\n            borrowToken,\n            withdrawAmount\n        );\n    }\n\n    /// @notice close an account that is no longer borrowing and return gains\n    function crossCloseAccount() external {\n        (address[] memory holdingTokens, uint256[] memory holdingAmounts) =\n            IMarginTrading(crossMarginTrading()).getHoldingAmounts(msg.sender);\n\n        // requires all debts paid off\n        IMarginTrading(crossMarginTrading()).registerLiquidation(msg.sender);\n\n        for (uint256 i; holdingTokens.length > i; i++) {\n            Fund(fund()).withdraw(\n                holdingTokens[i],\n                msg.sender,\n                holdingAmounts[i]\n            );\n        }\n    }\n\n    /// @notice entry point for swapping tokens held in cross margin account\n    function crossSwapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        // calc fees\n        uint256 fees = takeFeesFromInput(amountIn);\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            amountIn - fees,\n            amms,\n            tokens\n        );\n\n        // checks that trader is within allowed lending bounds\n        registerTrade(\n            msg.sender,\n            tokens[0],\n            tokens[tokens.length - 1],\n            amountIn,\n            amounts[amounts.length - 1]\n        );\n\n        _fundSwapExactT4T(amounts, amountOutMin, pairs, tokens);\n    }\n\n    /// @notice entry point for swapping tokens held in cross margin account\n    function crossSwapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        bytes32 amms,\n        address[] calldata tokens,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut + takeFeesFromOutput(amountOut),\n            amms,\n            tokens\n        );\n\n        // checks that trader is within allowed lending bounds\n        registerTrade(\n            msg.sender,\n            tokens[0],\n            tokens[tokens.length - 1],\n            amounts[0],\n            amountOut\n        );\n\n        _fundSwapT4ExactT(amounts, amountInMax, pairs, tokens);\n    }\n\n    /// @dev helper function does all the work of telling other contracts\n    /// about a cross margin trade\n    function registerTrade(\n        address trader,\n        address inToken,\n        address outToken,\n        uint256 inAmount,\n        uint256 outAmount\n    ) internal {\n        (uint256 extinguishAmount, uint256 borrowAmount) =\n            IMarginTrading(crossMarginTrading()).registerTradeAndBorrow(\n                trader,\n                inToken,\n                outToken,\n                inAmount,\n                outAmount\n            );\n        if (extinguishAmount > 0) {\n            Lending(lending()).payOff(outToken, extinguishAmount);\n            withdrawClaim(trader, outToken, extinguishAmount);\n        }\n        if (borrowAmount > 0) {\n            Lending(lending()).registerBorrow(inToken, borrowAmount);\n            stakeClaim(trader, inToken, borrowAmount);\n        }\n\n        emit CrossTrade(\n            trader,\n            inToken,\n            inAmount,\n            borrowAmount,\n            outToken,\n            outAmount,\n            extinguishAmount\n        );\n    }\n\n    /////////////\n    // Helpers\n    /////////////\n\n    /// @dev internal helper swapping exact token for token on AMM\n    function _fundSwapExactT4T(\n        uint256[] memory amounts,\n        uint256 amountOutMin,\n        address[] memory pairs,\n        address[] calldata tokens\n    ) internal {\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n        _swap(amounts, pairs, tokens, fund());\n    }\n\n    /// @notice make swaps on AMM using protocol funds, only for authorized contracts\n    function authorizedSwapExactT4T(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external returns (uint256[] memory amounts) {\n        require(\n            isAuthorizedFundTrader(msg.sender),\n            \"Calling contract is not authorized to trade with protocl funds\"\n        );\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            amountIn,\n            amms,\n            tokens\n        );\n        _fundSwapExactT4T(amounts, amountOutMin, pairs, tokens);\n    }\n\n    // @dev internal helper swapping exact token for token on on AMM\n    function _fundSwapT4ExactT(\n        uint256[] memory amounts,\n        uint256 amountInMax,\n        address[] memory pairs,\n        address[] calldata tokens\n    ) internal {\n        // TODO minimum trade?\n        require(\n            amounts[0] <= amountInMax,\n            \"MarginRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n        _swap(amounts, pairs, tokens, fund());\n    }\n\n    //// @notice swap protocol funds on AMM, only for authorized\n    function authorizedSwapT4ExactT(\n        uint256 amountOut,\n        uint256 amountInMax,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external returns (uint256[] memory amounts) {\n        require(\n            isAuthorizedFundTrader(msg.sender),\n            \"Calling contract is not authorized to trade with protocl funds\"\n        );\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut,\n            amms,\n            tokens\n        );\n        _fundSwapT4ExactT(amounts, amountInMax, pairs, tokens);\n    }\n\n    function takeFeesFromOutput(uint256 amount)\n        internal\n        pure\n        returns (uint256 fees)\n    {\n        fees = (mswapFeesPer10k * amount) / 10_000;\n    }\n\n    function takeFeesFromInput(uint256 amount)\n        internal\n        pure\n        returns (uint256 fees)\n    {\n        fees = (mswapFeesPer10k * amount) / (10_000 + mswapFeesPer10k);\n    }\n\n    function getAmountsOut(\n        uint256 inAmount,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory amounts) {\n        (amounts, ) = UniswapStyleLib.getAmountsOut(inAmount, amms, tokens);\n    }\n\n    function getAmountsIn(\n        uint256 outAmount,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory amounts) {\n        (amounts, ) = UniswapStyleLib.getAmountsIn(outAmount, amms, tokens);\n    }\n}\n"
    },
    "libraries/UniswapStyleLib.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nlibrary UniswapStyleLib {\n    \n    address constant UNISWAP_FACTORY  = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address constant SUSHI_FACTORY = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Identical address!\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Zero address!\");\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address pair,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) =\n            IUniswapV2Pair(pair).getReserves();\n\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1_000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn * amountOut * 1_000;\n\n        uint256 denominator = (reserveOut - amountOut) - 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        uint256 amountIn,\n        bytes32 amms,\n        address[] memory tokens\n    ) internal view returns (uint256[] memory amounts, address[] memory pairs) {\n        require(tokens.length >= 2, \"UniswapStyleLib: token path is too short\");\n\n        amounts = new uint256[](tokens.length);\n        amounts[0] = amountIn;\n\n        pairs = new address[](tokens.length -1);\n\n        for (uint256 i; i < tokens.length - 1; i++) {\n            address inToken = tokens[i];\n            address outToken = tokens[i+1];\n\n            address pair = amms[i] == 0 ? pairForUni(inToken, outToken) : pairForSushi(inToken, outToken);\n            pairs[i] = pair;\n\n            (uint256 reserveIn, uint256 reserveOut) =\n                getReserves(pair, inToken, outToken);\n\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        uint256 amountOut,\n        bytes32 amms,\n        address[] memory tokens\n                          ) internal view returns (uint256[] memory amounts, address[] memory pairs) {\n\n        require(tokens.length >= 2, \"UniswapStyleLib: token path is too short\");\n\n        amounts = new uint256[](tokens.length);\n        amounts[amounts.length - 1] = amountOut;\n\n        pairs = new address[](tokens.length -1);\n\n        for (uint256 i = tokens.length - 1; i > 0; i--) {\n\n            address inToken = tokens[i - 1] ;\n            address outToken = tokens[i];\n\n            address pair = amms[i - 1] == 0 ? pairForUni(inToken, outToken) : pairForSushi(inToken, outToken);\n            pairs[i - 1] = pair;\n\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(pair, inToken, outToken);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairForUni(address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                UNISWAP_FACTORY,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n                                                                  )))));\n    }\n\n    function pairForSushi(address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                SUSHI_FACTORY,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n                                                                  )))));\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "interfaces/IMarginTrading.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IMarginTrading {\n    function registerDeposit(\n        address trader,\n        address token,\n        uint256 amount\n    ) external returns (uint256 extinguishAmount);\n\n    function registerWithdrawal(\n        address trader,\n        address token,\n        uint256 amount\n    ) external;\n\n    function registerBorrow(\n        address trader,\n        address token,\n        uint256 amount\n    ) external;\n\n    function registerTradeAndBorrow(\n        address trader,\n        address inToken,\n        address outToken,\n        uint256 inAmount,\n        uint256 outAmount\n    ) external returns (uint256 extinguishAmount, uint256 borrowAmount);\n\n    function registerOvercollateralizedBorrow(\n        address trader,\n        address depositToken,\n        uint256 depositAmount,\n        address borrowToken,\n        uint256 withdrawAmount\n    ) external;\n\n    function registerLiquidation(address trader) external;\n\n    function getHoldingAmounts(address trader)\n        external\n        view\n        returns (\n            address[] memory holdingTokens,\n            uint256[] memory holdingAmounts\n        );\n\n    function getBorrowAmounts(address trader)\n        external\n        view\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts);\n}\n"
    },
    "contracts/BaseRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Fund.sol\";\nimport \"../libraries/UniswapStyleLib.sol\";\n\nabstract contract BaseRouter {\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"Trade has expired\");\n        _;\n    }\n\n    // **** SWAP ****\n    /// @dev requires the initial amount to have already been sent to the first pair\n    /// and for pairs to be vetted (which getAmountsIn / getAmountsOut do)\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory pairs,\n        address[] memory tokens,\n        address _to\n    ) internal {\n        for (uint256 i; i < pairs.length; i++) {\n            (address input, address output) = (tokens[i], tokens[i + 1]);\n            (address token0, ) = UniswapStyleLib.sortTokens(input, output);\n\n            uint256 amountOut = amounts[i + 1];\n\n            (uint256 amount0Out, uint256 amount1Out) =\n                input == token0\n                    ? (uint256(0), amountOut)\n                    : (amountOut, uint256(0));\n\n            address to = i < pairs.length - 1 ? pairs[i + 1] : _to;\n            IUniswapV2Pair pair = IUniswapV2Pair(pairs[i]);\n\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/TokenAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./IncentiveDistribution.sol\";\nimport \"./Fund.sol\";\nimport \"./CrossMarginTrading.sol\";\nimport \"./MarginRouter.sol\";\n\n/// @title A helper contract to manage the initialization of new tokens\n/// across different parts of the protocol, as well as changing some\n/// parameters throughout the lifetime of a token\ncontract TokenAdmin is RoleAware {\n    uint256 public totalLendingTargetPortion;\n    uint256 public totalBorrowingTargetPortion;\n    address[] public incentiveTokens;\n    mapping(address => uint256) public tokenWeights;\n    uint256 public totalTokenWeights;\n    mapping(address => uint8) public tokenLendingTranches;\n    mapping(address => uint8) public tokenBorrowingTranches;\n    uint8 public nextTrancheIndex = 20;\n\n    uint256 public initHourlyYieldAPRPercent = 10;\n\n    // TODO give this contract ownership of incentive distribution\n    // during deploy after everything else is incentivized\n    constructor(\n        uint256 lendingTargetPortion,\n        uint256 borrowingTargetPortion,\n        address _roles\n    ) RoleAware(_roles) {\n        totalLendingTargetPortion = lendingTargetPortion;\n        totalBorrowingTargetPortion = borrowingTargetPortion;\n    }\n\n    /// Activate a token for trading\n    function activateToken(\n        address token,\n        uint256 exposureCap,\n        uint256 lendingBuffer,\n        uint256 incentiveWeight,\n        bytes32 amms,\n        address[] calldata liquidationTokens\n    ) external onlyOwnerExec {\n        require(\n            !Lending(lending()).activeIssuers(token),\n            \"Token already is active\"\n        );\n\n        Lending(lending()).activateIssuer(token);\n        CrossMarginTrading(crossMarginTrading()).setTokenCap(\n            token,\n            exposureCap\n        );\n        Lending(lending()).setLendingCap(token, exposureCap);\n        Lending(lending()).setLendingBuffer(token, lendingBuffer);\n        Lending(lending()).setHourlyYieldAPR(token, initHourlyYieldAPRPercent);\n        Lending(lending()).initBorrowYieldAccumulator(token);\n\n        if (incentiveWeight > 0) {\n            totalTokenWeights += incentiveWeight;\n            tokenWeights[token] = incentiveWeight;\n            IncentiveDistribution iD =\n                IncentiveDistribution(incentiveDistributor());\n\n            // init lending\n            uint256 lendingShare =\n                calcTrancheShare(incentiveWeight, totalLendingTargetPortion);\n            iD.initTranche(nextTrancheIndex, lendingShare);\n            tokenLendingTranches[token] = nextTrancheIndex;\n            Lending(lending()).setIncentiveTranche(token, nextTrancheIndex);\n            nextTrancheIndex++;\n\n            // init borrowing\n            uint256 borrowingShare =\n                calcTrancheShare(incentiveWeight, totalBorrowingTargetPortion);\n            iD.initTranche(nextTrancheIndex, borrowingShare);\n            tokenBorrowingTranches[token] = nextTrancheIndex;\n            MarginRouter(marginRouter()).setIncentiveTranche(\n                token,\n                nextTrancheIndex\n            );\n            nextTrancheIndex++;\n\n            updateIncentiveShares(iD);\n            incentiveTokens.push(token);\n\n            require(\n                liquidationTokens[0] == token &&\n                    liquidationTokens[liquidationTokens.length - 1] ==\n                    CrossMarginTrading(crossMarginTrading()).peg(),\n                \"Invalid liquidationTokens -- should go from token to peg\"\n            );\n            CrossMarginTrading(crossMarginTrading()).setLiquidationPath(\n                amms,\n                liquidationTokens\n            );\n        }\n    }\n\n    /// Update token cap\n    function changeTokenCap(address token, uint256 exposureCap)\n        external\n        onlyOwnerExec\n    {\n        Lending(lending()).setLendingCap(token, exposureCap);\n        CrossMarginTrading(crossMarginTrading()).setTokenCap(\n            token,\n            exposureCap\n        );\n    }\n\n    /// Change weight of token incentive\n    function changeTokenIncentiveWeight(address token, uint256 tokenWeight)\n        external\n        onlyOwnerExec\n    {\n        totalTokenWeights =\n            totalTokenWeights +\n            tokenWeight -\n            tokenWeights[token];\n        tokenWeights[token] = tokenWeight;\n\n        updateIncentiveShares(IncentiveDistribution(incentiveDistributor()));\n    }\n\n    /// Update lending buffer\n    function changeLendingBuffer(address token, uint256 lendingBuffer)\n        external\n        onlyOwnerExec\n    {\n        Lending(lending()).setLendingBuffer(token, lendingBuffer);\n    }\n\n    //function changeBondLendingWeights(address token, uint256[] memory weights) external onlyOwnerExec {\n    //    Lending(lending()).setRuntimeWeights(token, weights);\n    //}\n\n    function updateIncentiveShares(IncentiveDistribution iD) internal {\n        for (uint8 i = 0; incentiveTokens.length > i; i++) {\n            address incentiveToken = incentiveTokens[i];\n            uint256 tokenWeight = tokenWeights[incentiveToken];\n            uint256 lendingShare =\n                calcTrancheShare(tokenWeight, totalLendingTargetPortion);\n            iD.setTrancheShare(\n                tokenLendingTranches[incentiveToken],\n                lendingShare\n            );\n\n            uint256 borrowingShare =\n                calcTrancheShare(tokenWeight, totalBorrowingTargetPortion);\n            iD.setTrancheShare(\n                tokenBorrowingTranches[incentiveToken],\n                borrowingShare\n            );\n        }\n    }\n\n    function calcTrancheShare(uint256 incentiveWeight, uint256 targetPortion)\n        internal\n        view\n        returns (uint256)\n    {\n        return (incentiveWeight * targetPortion) / totalTokenWeights;\n    }\n\n    /// Set lending target portion\n    function setLendingTargetPortion(uint256 portion) external onlyOwnerExec {\n        totalLendingTargetPortion = portion;\n    }\n\n    /// Set borrowing target portion\n    function setBorrowingTargetPortion(uint256 portion) external onlyOwnerExec {\n        totalBorrowingTargetPortion = portion;\n    }\n\n    function changeHourlyYieldAPR(address token, uint256 aprPercent)\n        external\n        onlyOwnerExec\n    {\n        Lending(lending()).setHourlyYieldAPR(token, aprPercent);\n    }\n\n    /// Set initial hourly yield APR\n    function setInitHourlyYieldAPR(uint256 value) external onlyOwnerExec {\n        initHourlyYieldAPRPercent = value;\n    }\n}\n"
    },
    "contracts/Relender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./RoleAware.sol\";\nimport \"./Lending.sol\";\nimport \"./CrossMarginTrading.sol\";\n\n/// @title anyone can call this contract to update relending levels\ncontract Relender is RoleAware {\n    uint256 public relendPercent = 10;\n\n    constructor(address _roles) RoleAware(_roles) {}\n\n    function setRelendPercent(uint256 newRelendPercent) external onlyOwnerExec {\n        relendPercent = newRelendPercent;\n    }\n\n    /// @dev relend from cross margin holdings\n    function crossRelend(address token) external {\n        uint256 relendBalance =\n            Lending(lending()).viewHourlyBondAmount(token, address(this));\n        uint256 relendTarget =\n            CrossMarginTrading(crossMarginTrading()).totalLong(token);\n        if (relendBalance > relendTarget) {\n            Lending(lending()).withdrawHourlyBond(\n                token,\n                relendBalance - relendTarget\n            );\n        } else {\n            Lending(lending()).buyHourlyBondSubscription(\n                token,\n                relendTarget - relendBalance\n            );\n        }\n    }\n}\n"
    },
    "contracts/IsolatedMarginAccounts.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./RoleAware.sol\";\nimport \"./Lending.sol\";\nimport \"./PriceAware.sol\";\n\nabstract contract IsolatedMarginAccounts is RoleAware {\n    struct IsolatedMarginAccount {\n        uint256 lastDepositBlock;\n        uint256 borrowed;\n        uint256 borrowedYieldQuotientFP;\n        uint256 holding;\n    }\n\n    address public borrowToken;\n    address public holdingToken;\n\n    uint256 public totalDebt;\n\n    bytes32 public amms;\n    address[] public liquidationTokens;\n\n    /// update window in blocks\n    uint16 public priceUpdateWindow = 8;\n    uint256 public UPDATE_RATE_PERMIL = 80;\n\n    /// @dev percentage of assets held per assets borrowed at which to liquidate\n    uint256 public liquidationThresholdPercent;\n\n    mapping(address => IsolatedMarginAccount) public marginAccounts;\n    uint256 public coolingOffPeriod = 20;\n    uint256 public leveragePercent = 500;\n\n    /// @dev adjust account to reflect borrowing of token amount\n    function borrow(IsolatedMarginAccount storage account, uint256 amount)\n        internal\n    {\n        updateLoan(account);\n        account.borrowed += amount;\n        require(positiveBalance(account), \"Can't borrow: insufficient balance\");\n    }\n\n    function updateLoan(IsolatedMarginAccount storage account) internal {\n        (account.borrowed, account.borrowedYieldQuotientFP) = Lending(lending())\n            .applyBorrowInterest(\n            account.borrowed,\n            address(this),\n            account.borrowedYieldQuotientFP\n        );\n    }\n\n    /// @dev checks whether account is in the black, deposit + earnings relative to borrowed\n    function positiveBalance(IsolatedMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account);\n        uint256 holdings = holdingInPeg(account);\n\n        // The following condition should hold:\n        // holdings / loan >= leveragePercent / (leveragePercent - 100)\n        // =>\n        return holdings * (leveragePercent - 100) >= loan * leveragePercent;\n    }\n\n    /// @dev internal function adjusting holding and borrow balances when debt extinguished\n    function extinguishDebt(\n        IsolatedMarginAccount storage account,\n        uint256 extinguishAmount\n    ) internal {\n        // TODO check if underflow?\n        // TODO TELL LENDING\n        updateLoan(account);\n        account.borrowed -= extinguishAmount;\n    }\n\n    /// @dev check whether an account can/should be liquidated\n    function belowMaintenanceThreshold(IsolatedMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account);\n        uint256 holdings = holdingInPeg(account);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }\n\n    /// @dev calculate loan in reference currency\n    function loanInPeg(\n        IsolatedMarginAccount storage account\n    ) internal returns (uint256) {\n        return\n            PriceAware(price()).getCurrentPriceInPeg(\n                borrowToken,\n                account.borrowed\n            );\n    }\n\n    /// @dev calculate loan in reference currency\n    function holdingInPeg(\n        IsolatedMarginAccount storage account\n    ) internal returns (uint256) {\n        return\n            PriceAware(price()).getCurrentPriceInPeg(\n                holdingToken,\n                account.holding\n            );\n    }\n\n    /// @dev minimum\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return b;\n        } else {\n            return a;\n        }\n    }\n}\n"
    },
    "contracts/IsolatedMarginLiquidation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./IsolatedMarginAccounts.sol\";\n\n/** \n@title Handles liquidation of accounts below maintenance threshold\n@notice Liquidation can be called by the authorized staker, \nas determined in the Admin contract.\nIf the authorized staker is delinquent, other participants can jump\nin and attack, taking their fees and potentially even their stake,\ndepending how delinquent the responsible authorized staker is.\n*/\nabstract contract IsolatedMarginLiquidation is IsolatedMarginAccounts {\n    event LiquidationShortfall(uint256 amount);\n    event AccountLiquidated(address account);\n\n    /// record kept around until a stake attacker can claim their reward\n    struct AccountLiqRecord {\n        uint256 blockNum;\n        address loser;\n        uint256 amount;\n        address stakeAttacker;\n    }\n\n    address[] internal tradersToLiquidate;\n\n    mapping(address => uint256) public maintenanceFailures;\n    mapping(address => AccountLiqRecord) public stakeAttackRecords;\n    uint256 public avgLiquidationPerCall = 10;\n\n    uint256 public liqStakeAttackWindow = 5;\n    uint256 public MAINTAINER_CUT_PERCENT = 5;\n\n    uint256 public failureThreshold = 10;\n\n    /// Set failure threshold\n    function setFailureThreshold(uint256 threshFactor) external onlyOwnerExec {\n        failureThreshold = threshFactor;\n    }\n\n    /// Set liquidity stake attack window\n    function setLiqStakeAttackWindow(uint256 window) external onlyOwnerExec {\n        liqStakeAttackWindow = window;\n    }\n\n    /// Set maintainer's percent cut\n    function setMaintainerCutPercent(uint256 cut) external onlyOwnerExec {\n        MAINTAINER_CUT_PERCENT = cut;\n    }\n\n    /// @dev calcLiquidationAmounts does a number of tasks in this contract\n    /// and some of them are not straightforward.\n    /// First of all it aggregates the total amount to sell\n    /// as well as which traders are ripe for liquidation, in storage (not in memory)\n    /// owing to the fact that arrays can't be pushed to and hash maps don't\n    /// exist in memory.\n    /// Then it also returns any stake attack funds if the stake was unsuccessful\n    /// (i.e. current caller is authorized). Also see context below.\n    function calcLiquidationAmounts(\n        address[] memory liquidationCandidates,\n        bool isAuthorized\n    )\n        internal\n        returns (\n            uint256 attackReturns,\n            uint256 sellAmount,\n            uint256 buyTarget\n        )\n    {\n        tradersToLiquidate = new address[](0);\n\n        for (\n            uint256 traderIndex = 0;\n            liquidationCandidates.length > traderIndex;\n            traderIndex++\n        ) {\n            address traderAddress = liquidationCandidates[traderIndex];\n            IsolatedMarginAccount storage account =\n                marginAccounts[traderAddress];\n\n            if (belowMaintenanceThreshold(account)) {\n                tradersToLiquidate.push(traderAddress);\n\n                sellAmount += account.holding;\n\n                updateLoan(account);\n                buyTarget += account.borrowed;\n\n                // TODO pay off / extinguish that loan\n            }\n\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[traderAddress];\n            if (isAuthorized) {\n                attackReturns += _disburseLiqAttack(liqAttackRecord);\n            }\n        }\n    }\n\n    function _disburseLiqAttack(AccountLiqRecord storage liqAttackRecord)\n        internal\n        returns (uint256 returnAmount)\n    {\n        if (liqAttackRecord.amount > 0) {\n            // validate attack records, if any\n            uint256 blockDiff =\n                min(\n                    block.number - liqAttackRecord.blockNum,\n                    liqStakeAttackWindow\n                );\n\n            uint256 attackerCut =\n                (liqAttackRecord.amount * blockDiff) / liqStakeAttackWindow;\n\n            Fund(fund()).withdraw(\n                borrowToken,\n                liqAttackRecord.stakeAttacker,\n                attackerCut\n            );\n\n            Admin a = Admin(admin());\n            uint256 penalty =\n                (a.maintenanceStakePerBlock() * attackerCut) /\n                    avgLiquidationPerCall;\n            a.penalizeMaintenanceStake(\n                liqAttackRecord.loser,\n                penalty,\n                liqAttackRecord.stakeAttacker\n            );\n\n            // return remainder, after cut was taken to authorized stakekr\n            returnAmount = liqAttackRecord.amount - attackerCut;\n        }\n    }\n\n    /// Disburse liquidity stake attacks\n    function disburseLiqStakeAttacks(address[] memory liquidatedAccounts)\n        external\n    {\n        for (uint256 i = 0; liquidatedAccounts.length > i; i++) {\n            address liqAccount = liquidatedAccounts[i];\n            AccountLiqRecord storage liqAttackRecord =\n                stakeAttackRecords[liqAccount];\n            if (\n                block.number > liqAttackRecord.blockNum + liqStakeAttackWindow\n            ) {\n                _disburseLiqAttack(liqAttackRecord);\n                delete stakeAttackRecords[liqAccount];\n            }\n        }\n    }\n\n    function maintainerIsFailing() internal view returns (bool) {\n        (address currentMaintainer, ) =\n            Admin(admin()).viewCurrentMaintenanceStaker();\n        return\n            maintenanceFailures[currentMaintainer] >\n            failureThreshold * avgLiquidationPerCall;\n    }\n\n    function liquidateToBorrow(uint256 sellAmount) internal returns (uint256) {\n        uint256[] memory amounts =\n            MarginRouter(marginRouter()).authorizedSwapExactT4T(\n                sellAmount,\n                0,\n                amms,\n                liquidationTokens\n            );\n\n        uint256 outAmount = amounts[amounts.length - 1];\n\n        return outAmount;\n    }\n\n    /// called by maintenance stakers to liquidate accounts below liquidation threshold\n    function liquidate(address[] memory liquidationCandidates)\n        external\n        noIntermediary\n        returns (uint256 maintainerCut)\n    {\n        bool isAuthorized = Admin(admin()).isAuthorizedStaker(msg.sender);\n        bool canTakeNow = isAuthorized || maintainerIsFailing();\n\n        // calcLiquidationAmounts does a lot of the work here\n        // * aggregates both sell and buy side targets to be liquidated\n        // * returns attacker cuts to them\n        // * aggregates any returned fees from unauthorized (attacking) attempts\n        uint256 sellAmount;\n        uint256 liquidationTarget;\n        (maintainerCut, sellAmount, liquidationTarget) = calcLiquidationAmounts(\n            liquidationCandidates,\n            isAuthorized\n        );\n\n        uint256 liquidationReturns = liquidateToBorrow(sellAmount);\n\n        // this may be a bit imprecise, since individual shortfalls may be obscured\n        // by overall returns and the maintainer cut is taken out of the net total,\n        // but it gives us the general picture\n        liquidationTarget *= (100 + MAINTAINER_CUT_PERCENT) / 100;\n        if (liquidationTarget > liquidationReturns) {\n            emit LiquidationShortfall(liquidationTarget - liquidationReturns);\n\n            Lending(lending()).haircut(liquidationTarget - liquidationReturns);\n        }\n\n        address loser = address(0);\n        if (!canTakeNow) {\n            // whoever is the current responsible maintenance staker\n            // and liable to lose their stake\n            loser = Admin(admin()).getUpdatedCurrentStaker();\n        }\n\n        // iterate over traders and send back their money\n        // as well as giving attackers their due, in case caller isn't authorized\n        for (\n            uint256 traderIdx = 0;\n            tradersToLiquidate.length > traderIdx;\n            traderIdx++\n        ) {\n            address traderAddress = tradersToLiquidate[traderIdx];\n            IsolatedMarginAccount storage account =\n                marginAccounts[traderAddress];\n\n            // 5% of value borrowed\n            uint256 maintainerCut4Account =\n                (account.borrowed * MAINTAINER_CUT_PERCENT) / 100;\n            maintainerCut += maintainerCut4Account;\n\n            if (!canTakeNow) {\n                // This could theoretically lead to a previous attackers\n                // record being overwritten, but only if the trader restarts\n                // their account and goes back into the red within the short time window\n                // which would be a costly attack requiring collusion without upside\n                AccountLiqRecord storage liqAttackRecord =\n                    stakeAttackRecords[traderAddress];\n                liqAttackRecord.amount = maintainerCut4Account;\n                liqAttackRecord.stakeAttacker = msg.sender;\n                liqAttackRecord.blockNum = block.number;\n                liqAttackRecord.loser = loser;\n            }\n\n            uint256 holdingsValue =\n                (account.holding * liquidationReturns) / sellAmount;\n\n            // send back trader money\n            if (holdingsValue >= maintainerCut4Account + account.borrowed) {\n                // send remaining funds back to trader\n                Fund(fund()).withdraw(\n                    borrowToken,\n                    traderAddress,\n                    holdingsValue - account.borrowed - maintainerCut4Account\n                );\n            }\n\n            emit AccountLiquidated(traderAddress);\n            delete marginAccounts[traderAddress];\n        }\n\n        avgLiquidationPerCall =\n            (avgLiquidationPerCall * 99 + maintainerCut) /\n            100;\n\n        if (canTakeNow) {\n            Fund(fund()).withdraw(borrowToken, msg.sender, maintainerCut);\n        }\n\n        address currentMaintainer = Admin(admin()).getUpdatedCurrentStaker();\n        if (isAuthorized) {\n            if (maintenanceFailures[currentMaintainer] > maintainerCut) {\n                maintenanceFailures[currentMaintainer] -= maintainerCut;\n            } else {\n                maintenanceFailures[currentMaintainer] = 0;\n            }\n        } else {\n            maintenanceFailures[currentMaintainer] += maintainerCut;\n        }\n    }\n}\n"
    },
    "contracts/IsolatedMarginTrading.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./IsolatedMarginLiquidation.sol\";\n\ncontract IsolatedMarginTrading is IsolatedMarginLiquidation {\n    constructor(address _roles) RoleAware(_roles) {}\n\n    /// @dev last time this account deposited\n    /// relevant for withdrawal window\n    function getLastDepositBlock(address trader)\n        external\n        view\n        returns (uint256)\n    {\n        return marginAccounts[trader].lastDepositBlock;\n    }\n\n    /// @dev setter for cooling off period for withdrawing funds after deposit\n    function setCoolingOffPeriod(uint256 blocks) external onlyOwnerExec {\n        coolingOffPeriod = blocks;\n    }\n\n    /// @dev admin function to set leverage\n    function setLeveragePercent(uint256 _leveragePercent)\n        external\n        onlyOwnerExec\n    {\n        leveragePercent = _leveragePercent;\n    }\n\n    /// @dev admin function to set liquidation threshold\n    function setLiquidationThresholdPercent(uint256 threshold)\n        external\n        onlyOwnerExec\n    {\n        liquidationThresholdPercent = threshold;\n    }\n\n    /// @dev gets called by router to affirm trader taking position\n    function registerPosition(\n        address trader,\n        uint256 borrowed,\n        uint256 holdingsAdded\n    ) external {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n\n        IsolatedMarginAccount storage account = marginAccounts[trader];\n\n        account.holding += holdingsAdded;\n        borrow(account, borrowed);\n    }\n\n    /// @dev gets called by router to affirm unwinding of position\n    function registerUnwind(\n        address trader,\n        uint256 extinguished,\n        uint256 holdingsSold\n    ) external {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n\n        IsolatedMarginAccount storage account = marginAccounts[trader];\n\n        account.holding -= holdingsSold;\n        extinguishDebt(account, extinguished);\n    }\n\n    /// @dev gets called by router to close account\n    function registerCloseAccount(address trader)\n        external\n        returns (uint256 holdingAmount)\n    {\n        require(\n            isMarginTrader(msg.sender),\n            \"Calling contract not authorized to deposit\"\n        );\n\n        IsolatedMarginAccount storage account = marginAccounts[trader];\n\n        require(account.borrowed == 0, \"Can't close account that's borrowing\");\n\n        holdingAmount = account.holding;\n\n        delete marginAccounts[trader];\n    }\n}\n"
    },
    "contracts/SpotRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../libraries/UniswapStyleLib.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./BaseRouter.sol\";\n\n/// @title Router for spot trading on uniswap and sushiswap jointly\n/// the paramater amms represents the choice of amm pair along the route\n/// it is a bytes32 value where amms[i] == 0 for uniswap and amms[i] == 1 for sushi\ncontract SpotRouter is BaseRouter {\n    using SafeERC20 for IERC20;\n    address public immutable WETH;\n\n    constructor(address _WETH) {\n        WETH = _WETH;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            amountIn,\n            amms,\n            tokens\n        );\n\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"SpotRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        IERC20(tokens[0]).safeTransferFrom(msg.sender, pairs[0], amounts[0]);\n        _swap(amounts, pairs, tokens, to);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        bytes32 amms,\n        address[] calldata tokens,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut,\n            amms,\n            tokens\n        );\n\n        require(\n            amounts[0] <= amountInMax,\n            \"SpotRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        IERC20(tokens[0]).safeTransferFrom(msg.sender, pairs[0], amounts[0]);\n        _swap(amounts, pairs, tokens, to);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens,\n        address to,\n        uint256 deadline\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n        require(tokens[0] == WETH, \"SpotRouter: INVALID_PATH\");\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            msg.value,\n            amms,\n            tokens\n        );\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"SpotRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(pairs[0], msg.value));\n\n        _swap(amounts, pairs, tokens, to);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        bytes32 amms,\n        address[] calldata tokens,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        require(tokens[tokens.length - 1] == WETH, \"SpotRouter: INVALID_PATH\");\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut,\n            amms,\n            tokens\n        );\n\n        require(\n            amounts[0] <= amountInMax,\n            \"SpotRouter: EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        IERC20(tokens[0]).safeTransferFrom(msg.sender, pairs[0], amounts[0]);\n\n        _swap(amounts, pairs, tokens, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        Address.sendValue(payable(to), amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes32 amms,\n        address[] calldata tokens,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        require(tokens[tokens.length - 1] == WETH, \"SpotRouter: INVALID_PATH\");\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsOut(\n            amountIn,\n            amms,\n            tokens\n        );\n\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"SpotRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        _swap(amounts, pairs, tokens, address(this));\n\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        Address.sendValue(payable(to), amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        bytes32 amms,\n        address[] calldata tokens,\n        address to,\n        uint256 deadline\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n        require(tokens[0] == WETH, \"SpotRouter: INVALID_PATH\");\n\n        address[] memory pairs;\n        (amounts, pairs) = UniswapStyleLib.getAmountsIn(\n            amountOut,\n            amms,\n            tokens\n        );\n\n        require(amounts[0] <= msg.value, \"SpotRouter: EXCESSIVE_INPUT_AMOUNT\");\n\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(pairs[0], amounts[0]));\n\n        _swap(amounts, pairs, tokens, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0])\n            Address.sendValue(payable(msg.sender), msg.value - amounts[0]);\n    }\n\n    function getAmountsOut(\n        uint256 inAmount,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory amounts) {\n        (amounts, ) = UniswapStyleLib.getAmountsOut(inAmount, amms, tokens);\n    }\n\n    function getAmountsIn(\n        uint256 outAmount,\n        bytes32 amms,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory amounts) {\n        (amounts, ) = UniswapStyleLib.getAmountsIn(outAmount, amms, tokens);\n    }\n}\n"
    },
    "contracts/DependencyController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\nimport \"./Executor.sol\";\nimport \"../interfaces/IDependencyController.sol\";\n\n/// @title Provides a single point of reference to verify integrity\n/// of the roles structure and facilitate governance actions\n/// within our system as well as performing cache invalidation for\n/// roles and inter-contract relationships\ncontract DependencyController is RoleAware, IDependencyController {\n    constructor(address _roles) RoleAware(_roles) {}\n\n    address public override currentExecutor;\n\n    address[] public managedContracts;\n    mapping(uint256 => bool) public knownCharacters;\n    mapping(uint256 => bool) public knownRoles;\n\n    uint256[] public allCharacters;\n    uint256[] public allRoles;\n\n    function executeAsOwner(address executor) external onlyOwnerExec {\n        uint256[] memory requiredRoles = Executor(executor).requiredRoles();\n\n        for (uint256 i = 0; requiredRoles.length > i; i++) {\n            _giveRole(requiredRoles[i], executor);\n        }\n\n        updateCaches(executor);\n        currentExecutor = executor;\n        Executor(executor).execute();\n        currentExecutor = address(0);\n\n        uint256 len = requiredRoles.length;\n        for (uint256 i = 0; len > i; i++) {\n            _removeRole(requiredRoles[i], executor);\n        }\n    }\n\n    /// Orchestrate roles and permission for contract\n    function manageContract(\n        address contr,\n        uint256[] memory charactersPlayed,\n        uint256[] memory rolesPlayed\n    ) external onlyOwnerExec {\n        managedContracts.push(contr);\n\n        // set up all characters this contract plays\n        uint256 len = charactersPlayed.length;\n        for (uint256 i = 0; len > i; i++) {\n            uint256 character = charactersPlayed[i];\n            _setMainCharacter(character, contr);\n        }\n\n        // all roles this contract plays\n        len = rolesPlayed.length;\n        for (uint256 i = 0; len > i; i++) {\n            uint256 role = rolesPlayed[i];\n            _giveRole(role, contr);\n        }\n\n        updateCaches(contr);\n    }\n\n    ///  Remove roles and permissions for contract\n    function disableContract(address contr) external onlyOwnerExecDisabler {\n        _disableContract(contr);\n    }\n\n    function _disableContract(address contr) internal {\n        uint256 len = allRoles.length;\n        for (uint256 i = 0; len > i; i++) {\n            if (roles.getRole(allRoles[i], contr)) {\n                _removeRole(allRoles[i], contr);\n            }\n        }\n\n        len = allCharacters.length;\n        for (uint256 i = 0; len > i; i++) {\n            if (roles.mainCharacters(allCharacters[i]) == contr) {\n                _setMainCharacter(allCharacters[i], address(0));\n            }\n        }\n    }\n\n    /// Activate role\n    function giveRole(uint256 role, address actor) external onlyOwnerExec {\n        _giveRole(role, actor);\n    }\n\n    /// Disable role\n    function removeRole(uint256 role, address actor)\n        external\n        onlyOwnerExecDisabler\n    {\n        _removeRole(role, actor);\n    }\n\n    function _removeRole(uint256 role, address actor) internal {\n        roles.removeRole(role, actor);\n        updateRoleCache(role, actor);\n    }\n\n    function setMainCharacter(uint256 role, address actor)\n        external\n        onlyOwnerExec\n    {\n        _setMainCharacter(role, actor);\n    }\n\n    function _giveRole(uint256 role, address actor) internal {\n        if (!knownRoles[role]) {\n            knownRoles[role] = true;\n            allRoles.push(role);\n        }\n        roles.giveRole(role, actor);\n        updateRoleCache(role, actor);\n    }\n\n    function _setMainCharacter(uint256 character, address actor) internal {\n        if (!knownCharacters[character]) {\n            knownCharacters[character] = true;\n            allCharacters.push(character);\n        }\n        roles.setMainCharacter(character, actor);\n        updateMainCharacterCache(character);\n    }\n\n    function updateMainCharacterCache(uint256 character) public override {\n        uint256 len = managedContracts.length;\n        for (uint256 i = 0; len > i; i++) {\n            RoleAware(managedContracts[i]).updateMainCharacterCache(character);\n        }\n    }\n\n    function updateRoleCache(uint256 role, address contr) public override {\n        uint256 len = managedContracts.length;\n        for (uint256 i = 0; len > i; i++) {\n            RoleAware(managedContracts[i]).updateRoleCache(role, contr);\n        }\n    }\n\n    function updateCaches(address contr) public {\n        // update this contract with all characters we know about\n        uint256 len = allCharacters.length;\n        for (uint256 i = 0; len > i; i++) {\n            RoleAware(contr).updateMainCharacterCache(allCharacters[i]);\n        }\n\n        // update this contract with all roles for all contracts we know about\n        len = allRoles.length;\n        for (uint256 i = 0; len > i; i++) {\n            for (uint256 j = 0; managedContracts.length > j; j++) {\n                RoleAware(contr).updateRoleCache(\n                    allRoles[i],\n                    managedContracts[j]\n                );\n            }\n        }\n    }\n\n    function allManagedContracts() external view returns (address[] memory) {\n        return managedContracts;\n    }\n}\n"
    },
    "contracts/Executor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./RoleAware.sol\";\n\nabstract contract Executor is RoleAware {\n    function requiredRoles() external virtual returns (uint256[] memory);\n\n    function execute() external virtual;\n}\n"
    },
    "contracts/controller-actions/TokenActivation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../Executor.sol\";\nimport \"../TokenAdmin.sol\";\n\ncontract TokenActivation is Executor {\n    address[] public tokens;\n    uint256[] public exposureCaps;\n    uint256[] public lendingBuffers;\n    uint256[] public incentiveWeights;\n    bytes32[] public amms;\n    address[][] public liquidationTokens;\n\n    constructor(\n        address _roles,\n        address[] memory tokens2activate,\n        uint256[] memory _exposureCaps,\n        uint256[] memory _lendingBuffers,\n        uint256[] memory _incentiveWeights,\n        bytes32[] memory _amms,\n        address[][] memory _liquidationTokens\n    ) RoleAware(_roles) {\n        tokens = tokens2activate;\n        exposureCaps = _exposureCaps;\n        lendingBuffers = _lendingBuffers;\n        incentiveWeights = _incentiveWeights;\n        amms = _amms;\n        liquidationTokens = _liquidationTokens;\n    }\n\n    function requiredRoles()\n        external\n        override\n        returns (uint256[] memory required)\n    {}\n\n    function execute() external override {\n        for (uint24 i = 0; tokens.length > i; i++) {\n            address token = tokens[i];\n            uint256 exposureCap = exposureCaps[i];\n            uint256 lendingBuffer = lendingBuffers[i];\n            uint256 incentiveWeight = incentiveWeights[i];\n            bytes32 ammPath = amms[i];\n            address[] memory liquidationTokenPath = liquidationTokens[i];\n\n            TokenAdmin(tokenAdmin()).activateToken(\n                token,\n                exposureCap,\n                lendingBuffer,\n                incentiveWeight,\n                ammPath,\n                liquidationTokenPath\n            );\n        }\n\n        selfdestruct(payable(tx.origin));\n    }\n}\n"
    },
    "contracts/LiquidityMiningReward.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IncentiveDistribution.sol\";\n\n/// @title Manaage rewards for liquidity mining\ncontract LiquidityMiningReward is RoleAware {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable stakeToken;\n    mapping(address => uint256) public stakeAmounts;\n\n    uint256 public immutable incentiveStart;\n\n    constructor(\n        address _roles,\n        address _stakeToken,\n        uint256 startTimestamp\n    ) RoleAware(_roles) {\n        stakeToken = IERC20(_stakeToken);\n        incentiveStart = startTimestamp;\n    }\n\n    /// Deposit stake tokens\n    function depositStake(uint256 amount) external {\n        require(\n            block.timestamp > incentiveStart,\n            \"Incentive hasn't started yet\"\n        );\n\n        stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        IncentiveDistribution(incentiveDistributor()).addToClaimAmount(\n            0,\n            msg.sender,\n            amount\n        );\n\n        stakeAmounts[msg.sender] += amount;\n    }\n\n    /// Withdraw stake tokens\n    function withdrawStake(uint256 amount) external {\n        uint256 stakeAmount = stakeAmounts[msg.sender];\n        require(stakeAmount >= amount, \"Not enough stake to withdraw\");\n\n        stakeAmounts[msg.sender] = stakeAmount - amount;\n\n        IncentiveDistribution(incentiveDistributor()).subtractFromClaimAmount(\n            0,\n            msg.sender,\n            amount\n        );\n\n        stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\n// USDC - MFI pair token\n// 0x9d640080af7c81911d87632a7d09cc4ab6b133ac\n\n// on ropsten:\n// 0xc4c79A0e1C7A9c79f1e943E3a5bEc65396a5434a\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}