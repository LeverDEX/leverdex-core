{
  "address": "0x47a58Bd6D2567ABb3b7d25637a9BE82a1674b37A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_WETH",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_roles",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrowToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "borrowAmount",
          "type": "uint256"
        }
      ],
      "name": "CrossBorrow",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        }
      ],
      "name": "CrossDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrowToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawAmount",
          "type": "uint256"
        }
      ],
      "name": "CrossOvercollateralizedBorrow",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "inToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inTokenAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inTokenBorrow",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "outToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outTokenAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outTokenExtinguish",
          "type": "uint256"
        }
      ],
      "name": "CrossTrade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "withdrawToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawAmount",
          "type": "uint256"
        }
      ],
      "name": "CrossWithdraw",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "WETH",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "pairs",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "authorizedSwapExactT4T",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountInMax",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "pairs",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "authorizedSwapT4ExactT",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "borrowToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "borrowAmount",
          "type": "uint256"
        }
      ],
      "name": "crossBorrow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "crossCloseAccount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        }
      ],
      "name": "crossDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "crossDepositETH",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "borrowToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "withdrawAmount",
          "type": "uint256"
        }
      ],
      "name": "crossOvercollateralizedBorrow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "pairs",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "crossSwapExactTokensForTokens",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountInMax",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "pairs",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "crossSwapTokensForExactTokens",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "withdrawToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "withdrawAmount",
          "type": "uint256"
        }
      ],
      "name": "crossWithdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "withdrawAmount",
          "type": "uint256"
        }
      ],
      "name": "crossWithdrawETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "outAmount",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "pairs",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "getAmountsIn",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "inAmount",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "pairs",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "getAmountsOut",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "incentiveTranches",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "mainCharacterCache",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mswapFeesPer10k",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "roleCache",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "roles",
      "outputs": [
        {
          "internalType": "contract Roles",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "tranche",
          "type": "uint8"
        }
      ],
      "name": "setIncentiveTranche",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "role",
          "type": "uint256"
        }
      ],
      "name": "updateMainCharacterCache",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "role",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "contr",
          "type": "address"
        }
      ],
      "name": "updateRoleCache",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x9906ddcda6653570347e5d8e98f8ce16b3e315097f00cbc31eedad741d8d5f11",
  "receipt": {
    "to": null,
    "from": "0x23292e9BA8434e59E6BAC1907bA7425211c4DE27",
    "contractAddress": "0x47a58Bd6D2567ABb3b7d25637a9BE82a1674b37A",
    "transactionIndex": 3,
    "gasUsed": "3391125",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6e88df0735d53498fe93fae2d7b508da0bd10c929dbb44ef80f696b89bd475b5",
    "transactionHash": "0x9906ddcda6653570347e5d8e98f8ce16b3e315097f00cbc31eedad741d8d5f11",
    "logs": [],
    "blockNumber": 24139010,
    "cumulativeGasUsed": "3696922",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    "0x67DceCCe970011547817a5A4dad9A86eF9a2AB63"
  ],
  "solcInputHash": "844ad074ee2713a040ed8b727b202f61",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_roles\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"CrossBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"CrossDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"CrossOvercollateralizedBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inTokenBorrow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outTokenExtinguish\",\"type\":\"uint256\"}],\"name\":\"CrossTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"CrossWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"authorizedSwapExactT4T\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"authorizedSwapT4ExactT\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"crossBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crossCloseAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"crossDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crossDepositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"crossOvercollateralizedBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"crossSwapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"crossSwapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"crossWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"crossWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"incentiveTranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mainCharacterCache\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mswapFeesPer10k\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roleCache\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"contract Roles\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche\",\"type\":\"uint8\"}],\"name\":\"setIncentiveTranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateMainCharacterCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contr\",\"type\":\"address\"}],\"name\":\"updateRoleCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"crossOvercollateralizedBorrow(address,uint256,address,uint256)\":{\"details\":\"caution: the account still has to have a positive balaance at the end of the withdraw. So an underwater account may not be able to withdraw\"}},\"title\":\"Top level transaction controller\",\"version\":1},\"userdoc\":{\"events\":{\"CrossBorrow(address,address,uint256)\":{\"notice\":\"emitted upon sucessfully borrowing\"},\"CrossDeposit(address,address,uint256)\":{\"notice\":\"emitted when a trader depoits on cross margin\"},\"CrossOvercollateralizedBorrow(address,address,uint256,address,uint256)\":{\"notice\":\"emmited on deposit-borrow-withdraw\"},\"CrossTrade(address,address,uint256,uint256,address,uint256,uint256)\":{\"notice\":\"emitted whenever a trade happens\"},\"CrossWithdraw(address,address,uint256)\":{\"notice\":\"emitted when a trader withdraws funds\"}},\"kind\":\"user\",\"methods\":{\"WETH()\":{\"notice\":\"wrapped ETH ERC20 contract\"},\"authorizedSwapExactT4T(uint256,uint256,address[],address[])\":{\"notice\":\"make swaps on AMM using protocol funds, only for authorized contracts\"},\"crossBorrow(address,uint256)\":{\"notice\":\"borrow into cross margin trading account\"},\"crossCloseAccount()\":{\"notice\":\"close an account that is no longer borrowing and return gains\"},\"crossDeposit(address,uint256)\":{\"notice\":\"traders call this to deposit funds on cross margin\"},\"crossDepositETH()\":{\"notice\":\"deposit wrapped ehtereum into cross margin account\"},\"crossOvercollateralizedBorrow(address,uint256,address,uint256)\":{\"notice\":\"convenience function to perform overcollateralized borrowing against a cross margin account.\"},\"crossSwapExactTokensForTokens(uint256,uint256,address[],address[],uint256)\":{\"notice\":\"entry point for swapping tokens held in cross margin account\"},\"crossSwapTokensForExactTokens(uint256,uint256,address[],address[],uint256)\":{\"notice\":\"entry point for swapping tokens held in cross margin account\"},\"crossWithdraw(address,uint256)\":{\"notice\":\"withdraw deposits/earnings from cross margin account\"},\"crossWithdrawETH(uint256)\":{\"notice\":\"withdraw ethereum from cross margin account\"},\"setIncentiveTranche(address,uint8)\":{\"notice\":\"Set incentive tranche\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MarginRouter.sol\":\"MarginRouter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":9900},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x1cae4f85f114ff17b90414f5da67365b1d00337abb5bce9bf944eb78a2c0673c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf8e8d118a7a8b2e134181f7da655f6266aa3a0f9134b2605747139fcb0c5d835\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x99f5c21018d796db7833a2100bb0e7411999e248a3c950fb526eee5d2bf47cb7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x069b2631bb5b5193a58ccf7a06266c7361bd2c20095667af4402817605627f45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\",\"keccak256\":\"0xe5905c0989cf5a865ed9bb7b9252536ca011c5b744017a82a7d4443b9c00a891\"},\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\",\"keccak256\":\"0x7c9bc70e5996c763e02ff38905282bc24fb242b0ef2519a003b36824fc524a4b\"},\"contracts/Admin.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IncentiveDistribution.sol\\\";\\nimport \\\"./RoleAware.sol\\\";\\nimport \\\"./Fund.sol\\\";\\nimport \\\"./CrossMarginTrading.sol\\\";\\n\\n/** \\n@title Here we support staking for MFI incentives as well as\\nstaking to perform the maintenance role.\\n*/\\ncontract Admin is RoleAware {\\n    /// Margenswap (MFI) token address\\n    address public immutable MFI;\\n    mapping(address => uint256) public stakes;\\n    uint256 public totalStakes;\\n\\n    uint256 public maintenanceStakePerBlock = 10 ether;\\n    mapping(address => address) public nextMaintenanceStaker;\\n    mapping(address => mapping(address => bool)) public maintenanceDelegateTo;\\n    address public currentMaintenanceStaker;\\n    address public prevMaintenanceStaker;\\n    uint256 public currentMaintenanceStakerStartBlock;\\n    address public immutable lockedMFI;\\n\\n    constructor(\\n        address _MFI,\\n        address _lockedMFI,\\n        address lockedMFIDelegate,\\n        address _roles\\n    ) RoleAware(_roles) {\\n        MFI = _MFI;\\n        maintenanceStakePerBlock = 1 ether;\\n        lockedMFI = _lockedMFI;\\n\\n        // for initialization purposes and to ensure availability of service\\n        // the team's locked MFI participate in maintenance staking only\\n        // (not in the incentive staking part)\\n        // this implies some trust of the team to execute, which we deem reasonable\\n        // since the locked stake is temporary and diminishing as well as the fact\\n        // that the team is heavily invested in the protocol and incentivized\\n        // by fees like any other maintainer\\n        // furthermore others could step in to liquidate via the attacker route\\n        // and take away the team fees if they were delinquent\\n        nextMaintenanceStaker[_lockedMFI] = _lockedMFI;\\n        currentMaintenanceStaker = _lockedMFI;\\n        prevMaintenanceStaker = _lockedMFI;\\n        maintenanceDelegateTo[_lockedMFI][lockedMFIDelegate];\\n        currentMaintenanceStakerStartBlock = block.number;\\n    }\\n\\n    /// Maintence stake setter\\n    function setMaintenanceStakePerBlock(uint256 amount)\\n        external\\n        onlyOwnerExec\\n    {\\n        maintenanceStakePerBlock = amount;\\n    }\\n\\n    function _stake(address holder, uint256 amount) internal {\\n        Fund(fund()).depositFor(holder, MFI, amount);\\n\\n        stakes[holder] += amount;\\n        totalStakes += amount;\\n\\n        IncentiveDistribution(incentiveDistributor()).addToClaimAmount(\\n            1,\\n            holder,\\n            amount\\n        );\\n    }\\n\\n    /// Deposit a stake for sender\\n    function depositStake(uint256 amount) external {\\n        _stake(msg.sender, amount);\\n    }\\n\\n    function _withdrawStake(\\n        address holder,\\n        uint256 amount,\\n        address recipient\\n    ) internal {\\n        // overflow failure desirable\\n        stakes[holder] -= amount;\\n        totalStakes -= amount;\\n        Fund(fund()).withdraw(MFI, recipient, amount);\\n\\n        IncentiveDistribution(incentiveDistributor()).subtractFromClaimAmount(\\n            1,\\n            holder,\\n            amount\\n        );\\n    }\\n\\n    /// Withdraw stake for sender\\n    function withdrawStake(uint256 amount) external {\\n        require(\\n            !isAuthorizedStaker(msg.sender),\\n            \\\"You can't withdraw while you're authorized staker\\\"\\n        );\\n        _withdrawStake(msg.sender, amount, msg.sender);\\n    }\\n\\n    /// Deposit maintenance stake\\n    function depositMaintenanceStake(uint256 amount) external {\\n        require(\\n            amount + stakes[msg.sender] >= maintenanceStakePerBlock,\\n            \\\"Insufficient stake to call even one block\\\"\\n        );\\n        _stake(msg.sender, amount);\\n        if (nextMaintenanceStaker[msg.sender] == address(0)) {\\n            nextMaintenanceStaker[msg.sender] = getUpdatedCurrentStaker();\\n            nextMaintenanceStaker[prevMaintenanceStaker] = msg.sender;\\n        }\\n    }\\n\\n    function getMaintenanceStakerStake(address staker)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (staker == lockedMFI) {\\n            return IERC20(MFI).balanceOf(lockedMFI) / 2;\\n        } else {\\n            return stakes[staker];\\n        }\\n    }\\n\\n    function getUpdatedCurrentStaker() public returns (address) {\\n        uint256 currentStake =\\n            getMaintenanceStakerStake(currentMaintenanceStaker);\\n        while (\\n            (block.number - currentMaintenanceStakerStartBlock) *\\n                maintenanceStakePerBlock >=\\n            currentStake\\n        ) {\\n            if (maintenanceStakePerBlock > currentStake) {\\n                // delete current from daisy chain\\n                address nextOne =\\n                    nextMaintenanceStaker[currentMaintenanceStaker];\\n                nextMaintenanceStaker[prevMaintenanceStaker] = nextOne;\\n                nextMaintenanceStaker[currentMaintenanceStaker] = address(0);\\n\\n                currentMaintenanceStaker = nextOne;\\n            } else {\\n                currentMaintenanceStakerStartBlock +=\\n                    currentStake /\\n                    maintenanceStakePerBlock;\\n\\n                prevMaintenanceStaker = currentMaintenanceStaker;\\n                currentMaintenanceStaker = nextMaintenanceStaker[\\n                    currentMaintenanceStaker\\n                ];\\n            }\\n            currentStake = getMaintenanceStakerStake(currentMaintenanceStaker);\\n        }\\n        return currentMaintenanceStaker;\\n    }\\n\\n    function viewCurrentMaintenanceStaker()\\n        public\\n        view\\n        returns (address staker, uint256 startBlock)\\n    {\\n        staker = currentMaintenanceStaker;\\n        uint256 currentStake = getMaintenanceStakerStake(staker);\\n        startBlock = currentMaintenanceStakerStartBlock;\\n        while (\\n            (block.number - startBlock) * maintenanceStakePerBlock >=\\n            currentStake\\n        ) {\\n            if (maintenanceStakePerBlock > currentStake) {\\n                // skip\\n                staker = nextMaintenanceStaker[staker];\\n                currentStake = getMaintenanceStakerStake(staker);\\n            } else {\\n                startBlock += currentStake / maintenanceStakePerBlock;\\n                staker = nextMaintenanceStaker[staker];\\n                currentStake = getMaintenanceStakerStake(staker);\\n            }\\n        }\\n    }\\n\\n    /// Add a delegate for staker\\n    function addDelegate(address forStaker, address delegate) external {\\n        require(\\n            msg.sender == forStaker ||\\n                maintenanceDelegateTo[forStaker][msg.sender],\\n            \\\"msg.sender not authorized to delegate for staker\\\"\\n        );\\n        maintenanceDelegateTo[forStaker][delegate] = true;\\n    }\\n\\n    /// Remove a delegate for staker\\n    function removeDelegate(address forStaker, address delegate) external {\\n        require(\\n            msg.sender == forStaker ||\\n                maintenanceDelegateTo[forStaker][msg.sender],\\n            \\\"msg.sender not authorized to delegate for staker\\\"\\n        );\\n        maintenanceDelegateTo[forStaker][delegate] = false;\\n    }\\n\\n    function isAuthorizedStaker(address caller)\\n        public\\n        returns (bool isAuthorized)\\n    {\\n        address currentStaker = getUpdatedCurrentStaker();\\n        isAuthorized =\\n            currentStaker == caller ||\\n            maintenanceDelegateTo[currentStaker][caller];\\n    }\\n\\n    /// Penalize a staker\\n    function penalizeMaintenanceStake(\\n        address maintainer,\\n        uint256 penalty,\\n        address recipient\\n    ) external returns (uint256 stakeTaken) {\\n        require(\\n            isStakePenalizer(msg.sender),\\n            \\\"msg.sender not authorized to penalize stakers\\\"\\n        );\\n        if (penalty > stakes[maintainer]) {\\n            stakeTaken = stakes[maintainer];\\n        } else {\\n            stakeTaken = penalty;\\n        }\\n        _withdrawStake(maintainer, stakeTaken, recipient);\\n    }\\n}\\n\",\"keccak256\":\"0xa91e905abddc0d5dc60f3573259c331b33f4b2a65f1d468654f481f02cde50a4\",\"license\":\"BUSL-1.1\"},\"contracts/BaseLending.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./RoleAware.sol\\\";\\n\\n/// @title Base lending behavior\\nabstract contract BaseLending {\\n    uint256 constant FP32 = 2**32;\\n    uint256 constant ACCUMULATOR_INIT = 10**18;\\n\\n    struct YieldAccumulator {\\n        uint256 accumulatorFP;\\n        uint256 lastUpdated;\\n        uint256 hourlyYieldFP;\\n    }\\n\\n    struct LendingMetadata {\\n        uint256 totalLending;\\n        uint256 totalBorrowed;\\n        uint256 lendingBuffer;\\n        uint256 lendingCap;\\n    }\\n    mapping(address => LendingMetadata) public lendingMeta;\\n\\n    /// @dev accumulate interest per issuer (like compound indices)\\n    mapping(address => YieldAccumulator) public borrowYieldAccumulators;\\n\\n    uint256 public maxHourlyYieldFP;\\n    uint256 public yieldChangePerSecondFP;\\n\\n    /// @dev simple formula for calculating interest relative to accumulator\\n    function applyInterest(\\n        uint256 balance,\\n        uint256 accumulatorFP,\\n        uint256 yieldQuotientFP\\n    ) internal pure returns (uint256) {\\n        // 1 * FP / FP = 1\\n        return (balance * accumulatorFP) / yieldQuotientFP;\\n    }\\n\\n    /// update the yield for an asset based on recent supply and demand\\n    function updatedYieldFP(\\n        // previous yield\\n        uint256 _yieldFP,\\n        // timestamp\\n        uint256 lastUpdated,\\n        uint256 totalLendingInBucket,\\n        uint256 bucketTarget,\\n        uint256 buyingSpeed,\\n        uint256 withdrawingSpeed,\\n        uint256 bucketMaxYield\\n    ) internal view returns (uint256 yieldFP) {\\n        yieldFP = _yieldFP;\\n        uint256 timeDiff = block.timestamp - lastUpdated;\\n        uint256 yieldDiff = timeDiff * yieldChangePerSecondFP;\\n\\n        if (\\n            totalLendingInBucket >= bucketTarget ||\\n            buyingSpeed >= withdrawingSpeed\\n        ) {\\n            yieldFP -= min(yieldFP, yieldDiff);\\n        } else {\\n            yieldFP += yieldDiff;\\n            if (yieldFP > bucketMaxYield) {\\n                yieldFP = bucketMaxYield;\\n            }\\n        }\\n    }\\n\\n    function updateSpeed(\\n        uint256 speed,\\n        uint256 lastAction,\\n        uint256 amount,\\n        uint256 runtime\\n    ) internal view returns (uint256 newSpeed, uint256 newLastAction) {\\n        uint256 timeDiff = block.timestamp - lastAction;\\n        uint256 updateAmount = (amount * runtime) / (timeDiff + 1);\\n\\n        uint256 oldSpeedWeight = (runtime + 120 minutes) / 3;\\n        uint256 updateWeight = timeDiff + 1;\\n        // scale adjustment relative to runtime\\n        newSpeed =\\n            (speed * oldSpeedWeight + updateAmount * updateWeight) /\\n            (oldSpeedWeight + updateWeight);\\n        newLastAction = block.timestamp;\\n    }\\n\\n    /// @dev minimum\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a > b) {\\n            return b;\\n        } else {\\n            return a;\\n        }\\n    }\\n\\n    function _makeFallbackBond(\\n        address issuer,\\n        address holder,\\n        uint256 amount\\n    ) internal virtual;\\n\\n    function lendingTarget(LendingMetadata storage meta)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return min(meta.lendingCap, meta.totalBorrowed + meta.lendingBuffer);\\n    }\\n\\n    /// View lending target\\n    function viewLendingTarget(address issuer) external view returns (uint256) {\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        return lendingTarget(meta);\\n    }\\n\\n    /// Available tokens to this issuance\\n    function issuanceBalance(address issuance)\\n        internal\\n        view\\n        virtual\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0xe949439417190fbd5af9e3e05147c4e7775ea532f2b74a6449d2e7d1044afe33\",\"license\":\"BUSL-1.1\"},\"contracts/BondLending.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./BaseLending.sol\\\";\\n\\nstruct Bond {\\n    address holder;\\n    address issuer;\\n    uint256 originalPrice;\\n    uint256 returnAmount;\\n    uint256 maturityTimestamp;\\n    uint256 runtime;\\n    uint256 yieldFP;\\n}\\n\\n/** \\n@title Lending for fixed runtime, fixed interest\\nLenders can pick their own bond maturity date\\n@dev In order to manage interest rates for the different\\nmaturities and create a yield curve we bucket\\nbond runtimes into weighted baskets and adjust\\nrates individually per bucket, based on supply and demand.\\n*/\\nabstract contract BondLending is BaseLending {\\n    uint256 public minRuntime = 30 days;\\n    uint256 public maxRuntime = 365 days;\\n    uint256 public diffMaxMinRuntime;\\n    /** \\n    @dev this is the numerator under runtimeWeights.\\n    any excess left over is the weight of hourly bonds\\n    */\\n    uint256 public constant WEIGHT_TOTAL_10k = 10_000;\\n    uint256 public borrowingMarkupFP;\\n\\n    struct BondBucketMetadata {\\n        uint256 runtimeWeight;\\n        uint256 buyingSpeed;\\n        uint256 lastBought;\\n        uint256 withdrawingSpeed;\\n        uint256 lastWithdrawn;\\n        uint256 yieldLastUpdated;\\n        uint256 totalLending;\\n        uint256 runtimeYieldFP;\\n    }\\n\\n    mapping(uint256 => Bond) public bonds;\\n\\n    mapping(address => BondBucketMetadata[]) public bondBucketMetadata;\\n\\n    uint256 public nextBondIndex = 1;\\n\\n    event LiquidityWarning(\\n        address indexed issuer,\\n        address indexed holder,\\n        uint256 value\\n    );\\n\\n    function _makeBond(\\n        address holder,\\n        address issuer,\\n        uint256 runtime,\\n        uint256 amount,\\n        uint256 minReturn\\n    ) internal returns (uint256 bondIndex) {\\n        uint256 bucketIndex = getBucketIndex(issuer, runtime);\\n        BondBucketMetadata storage bondMeta =\\n            bondBucketMetadata[issuer][bucketIndex];\\n\\n        uint256 yieldFP = calcBondYieldFP(issuer, amount, runtime, bondMeta);\\n\\n        uint256 bondReturn = (yieldFP * amount) / FP32;\\n        if (bondReturn >= minReturn) {\\n            uint256 interpolatedAmount = (amount + bondReturn) / 2;\\n            lendingMeta[issuer].totalLending += interpolatedAmount;\\n\\n            bondMeta.totalLending += interpolatedAmount;\\n\\n            bondIndex = nextBondIndex;\\n            nextBondIndex++;\\n\\n            bonds[bondIndex] = Bond({\\n                holder: holder,\\n                issuer: issuer,\\n                originalPrice: amount,\\n                returnAmount: bondReturn,\\n                maturityTimestamp: block.timestamp + runtime,\\n                runtime: runtime,\\n                yieldFP: yieldFP\\n            });\\n\\n            (bondMeta.buyingSpeed, bondMeta.lastBought) = updateSpeed(\\n                bondMeta.buyingSpeed,\\n                bondMeta.lastBought,\\n                amount,\\n                runtime\\n            );\\n        }\\n    }\\n\\n    function _withdrawBond(uint256 bondId, Bond storage bond)\\n        internal\\n        returns (uint256 withdrawAmount)\\n    {\\n        address issuer = bond.issuer;\\n        uint256 bucketIndex = getBucketIndex(issuer, bond.runtime);\\n        BondBucketMetadata storage bondMeta =\\n            bondBucketMetadata[issuer][bucketIndex];\\n\\n        uint256 returnAmount = bond.returnAmount;\\n        address holder = bond.holder;\\n\\n        uint256 interpolatedAmount = (bond.originalPrice + returnAmount) / 2;\\n\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        meta.totalLending -= interpolatedAmount;\\n        bondMeta.totalLending -= interpolatedAmount;\\n\\n        (bondMeta.withdrawingSpeed, bondMeta.lastWithdrawn) = updateSpeed(\\n            bondMeta.withdrawingSpeed,\\n            bondMeta.lastWithdrawn,\\n            bond.originalPrice,\\n            bond.runtime\\n        );\\n\\n        delete bonds[bondId];\\n        if (\\n            meta.totalBorrowed > meta.totalLending ||\\n            issuanceBalance(issuer) < returnAmount\\n        ) {\\n            // apparently there is a liquidity issue\\n            emit LiquidityWarning(issuer, holder, returnAmount);\\n            _makeFallbackBond(issuer, holder, returnAmount);\\n        } else {\\n            withdrawAmount = returnAmount;\\n        }\\n    }\\n\\n    function calcBondYieldFP(\\n        address issuer,\\n        uint256 addedAmount,\\n        uint256 runtime,\\n        BondBucketMetadata storage bucketMeta\\n    ) internal view returns (uint256 yieldFP) {\\n        uint256 totalLendingInBucket = addedAmount + bucketMeta.totalLending;\\n\\n        yieldFP = bucketMeta.runtimeYieldFP;\\n        uint256 lastUpdated = bucketMeta.yieldLastUpdated;\\n\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        uint256 bucketTarget =\\n            (lendingTarget(meta) * bucketMeta.runtimeWeight) / WEIGHT_TOTAL_10k;\\n\\n        uint256 buying = bucketMeta.buyingSpeed;\\n        uint256 withdrawing = bucketMeta.withdrawingSpeed;\\n\\n        YieldAccumulator storage borrowAccumulator =\\n            borrowYieldAccumulators[issuer];\\n\\n        uint256 yieldGeneratedFP =\\n            (borrowAccumulator.hourlyYieldFP * meta.totalBorrowed) /\\n                (1 + meta.totalLending);\\n        uint256 _maxHourlyYieldFP = min(maxHourlyYieldFP, yieldGeneratedFP);\\n\\n        uint256 bucketMaxYield = _maxHourlyYieldFP * (runtime / (1 hours));\\n\\n        yieldFP = updatedYieldFP(\\n            yieldFP,\\n            lastUpdated,\\n            totalLendingInBucket,\\n            bucketTarget,\\n            buying,\\n            withdrawing,\\n            bucketMaxYield\\n        );\\n    }\\n\\n    /// Get view of returns on bond\\n    function viewBondReturn(\\n        address issuer,\\n        uint256 runtime,\\n        uint256 amount\\n    ) external view returns (uint256) {\\n        uint256 bucketIndex = getBucketIndex(issuer, runtime);\\n        uint256 yieldFP =\\n            calcBondYieldFP(\\n                issuer,\\n                amount + bondBucketMetadata[issuer][bucketIndex].totalLending,\\n                runtime,\\n                bondBucketMetadata[issuer][bucketIndex]\\n            );\\n        return (yieldFP * amount) / FP32;\\n    }\\n\\n    function getBucketIndex(address issuer, uint256 runtime)\\n        internal\\n        view\\n        returns (uint256 bucketIndex)\\n    {\\n        uint256 bucketSize =\\n            diffMaxMinRuntime / bondBucketMetadata[issuer].length;\\n        bucketIndex = (runtime - minRuntime) / bucketSize;\\n    }\\n}\\n\",\"keccak256\":\"0xee2781021cafc9e28553768678b85cf9687cded3d8f5da4f2d5bc5944263c89d\",\"license\":\"BUSL-1.1\"},\"contracts/CrossMarginAccounts.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./Fund.sol\\\";\\nimport \\\"./Lending.sol\\\";\\nimport \\\"./RoleAware.sol\\\";\\nimport \\\"./MarginRouter.sol\\\";\\nimport \\\"./PriceAware.sol\\\";\\n\\n// Goal: all external functions only accessible to margintrader role\\n// except for view functions of course\\n\\nstruct CrossMarginAccount {\\n    uint256 lastDepositBlock;\\n    address[] borrowTokens;\\n    // borrowed token address => amount\\n    mapping(address => uint256) borrowed;\\n    // borrowed token => yield quotient\\n    mapping(address => uint256) borrowedYieldQuotientsFP;\\n    address[] holdingTokens;\\n    // token held in portfolio => amount\\n    mapping(address => uint256) holdings;\\n    // boolean value of whether an account holds a token\\n    mapping(address => bool) holdsToken;\\n}\\n\\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\\n    /// @dev gets used in calculating how much accounts can borrow\\n    uint256 public leveragePercent;\\n\\n    /// @dev percentage of assets held per assets borrowed at which to liquidate\\n    uint256 public liquidationThresholdPercent;\\n\\n    /// @dev record of all cross margin accounts\\n    mapping(address => CrossMarginAccount) internal marginAccounts;\\n    /// @dev total token caps\\n    mapping(address => uint256) public tokenCaps;\\n    /// @dev tracks total of short positions per token\\n    mapping(address => uint256) public totalShort;\\n    /// @dev tracks total of long positions per token\\n    mapping(address => uint256) public totalLong;\\n    uint256 public coolingOffPeriod;\\n\\n    /// @dev last time this account deposited\\n    /// relevant for withdrawal window\\n    function getLastDepositBlock(address trader)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return marginAccounts[trader].lastDepositBlock;\\n    }\\n\\n    /// @dev add an asset to be held by account\\n    function addHolding(\\n        CrossMarginAccount storage account,\\n        address token,\\n        uint256 depositAmount\\n    ) internal {\\n        if (!hasHoldingToken(account, token)) {\\n            account.holdingTokens.push(token);\\n        }\\n\\n        account.holdings[token] += depositAmount;\\n    }\\n\\n    /// @dev adjust account to reflect borrowing of token amount\\n    function borrow(\\n        CrossMarginAccount storage account,\\n        address borrowToken,\\n        uint256 borrowAmount\\n    ) internal {\\n        if (!hasBorrowedToken(account, borrowToken)) {\\n            account.borrowTokens.push(borrowToken);\\n        } else {\\n            account.borrowed[borrowToken] = Lending(lending())\\n                .applyBorrowInterest(\\n                account.borrowed[borrowToken],\\n                borrowToken,\\n                account.borrowedYieldQuotientsFP[borrowToken]\\n            );\\n        }\\n        account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\\n            .viewBorrowingYieldFP(borrowToken);\\n\\n        account.borrowed[borrowToken] += borrowAmount;\\n        addHolding(account, borrowToken, borrowAmount);\\n\\n        require(positiveBalance(account), \\\"Can't borrow: insufficient balance\\\");\\n    }\\n\\n    /// @dev checks whether account is in the black, deposit + earnings relative to borrowed\\n    function positiveBalance(CrossMarginAccount storage account)\\n        internal\\n        returns (bool)\\n    {\\n        uint256 loan = loanInPeg(account, false);\\n        uint256 holdings = holdingsInPeg(account, false);\\n        // The following condition should hold:\\n        // holdings / loan >= leveragePercent / (leveragePercent - 100)\\n        // =>\\n        return holdings * (leveragePercent - 100) >= loan * leveragePercent;\\n    }\\n\\n    /// @dev internal function adjusting holding and borrow balances when debt extinguished\\n    function extinguishDebt(\\n        CrossMarginAccount storage account,\\n        address debtToken,\\n        uint256 extinguishAmount\\n    ) internal {\\n        // will throw if insufficient funds\\n        account.borrowed[debtToken] = Lending(lending()).applyBorrowInterest(\\n            account.borrowed[debtToken],\\n            debtToken,\\n            account.borrowedYieldQuotientsFP[debtToken]\\n        );\\n\\n        account.borrowed[debtToken] =\\n            account.borrowed[debtToken] -\\n            extinguishAmount;\\n        account.holdings[debtToken] =\\n            account.holdings[debtToken] -\\n            extinguishAmount;\\n\\n        if (account.borrowed[debtToken] > 0) {\\n            account.borrowedYieldQuotientsFP[debtToken] = Lending(lending())\\n                .viewBorrowingYieldFP(debtToken);\\n        } else {\\n            delete account.borrowedYieldQuotientsFP[debtToken];\\n\\n            bool decrement = false;\\n            uint256 len = account.borrowTokens.length;\\n            for (uint256 i; len > i; i++) {\\n                address currToken = account.borrowTokens[i];\\n                if (currToken == debtToken) {\\n                    decrement = true;\\n                } else if (decrement) {\\n                    account.borrowTokens[i - 1] = currToken;\\n                }\\n            }\\n            account.borrowTokens.pop();\\n        }\\n    }\\n\\n    /// @dev checks whether an account holds a token\\n    function hasHoldingToken(CrossMarginAccount storage account, address token)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return account.holdsToken[token];\\n    }\\n\\n    /// @dev checks whether an account has borrowed a token\\n    function hasBorrowedToken(CrossMarginAccount storage account, address token)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return account.borrowedYieldQuotientsFP[token] > 0;\\n    }\\n\\n    /// @dev calculate total loan in reference currency, including compound interest\\n    function loanInPeg(CrossMarginAccount storage account, bool forceCurBlock)\\n        internal\\n        returns (uint256)\\n    {\\n        return\\n            sumTokensInPegWithYield(\\n                account.borrowTokens,\\n                account.borrowed,\\n                account.borrowedYieldQuotientsFP,\\n                forceCurBlock\\n            );\\n    }\\n\\n    /// @dev total of assets of account, expressed in reference currency\\n    function holdingsInPeg(\\n        CrossMarginAccount storage account,\\n        bool forceCurBlock\\n    ) internal returns (uint256) {\\n        return\\n            sumTokensInPeg(\\n                account.holdingTokens,\\n                account.holdings,\\n                forceCurBlock\\n            );\\n    }\\n\\n    /// @dev check whether an account can/should be liquidated\\n    function belowMaintenanceThreshold(CrossMarginAccount storage account)\\n        internal\\n        returns (bool)\\n    {\\n        uint256 loan = loanInPeg(account, true);\\n        uint256 holdings = holdingsInPeg(account, true);\\n        // The following should hold:\\n        // holdings / loan >= 1.1\\n        // => holdings >= loan * 1.1\\n        return 100 * holdings >= liquidationThresholdPercent * loan;\\n    }\\n\\n    /// @dev go through list of tokens and their amounts, summing up\\n    function sumTokensInPeg(\\n        address[] storage tokens,\\n        mapping(address => uint256) storage amounts,\\n        bool forceCurBlock\\n    ) internal returns (uint256 totalPeg) {\\n        uint256 len = tokens.length;\\n        for (uint256 tokenId; tokenId < len; tokenId++) {\\n            address token = tokens[tokenId];\\n            totalPeg += PriceAware.getCurrentPriceInPeg(\\n                token,\\n                amounts[token],\\n                forceCurBlock\\n            );\\n        }\\n    }\\n\\n    /// @dev go through list of tokens and their amounts, summing up\\n    function viewTokensInPeg(\\n        address[] storage tokens,\\n        mapping(address => uint256) storage amounts\\n    ) internal view returns (uint256 totalPeg) {\\n        uint256 len = tokens.length;\\n        for (uint256 tokenId; tokenId < len; tokenId++) {\\n            address token = tokens[tokenId];\\n            totalPeg += PriceAware.viewCurrentPriceInPeg(token, amounts[token]);\\n        }\\n    }\\n\\n    /// @dev go through list of tokens and ammounts, summing up with interest\\n    function sumTokensInPegWithYield(\\n        address[] storage tokens,\\n        mapping(address => uint256) storage amounts,\\n        mapping(address => uint256) storage yieldQuotientsFP,\\n        bool forceCurBlock\\n    ) internal returns (uint256 totalPeg) {\\n        uint256 len = tokens.length;\\n        for (uint256 tokenId; tokenId < len; tokenId++) {\\n            address token = tokens[tokenId];\\n            totalPeg += yieldTokenInPeg(\\n                token,\\n                amounts[token],\\n                yieldQuotientsFP,\\n                forceCurBlock\\n            );\\n        }\\n    }\\n\\n    /// @dev go through list of tokens and ammounts, summing up with interest\\n    function viewTokensInPegWithYield(\\n        address[] storage tokens,\\n        mapping(address => uint256) storage amounts,\\n        mapping(address => uint256) storage yieldQuotientsFP\\n    ) internal view returns (uint256 totalPeg) {\\n        uint256 len = tokens.length;\\n        for (uint256 tokenId; tokenId < len; tokenId++) {\\n            address token = tokens[tokenId];\\n            totalPeg += viewYieldTokenInPeg(\\n                token,\\n                amounts[token],\\n                yieldQuotientsFP\\n            );\\n        }\\n    }\\n\\n    /// @dev calculate yield for token amount and convert to reference currency\\n    function yieldTokenInPeg(\\n        address token,\\n        uint256 amount,\\n        mapping(address => uint256) storage yieldQuotientsFP,\\n        bool forceCurBlock\\n    ) internal returns (uint256) {\\n        uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\\n        // 1 * FP / FP = 1\\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\\n        return\\n            PriceAware.getCurrentPriceInPeg(\\n                token,\\n                amountInToken,\\n                forceCurBlock\\n            );\\n    }\\n\\n    /// @dev calculate yield for token amount and convert to reference currency\\n    function viewYieldTokenInPeg(\\n        address token,\\n        uint256 amount,\\n        mapping(address => uint256) storage yieldQuotientsFP\\n    ) internal view returns (uint256) {\\n        uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\\n        // 1 * FP / FP = 1\\n        uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\\n        return PriceAware.viewCurrentPriceInPeg(token, amountInToken);\\n    }\\n\\n    /// @dev move tokens from one holding to another\\n    function adjustAmounts(\\n        CrossMarginAccount storage account,\\n        address fromToken,\\n        address toToken,\\n        uint256 soldAmount,\\n        uint256 boughtAmount\\n    ) internal {\\n        account.holdings[fromToken] = account.holdings[fromToken] - soldAmount;\\n        addHolding(account, toToken, boughtAmount);\\n    }\\n\\n    /// sets borrow and holding to zero\\n    function deleteAccount(CrossMarginAccount storage account) internal {\\n        uint256 len = account.borrowTokens.length;\\n        for (uint256 borrowIdx; len > borrowIdx; borrowIdx++) {\\n            address borrowToken = account.borrowTokens[borrowIdx];\\n            totalShort[borrowToken] -= account.borrowed[borrowToken];\\n            account.borrowed[borrowToken] = 0;\\n            account.borrowedYieldQuotientsFP[borrowToken] = 0;\\n        }\\n        len = account.holdingTokens.length;\\n        for (uint256 holdingIdx; len > holdingIdx; holdingIdx++) {\\n            address holdingToken = account.holdingTokens[holdingIdx];\\n            totalLong[holdingToken] -= account.holdings[holdingToken];\\n            account.holdings[holdingToken] = 0;\\n            account.holdsToken[holdingToken] = false;\\n        }\\n        delete account.borrowTokens;\\n        delete account.holdingTokens;\\n    }\\n\\n    /// @dev minimum\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a > b) {\\n            return b;\\n        } else {\\n            return a;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3636f8fb62dd762b6ace00d40013584a859e515e901dd65691b04608bbdf1ac1\",\"license\":\"BUSL-1.1\"},\"contracts/CrossMarginLiquidation.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CrossMarginAccounts.sol\\\";\\n\\n/** \\n@title Handles liquidation of accounts below maintenance threshold\\n@notice Liquidation can be called by the authorized staker, \\nas determined in the Admin contract.\\nIf the authorized staker is delinquent, other participants can jump\\nin and attack, taking their fees and potentially even their stake,\\ndepending how delinquent the responsible authorized staker is.\\n*/\\nabstract contract CrossMarginLiquidation is CrossMarginAccounts {\\n    event LiquidationShortfall(uint256 amount);\\n    event AccountLiquidated(address account);\\n\\n    struct Liquidation {\\n        uint256 buy;\\n        uint256 sell;\\n        uint256 blockNum;\\n    }\\n\\n    /// record kept around until a stake attacker can claim their reward\\n    struct AccountLiqRecord {\\n        uint256 blockNum;\\n        address loser;\\n        uint256 amount;\\n        address stakeAttacker;\\n    }\\n\\n    mapping(address => Liquidation) liquidationAmounts;\\n    address[] internal sellTokens;\\n    address[] internal buyTokens;\\n    address[] internal tradersToLiquidate;\\n\\n    mapping(address => uint256) public maintenanceFailures;\\n    mapping(address => AccountLiqRecord) public stakeAttackRecords;\\n    uint256 public avgLiquidationPerCall = 10;\\n\\n    uint256 public liqStakeAttackWindow = 5;\\n    uint256 public MAINTAINER_CUT_PERCENT = 5;\\n\\n    uint256 public failureThreshold = 10;\\n\\n    /// Set failure threshold\\n    function setFailureThreshold(uint256 threshFactor) external onlyOwnerExec {\\n        failureThreshold = threshFactor;\\n    }\\n\\n    /// Set liquidity stake attack window\\n    function setLiqStakeAttackWindow(uint256 window) external onlyOwnerExec {\\n        liqStakeAttackWindow = window;\\n    }\\n\\n    /// Set maintainer's percent cut\\n    function setMaintainerCutPercent(uint256 cut) external onlyOwnerExec {\\n        MAINTAINER_CUT_PERCENT = cut;\\n    }\\n\\n    /// @dev calcLiquidationAmounts does a number of tasks in this contract\\n    /// and some of them are not straightforward.\\n    /// First of all it aggregates liquidation amounts,\\n    /// as well as which traders are ripe for liquidation, in storage (not in memory)\\n    /// owing to the fact that arrays can't be pushed to and hash maps don't\\n    /// exist in memory.\\n    /// Then it also returns any stake attack funds if the stake was unsuccessful\\n    /// (i.e. current caller is authorized). Also see context below.\\n    function calcLiquidationAmounts(\\n        address[] memory liquidationCandidates,\\n        bool isAuthorized\\n    ) internal returns (uint256 attackReturns) {\\n        sellTokens = new address[](0);\\n        buyTokens = new address[](0);\\n        tradersToLiquidate = new address[](0);\\n\\n        for (\\n            uint256 traderIndex = 0;\\n            liquidationCandidates.length > traderIndex;\\n            traderIndex++\\n        ) {\\n            address traderAddress = liquidationCandidates[traderIndex];\\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\\n            if (belowMaintenanceThreshold(account)) {\\n                tradersToLiquidate.push(traderAddress);\\n                for (\\n                    uint256 sellIdx = 0;\\n                    account.holdingTokens.length > sellIdx;\\n                    sellIdx++\\n                ) {\\n                    address token = account.holdingTokens[sellIdx];\\n                    Liquidation storage liquidation = liquidationAmounts[token];\\n\\n                    if (liquidation.blockNum != block.number) {\\n                        liquidation.sell = account.holdings[token];\\n                        liquidation.buy = 0;\\n                        liquidation.blockNum = block.number;\\n                        sellTokens.push(token);\\n                    } else {\\n                        liquidation.sell += account.holdings[token];\\n                    }\\n                }\\n                for (\\n                    uint256 buyIdx = 0;\\n                    account.borrowTokens.length > buyIdx;\\n                    buyIdx++\\n                ) {\\n                    address token = account.borrowTokens[buyIdx];\\n                    Liquidation storage liquidation = liquidationAmounts[token];\\n\\n                    uint256 loanAmount =\\n                        Lending(lending()).applyBorrowInterest(\\n                            account.borrowed[token],\\n                            token,\\n                            account.borrowedYieldQuotientsFP[token]\\n                        );\\n\\n                    Lending(lending()).payOff(token, loanAmount);\\n\\n                    if (liquidation.blockNum != block.number) {\\n                        liquidation.sell = 0;\\n                        liquidation.buy = loanAmount;\\n                        liquidation.blockNum = block.number;\\n                        buyTokens.push(token);\\n                    } else {\\n                        liquidation.buy += loanAmount;\\n                    }\\n                }\\n            }\\n\\n            AccountLiqRecord storage liqAttackRecord =\\n                stakeAttackRecords[traderAddress];\\n            if (isAuthorized) {\\n                attackReturns += _disburseLiqAttack(liqAttackRecord);\\n            }\\n        }\\n    }\\n\\n    function _disburseLiqAttack(AccountLiqRecord storage liqAttackRecord)\\n        internal\\n        returns (uint256 returnAmount)\\n    {\\n        if (liqAttackRecord.amount > 0) {\\n            // validate attack records, if any\\n            uint256 blockDiff =\\n                min(\\n                    block.number - liqAttackRecord.blockNum,\\n                    liqStakeAttackWindow\\n                );\\n\\n            uint256 attackerCut =\\n                (liqAttackRecord.amount * blockDiff) / liqStakeAttackWindow;\\n\\n            Fund(fund()).withdraw(\\n                PriceAware.peg,\\n                liqAttackRecord.stakeAttacker,\\n                attackerCut\\n            );\\n\\n            Admin a = Admin(admin());\\n            uint256 penalty =\\n                (a.maintenanceStakePerBlock() * attackerCut) /\\n                    avgLiquidationPerCall;\\n            a.penalizeMaintenanceStake(\\n                liqAttackRecord.loser,\\n                penalty,\\n                liqAttackRecord.stakeAttacker\\n            );\\n\\n            // return remainder, after cut was taken to authorized stakekr\\n            returnAmount = liqAttackRecord.amount - attackerCut;\\n        }\\n    }\\n\\n    /// Disburse liquidity stake attacks\\n    function disburseLiqStakeAttacks(address[] memory liquidatedAccounts)\\n        external\\n    {\\n        for (uint256 i = 0; liquidatedAccounts.length > i; i++) {\\n            address liqAccount = liquidatedAccounts[i];\\n            AccountLiqRecord storage liqAttackRecord =\\n                stakeAttackRecords[liqAccount];\\n            if (\\n                block.number > liqAttackRecord.blockNum + liqStakeAttackWindow\\n            ) {\\n                _disburseLiqAttack(liqAttackRecord);\\n                delete stakeAttackRecords[liqAccount];\\n            }\\n        }\\n    }\\n\\n    function liquidateFromPeg() internal returns (uint256 pegAmount) {\\n        for (uint256 tokenIdx = 0; buyTokens.length > tokenIdx; tokenIdx++) {\\n            address buyToken = buyTokens[tokenIdx];\\n            Liquidation storage liq = liquidationAmounts[buyToken];\\n            if (liq.buy > liq.sell) {\\n                pegAmount += PriceAware.liquidateFromPeg(\\n                    buyToken,\\n                    liq.buy - liq.sell\\n                );\\n                delete liquidationAmounts[buyToken];\\n            }\\n        }\\n        delete buyTokens;\\n    }\\n\\n    function liquidateToPeg() internal returns (uint256 pegAmount) {\\n        for (\\n            uint256 tokenIndex = 0;\\n            sellTokens.length > tokenIndex;\\n            tokenIndex++\\n        ) {\\n            address token = sellTokens[tokenIndex];\\n            Liquidation storage liq = liquidationAmounts[token];\\n            if (liq.sell > liq.buy) {\\n                uint256 sellAmount = liq.sell - liq.buy;\\n                pegAmount += PriceAware.liquidateToPeg(token, sellAmount);\\n                delete liquidationAmounts[token];\\n            }\\n        }\\n        delete sellTokens;\\n    }\\n\\n    function maintainerIsFailing() internal view returns (bool) {\\n        (address currentMaintainer, ) =\\n            Admin(admin()).viewCurrentMaintenanceStaker();\\n        return\\n            maintenanceFailures[currentMaintainer] >\\n            failureThreshold * avgLiquidationPerCall;\\n    }\\n\\n    /// called by maintenance stakers to liquidate accounts below liquidation threshold\\n    function liquidate(address[] memory liquidationCandidates)\\n        external\\n        noIntermediary\\n        returns (uint256 maintainerCut)\\n    {\\n        bool isAuthorized = Admin(admin()).isAuthorizedStaker(msg.sender);\\n        bool canTakeNow = isAuthorized || maintainerIsFailing();\\n\\n        // calcLiquidationAmounts does a lot of the work here\\n        // * aggregates both sell and buy side targets to be liquidated\\n        // * returns attacker cuts to them\\n        // * aggregates any returned fees from unauthorized (attacking) attempts\\n        maintainerCut = calcLiquidationAmounts(\\n            liquidationCandidates,\\n            isAuthorized\\n        );\\n\\n        uint256 sale2pegAmount = liquidateToPeg();\\n        uint256 peg2targetCost = liquidateFromPeg();\\n\\n        // this may be a bit imprecise, since individual shortfalls may be obscured\\n        // by overall returns and the maintainer cut is taken out of the net total,\\n        // but it gives us the general picture\\n        if (\\n            (peg2targetCost * (100 + MAINTAINER_CUT_PERCENT)) / 100 >\\n            sale2pegAmount\\n        ) {\\n            emit LiquidationShortfall(\\n                (peg2targetCost * (100 + MAINTAINER_CUT_PERCENT)) /\\n                    100 -\\n                    sale2pegAmount\\n            );\\n        }\\n\\n        address loser = address(0);\\n        if (!canTakeNow) {\\n            // whoever is the current responsible maintenance staker\\n            // and liable to lose their stake\\n            loser = Admin(admin()).getUpdatedCurrentStaker();\\n        }\\n\\n        // iterate over traders and send back their money\\n        // as well as giving attackers their due, in case caller isn't authorized\\n        for (\\n            uint256 traderIdx = 0;\\n            tradersToLiquidate.length > traderIdx;\\n            traderIdx++\\n        ) {\\n            address traderAddress = tradersToLiquidate[traderIdx];\\n            CrossMarginAccount storage account = marginAccounts[traderAddress];\\n\\n            uint256 holdingsValue = holdingsInPeg(account, true);\\n            uint256 borrowValue = loanInPeg(account, true);\\n            // 5% of value borrowed\\n            uint256 maintainerCut4Account =\\n                (borrowValue * MAINTAINER_CUT_PERCENT) / 100;\\n            maintainerCut += maintainerCut4Account;\\n\\n            if (!canTakeNow) {\\n                // This could theoretically lead to a previous attackers\\n                // record being overwritten, but only if the trader restarts\\n                // their account and goes back into the red within the short time window\\n                // which would be a costly attack requiring collusion without upside\\n                AccountLiqRecord storage liqAttackRecord =\\n                    stakeAttackRecords[traderAddress];\\n                liqAttackRecord.amount = maintainerCut4Account;\\n                liqAttackRecord.stakeAttacker = msg.sender;\\n                liqAttackRecord.blockNum = block.number;\\n                liqAttackRecord.loser = loser;\\n            }\\n\\n            // send back trader money\\n            if (holdingsValue >= maintainerCut4Account + borrowValue) {\\n                // send remaining funds back to trader\\n                Fund(fund()).withdraw(\\n                    PriceAware.peg,\\n                    traderAddress,\\n                    holdingsValue - borrowValue - maintainerCut4Account\\n                );\\n            }\\n\\n            emit AccountLiquidated(traderAddress);\\n            deleteAccount(account);\\n        }\\n\\n        avgLiquidationPerCall =\\n            (avgLiquidationPerCall * 99 + maintainerCut) /\\n            100;\\n\\n        if (canTakeNow) {\\n            Fund(fund()).withdraw(PriceAware.peg, msg.sender, maintainerCut);\\n        }\\n\\n        address currentMaintainer = Admin(admin()).getUpdatedCurrentStaker();\\n        if (isAuthorized) {\\n            if (maintenanceFailures[currentMaintainer] > maintainerCut) {\\n                maintenanceFailures[currentMaintainer] -= maintainerCut;\\n            } else {\\n                maintenanceFailures[currentMaintainer] = 0;\\n            }\\n        } else {\\n            maintenanceFailures[currentMaintainer] += maintainerCut;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbe0a001b27877e543479e4185183fc5777221d90787f2f7ba0b265b575227c78\",\"license\":\"BUSL-1.1\"},\"contracts/CrossMarginTrading.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./Fund.sol\\\";\\nimport \\\"./Lending.sol\\\";\\nimport \\\"./RoleAware.sol\\\";\\nimport \\\"./MarginRouter.sol\\\";\\nimport \\\"./CrossMarginLiquidation.sol\\\";\\n\\n// Goal: all external functions only accessible to margintrader role\\n// except for view functions of course\\n\\ncontract CrossMarginTrading is CrossMarginLiquidation, IMarginTrading {\\n    constructor(address _peg, address _roles)\\n        RoleAware(_roles)\\n        PriceAware(_peg)\\n    {\\n        liquidationThresholdPercent = 110;\\n        coolingOffPeriod = 20;\\n        leveragePercent = 300;\\n    }\\n\\n    /// @dev admin function to set the token cap\\n    function setTokenCap(address token, uint256 cap)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        tokenCaps[token] = cap;\\n    }\\n\\n    /// @dev setter for cooling off period for withdrawing funds after deposit\\n    function setCoolingOffPeriod(uint256 blocks) external onlyOwnerExec {\\n        coolingOffPeriod = blocks;\\n    }\\n\\n    /// @dev admin function to set leverage\\n    function setLeverage(uint256 _leveragePercent) external onlyOwnerExec {\\n        leveragePercent = _leveragePercent;\\n    }\\n\\n    /// @dev admin function to set liquidation threshold\\n    function setLiquidationThresholdPercent(uint256 threshold)\\n        external\\n        onlyOwnerExec\\n    {\\n        liquidationThresholdPercent = threshold;\\n    }\\n\\n    /// @dev gets called by router to affirm a deposit to an account\\n    function registerDeposit(\\n        address trader,\\n        address token,\\n        uint256 depositAmount\\n    ) external override returns (uint256 extinguishableDebt) {\\n        require(\\n            isMarginTrader(msg.sender),\\n            \\\"Calling contract not authorized to deposit\\\"\\n        );\\n\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        account.lastDepositBlock = block.number;\\n\\n        if (account.borrowed[token] > 0) {\\n            extinguishableDebt = min(depositAmount, account.borrowed[token]);\\n            extinguishDebt(account, token, extinguishableDebt);\\n            totalShort[token] -= extinguishableDebt;\\n        }\\n\\n        // no overflow because depositAmount >= extinguishableDebt\\n        uint256 addedHolding = depositAmount - extinguishableDebt;\\n        _registerDeposit(account, token, addedHolding);\\n    }\\n\\n    function _registerDeposit(\\n        CrossMarginAccount storage account,\\n        address token,\\n        uint256 addedHolding\\n    ) internal {\\n        addHolding(account, token, addedHolding);\\n\\n        totalLong[token] += addedHolding;\\n        require(\\n            tokenCaps[token] >= totalLong[token],\\n            \\\"Exceeding global exposure cap to token -- try again later\\\"\\n        );\\n    }\\n\\n    /// @dev gets called by router to affirm borrowing event\\n    function registerBorrow(\\n        address trader,\\n        address borrowToken,\\n        uint256 borrowAmount\\n    ) external override {\\n        require(\\n            isMarginTrader(msg.sender),\\n            \\\"Calling contract not authorized to deposit\\\"\\n        );\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        _registerBorrow(account, borrowToken, borrowAmount);\\n    }\\n\\n    function _registerBorrow(\\n        CrossMarginAccount storage account,\\n        address borrowToken,\\n        uint256 borrowAmount\\n    ) internal {\\n        totalShort[borrowToken] += borrowAmount;\\n        totalLong[borrowToken] += borrowAmount;\\n        require(\\n            tokenCaps[borrowToken] >= totalShort[borrowToken] &&\\n                tokenCaps[borrowToken] >= totalLong[borrowToken],\\n            \\\"Exceeding global exposure cap to token -- try again later\\\"\\n        );\\n\\n        borrow(account, borrowToken, borrowAmount);\\n    }\\n\\n    /// @dev gets called by router to affirm withdrawal of tokens from account\\n    function registerWithdrawal(\\n        address trader,\\n        address withdrawToken,\\n        uint256 withdrawAmount\\n    ) external override {\\n        require(\\n            isMarginTrader(msg.sender),\\n            \\\"Calling contract not authorized to deposit\\\"\\n        );\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        _registerWithdrawal(account, withdrawToken, withdrawAmount);\\n    }\\n\\n    function _registerWithdrawal(\\n        CrossMarginAccount storage account,\\n        address withdrawToken,\\n        uint256 withdrawAmount\\n    ) internal {\\n        require(\\n            block.number > account.lastDepositBlock + coolingOffPeriod,\\n            \\\"To prevent attacks you must wait until your cooling off period is over to withdraw\\\"\\n        );\\n\\n        totalLong[withdrawToken] -= withdrawAmount;\\n        // throws on underflow\\n        account.holdings[withdrawToken] =\\n            account.holdings[withdrawToken] -\\n            withdrawAmount;\\n        require(\\n            positiveBalance(account),\\n            \\\"Account balance is too low to withdraw\\\"\\n        );\\n    }\\n\\n    /// @dev overcollateralized borrowing on a cross margin account, called by router\\n    function registerOvercollateralizedBorrow(\\n        address trader,\\n        address depositToken,\\n        uint256 depositAmount,\\n        address borrowToken,\\n        uint256 withdrawAmount\\n    ) external override {\\n        require(\\n            isMarginTrader(msg.sender),\\n            \\\"Calling contract not authorized to deposit\\\"\\n        );\\n\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n\\n        _registerDeposit(account, depositToken, depositAmount);\\n        _registerBorrow(account, borrowToken, withdrawAmount);\\n        _registerWithdrawal(account, borrowToken, withdrawAmount);\\n\\n        account.lastDepositBlock = block.number;\\n    }\\n\\n    /// @dev gets called by router to register a trade and borrow and extinguish as necessary\\n    function registerTradeAndBorrow(\\n        address trader,\\n        address tokenFrom,\\n        address tokenTo,\\n        uint256 inAmount,\\n        uint256 outAmount\\n    )\\n        external\\n        override\\n        returns (uint256 extinguishableDebt, uint256 borrowAmount)\\n    {\\n        require(\\n            isMarginTrader(msg.sender),\\n            \\\"Calling contract is not an authorized margin trader agent\\\"\\n        );\\n\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n\\n        if (account.borrowed[tokenTo] > 0) {\\n            extinguishableDebt = min(outAmount, account.borrowed[tokenTo]);\\n            extinguishDebt(account, tokenTo, extinguishableDebt);\\n            totalShort[tokenTo] -= extinguishableDebt;\\n        }\\n        totalLong[tokenFrom] -= inAmount;\\n        totalLong[tokenTo] += outAmount - extinguishableDebt;\\n        require(\\n            tokenCaps[tokenTo] >= totalLong[tokenTo],\\n            \\\"Exceeding global exposure cap to token -- try again later\\\"\\n        );\\n\\n        uint256 sellAmount = inAmount;\\n        if (inAmount > account.holdings[tokenFrom]) {\\n            sellAmount = account.holdings[tokenFrom];\\n            /// won't overflow\\n            borrowAmount = inAmount - sellAmount;\\n\\n            totalShort[tokenFrom] += borrowAmount;\\n            require(\\n                tokenCaps[tokenFrom] >= totalShort[tokenFrom],\\n                \\\"Exceeding global exposure cap to token -- try again later\\\"\\n            );\\n\\n            borrow(account, tokenFrom, borrowAmount);\\n        }\\n        adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);\\n    }\\n\\n    /// @dev can get called by router to register the dissolution of an account\\n    function registerLiquidation(address trader) external override {\\n        require(\\n            isMarginTrader(msg.sender),\\n            \\\"Calling contract is not an authorized margin trader agent\\\"\\n        );\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        require(\\n            loanInPeg(account, false) == 0,\\n            \\\"Can't liquidate currently borrowing account\\\"\\n        );\\n\\n        deleteAccount(account);\\n    }\\n\\n    /// @dev view function to display account held assets state\\n    function getHoldingAmounts(address trader)\\n        external\\n        view\\n        override\\n        returns (\\n            address[] memory holdingTokens,\\n            uint256[] memory holdingAmounts\\n        )\\n    {\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        holdingTokens = account.holdingTokens;\\n\\n        holdingAmounts = new uint256[](account.holdingTokens.length);\\n        for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\\n            address tokenAddress = holdingTokens[idx];\\n            holdingAmounts[idx] = account.holdings[tokenAddress];\\n        }\\n    }\\n\\n    /// @dev view function to display account borrowing state\\n    function getBorrowAmounts(address trader)\\n        external\\n        view\\n        override\\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts)\\n    {\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        borrowTokens = account.borrowTokens;\\n\\n        borrowAmounts = new uint256[](account.borrowTokens.length);\\n        for (uint256 idx = 0; borrowTokens.length > idx; idx++) {\\n            address tokenAddress = borrowTokens[idx];\\n            borrowAmounts[idx] = Lending(lending()).viewBorrowInterest(\\n                account.borrowed[tokenAddress],\\n                tokenAddress,\\n                account.borrowedYieldQuotientsFP[tokenAddress]\\n            );\\n        }\\n    }\\n\\n    /// @dev view function to get loan amount in peg\\n    function viewLoanInPeg(address trader)\\n        external\\n        view\\n        returns (uint256 amount)\\n    {\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        return\\n            viewTokensInPegWithYield(\\n                account.borrowTokens,\\n                account.borrowed,\\n                account.borrowedYieldQuotientsFP\\n            );\\n    }\\n\\n    /// @dev total of assets of account, expressed in reference currency\\n    function viewHoldingsInPeg(address trader) external view returns (uint256) {\\n        CrossMarginAccount storage account = marginAccounts[trader];\\n        return viewTokensInPeg(account.holdingTokens, account.holdings);\\n    }\\n}\\n\",\"keccak256\":\"0x1775d5ea9efbe4f0d0b57de7d6993406264d3d157756b9e3f59cae4674fff7ba\",\"license\":\"BUSL-1.1\"},\"contracts/Fund.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"./RoleAware.sol\\\";\\n\\n/// @title Manage funding\\ncontract Fund is RoleAware {\\n    using SafeERC20 for IERC20;\\n    /// wrapped ether\\n    address public immutable WETH;\\n\\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\\n        WETH = _WETH;\\n    }\\n\\n    /// Deposit an active token\\n    function deposit(address depositToken, uint256 depositAmount) external {\\n        IERC20(depositToken).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            depositAmount\\n        );\\n    }\\n\\n    /// Deposit token on behalf of `sender`\\n    function depositFor(\\n        address sender,\\n        address depositToken,\\n        uint256 depositAmount\\n    ) external {\\n        require(\\n            isFundTransferer(msg.sender),\\n            \\\"Contract not authorized to deposit for user\\\"\\n        );\\n        IERC20(depositToken).safeTransferFrom(\\n            sender,\\n            address(this),\\n            depositAmount\\n        );\\n    }\\n\\n    /// Deposit to wrapped ether\\n    function depositToWETH() external payable {\\n        IWETH(WETH).deposit{value: msg.value}();\\n    }\\n\\n    // withdrawers role\\n    function withdraw(\\n        address withdrawalToken,\\n        address recipient,\\n        uint256 withdrawalAmount\\n    ) external {\\n        require(\\n            isFundTransferer(msg.sender),\\n            \\\"Contract not authorized to withdraw\\\"\\n        );\\n        IERC20(withdrawalToken).safeTransfer(recipient, withdrawalAmount);\\n    }\\n\\n    // withdrawers role\\n    function withdrawETH(address recipient, uint256 withdrawalAmount) external {\\n        require(isFundTransferer(msg.sender), \\\"Not authorized to withdraw\\\");\\n        IWETH(WETH).withdraw(withdrawalAmount);\\n        Address.sendValue(payable(recipient), withdrawalAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x52f9f08048d3fbc3214259051c0fbfd5e6a6247542deb50c088af3d8aff9ff03\",\"license\":\"BUSL-1.1\"},\"contracts/HourlyBondSubscriptionLending.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseLending.sol\\\";\\n\\nstruct HourlyBond {\\n    uint256 amount;\\n    uint256 yieldQuotientFP;\\n    uint256 moduloHour;\\n}\\n\\n/// @title Here we offer subscriptions to auto-renewing hourly bonds\\n/// Funds are locked in for an 50 minutes per hour, while interest rates float\\nabstract contract HourlyBondSubscriptionLending is BaseLending {\\n    struct HourlyBondMetadata {\\n        YieldAccumulator yieldAccumulator;\\n        uint256 buyingSpeed;\\n        uint256 withdrawingSpeed;\\n        uint256 lastBought;\\n        uint256 lastWithdrawn;\\n    }\\n\\n    mapping(address => HourlyBondMetadata) hourlyBondMetadata;\\n\\n    uint256 public withdrawalWindow = 10 minutes;\\n    // issuer => holder => bond record\\n    mapping(address => mapping(address => HourlyBond))\\n        public hourlyBondAccounts;\\n\\n    uint256 public borrowingFactorPercent = 200;\\n\\n    function _makeHourlyBond(\\n        address issuer,\\n        address holder,\\n        uint256 amount\\n    ) internal {\\n        HourlyBond storage bond = hourlyBondAccounts[issuer][holder];\\n        updateHourlyBondAmount(issuer, bond);\\n\\n        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];\\n        bond.yieldQuotientFP = bondMeta.yieldAccumulator.accumulatorFP;\\n        bond.moduloHour = block.timestamp % (1 hours);\\n        bond.amount += amount;\\n        lendingMeta[issuer].totalLending += amount;\\n\\n        (bondMeta.buyingSpeed, bondMeta.lastBought) = updateSpeed(\\n            bondMeta.buyingSpeed,\\n            bondMeta.lastBought,\\n            amount,\\n            1 hours\\n        );\\n    }\\n\\n    function updateHourlyBondAmount(address issuer, HourlyBond storage bond)\\n        internal\\n    {\\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\\n        if (yieldQuotientFP > 0) {\\n            YieldAccumulator storage yA =\\n                getUpdatedHourlyYield(issuer, hourlyBondMetadata[issuer]);\\n\\n            uint256 oldAmount = bond.amount;\\n            bond.amount = applyInterest(\\n                bond.amount,\\n                yA.accumulatorFP,\\n                yieldQuotientFP\\n            );\\n\\n            uint256 deltaAmount = bond.amount - oldAmount;\\n            lendingMeta[issuer].totalLending += deltaAmount;\\n        }\\n    }\\n\\n    // Retrieves bond balance for issuer and holder\\n    function viewHourlyBondAmount(address issuer, address holder)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        HourlyBond storage bond = hourlyBondAccounts[issuer][holder];\\n        uint256 yieldQuotientFP = bond.yieldQuotientFP;\\n\\n        uint256 cumulativeYield =\\n            viewCumulativeYieldFP(\\n                hourlyBondMetadata[issuer].yieldAccumulator,\\n                block.timestamp\\n            );\\n\\n        if (yieldQuotientFP > 0) {\\n            return\\n                bond.amount +\\n                applyInterest(bond.amount, cumulativeYield, yieldQuotientFP);\\n        }\\n        return bond.amount + 0;\\n    }\\n\\n    function _withdrawHourlyBond(\\n        address issuer,\\n        HourlyBond storage bond,\\n        uint256 amount\\n    ) internal {\\n        // how far the current hour has advanced (relative to acccount hourly clock)\\n        uint256 currentOffset = (block.timestamp - bond.moduloHour) % (1 hours);\\n\\n        require(\\n            withdrawalWindow >= currentOffset,\\n            \\\"Tried withdrawing outside subscription cancellation time window\\\"\\n        );\\n\\n        bond.amount -= amount;\\n        lendingMeta[issuer].totalLending -= amount;\\n\\n        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];\\n        (bondMeta.withdrawingSpeed, bondMeta.lastWithdrawn) = updateSpeed(\\n            bondMeta.withdrawingSpeed,\\n            bondMeta.lastWithdrawn,\\n            bond.amount,\\n            1 hours\\n        );\\n    }\\n\\n    function calcCumulativeYieldFP(\\n        YieldAccumulator storage yieldAccumulator,\\n        uint256 timeDelta\\n    ) internal view returns (uint256 accumulatorFP) {\\n        uint256 secondsDelta = timeDelta % (1 hours);\\n        // linearly interpolate interest for seconds\\n        // accumulator * hourly_yield == seconds_per_hour * accumulator * hourly_yield / seconds_per_hour\\n        // FP * FP * 1 / (FP * 1) = FP\\n        accumulatorFP =\\n            (yieldAccumulator.accumulatorFP *\\n                yieldAccumulator.hourlyYieldFP *\\n                secondsDelta) /\\n            (FP32 * 1 hours);\\n\\n        uint256 hoursDelta = timeDelta / (1 hours);\\n        if (hoursDelta > 0) {\\n            // This loop should hardly ever 1 or more unless something bad happened\\n            // In which case it costs gas but there isn't overflow\\n            for (uint256 i = 0; hoursDelta > i; i++) {\\n                // FP32 * FP32 / FP32 = FP32\\n                accumulatorFP =\\n                    (accumulatorFP * yieldAccumulator.hourlyYieldFP) /\\n                    FP32;\\n            }\\n        }\\n    }\\n\\n    /// @dev updates yield accumulators for both borrowing and lending\\n    function getUpdatedHourlyYield(\\n        address issuer,\\n        HourlyBondMetadata storage bondMeta\\n    ) internal returns (YieldAccumulator storage accumulator) {\\n        accumulator = bondMeta.yieldAccumulator;\\n        uint256 timeDelta = (block.timestamp - accumulator.lastUpdated);\\n\\n        accumulator.accumulatorFP = calcCumulativeYieldFP(\\n            accumulator,\\n            timeDelta\\n        );\\n\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        YieldAccumulator storage borrowAccumulator =\\n            borrowYieldAccumulators[issuer];\\n\\n        uint256 yieldGeneratedFP =\\n            (borrowAccumulator.hourlyYieldFP * meta.totalBorrowed) /\\n                (1 + meta.totalLending);\\n        uint256 _maxHourlyYieldFP = min(maxHourlyYieldFP, yieldGeneratedFP);\\n\\n        accumulator.hourlyYieldFP = updatedYieldFP(\\n            accumulator.hourlyYieldFP,\\n            accumulator.lastUpdated,\\n            meta.totalLending,\\n            lendingTarget(meta),\\n            bondMeta.buyingSpeed,\\n            bondMeta.withdrawingSpeed,\\n            _maxHourlyYieldFP\\n        );\\n\\n        timeDelta = block.timestamp - borrowAccumulator.lastUpdated;\\n        borrowAccumulator.accumulatorFP = calcCumulativeYieldFP(\\n            borrowAccumulator,\\n            timeDelta\\n        );\\n\\n        borrowAccumulator.hourlyYieldFP =\\n            1 +\\n            (borrowingFactorPercent * accumulator.hourlyYieldFP) /\\n            100;\\n\\n        accumulator.lastUpdated = block.timestamp;\\n        borrowAccumulator.lastUpdated = block.timestamp;\\n    }\\n\\n    function viewCumulativeYieldFP(\\n        YieldAccumulator storage yA,\\n        uint256 timestamp\\n    ) internal view returns (uint256) {\\n        uint256 timeDelta = (timestamp - yA.lastUpdated);\\n        return calcCumulativeYieldFP(yA, timeDelta);\\n    }\\n}\\n\",\"keccak256\":\"0x2652367528767f30f2f86ebfa6f117acdd2c7654be1151273d3db2552f596f19\",\"license\":\"BUSL-1.1\"},\"contracts/IncentiveDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./RoleAware.sol\\\";\\nimport \\\"./Fund.sol\\\";\\n\\nstruct Claim {\\n    uint256 startingRewardRateFP;\\n    uint256 amount;\\n    uint256 intraDayGain;\\n    uint256 intraDayLoss;\\n}\\n\\n/// @title Manage distribution of liquidity stake incentives\\n/// Some efforts have been made to reduce gas cost at claim time\\n/// and shift gas burden onto those who would want to withdraw\\ncontract IncentiveDistribution is RoleAware {\\n    // fixed point number factor\\n    uint256 internal constant FP32 = 2**32;\\n    // the amount of contraction per thousand, per day\\n    // of the overal daily incentive distribution\\n    // https://en.wikipedia.org/wiki/Per_mil\\n    uint256 public constant contractionPerMil = 999;\\n    address public immutable MFI;\\n\\n    constructor(\\n        address _MFI,\\n        uint256 startingDailyDistributionWithoutDecimals,\\n        address _roles\\n    ) RoleAware(_roles) {\\n        MFI = _MFI;\\n        currentDailyDistribution =\\n            startingDailyDistributionWithoutDecimals *\\n            (1 ether);\\n    }\\n\\n    // how much is going to be distributed, contracts every day\\n    uint256 public currentDailyDistribution;\\n\\n    uint256 public trancheShareTotal;\\n    uint256[] public allTranches;\\n\\n    struct TrancheMeta {\\n        // portion of daily distribution per each tranche\\n        uint256 rewardShare;\\n        uint256 currentDayGains;\\n        uint256 currentDayLosses;\\n        uint256 tomorrowOngoingTotals;\\n        uint256 yesterdayOngoingTotals;\\n        // aggregate all the unclaimed intra-days\\n        uint256 intraDayGains;\\n        uint256 intraDayLosses;\\n        uint256 intraDayRewardGains;\\n        uint256 intraDayRewardLosses;\\n        // how much each claim unit would get if they had staked from the dawn of time\\n        // expressed as fixed point number\\n        // claim amounts are expressed relative to this ongoing aggregate\\n        uint256 aggregateDailyRewardRateFP;\\n        uint256 yesterdayRewardRateFP;\\n        mapping(address => Claim) claims;\\n    }\\n\\n    mapping(uint256 => TrancheMeta) public trancheMetadata;\\n\\n    // last updated day\\n    uint256 public lastUpdatedDay;\\n\\n    mapping(address => uint256) public accruedReward;\\n\\n    /// Set share of tranche\\n    function setTrancheShare(uint256 tranche, uint256 share)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        require(\\n            trancheMetadata[tranche].rewardShare > 0,\\n            \\\"Tranche is not initialized, please initialize first\\\"\\n        );\\n        _setTrancheShare(tranche, share);\\n    }\\n\\n    function _setTrancheShare(uint256 tranche, uint256 share) internal {\\n        TrancheMeta storage tm = trancheMetadata[tranche];\\n\\n        if (share > tm.rewardShare) {\\n            trancheShareTotal += share - tm.rewardShare;\\n        } else {\\n            trancheShareTotal -= tm.rewardShare - share;\\n        }\\n        tm.rewardShare = share;\\n    }\\n\\n    /// Initialize tranche\\n    function initTranche(uint256 tranche, uint256 share) external onlyOwnerExecActivator {\\n        TrancheMeta storage tm = trancheMetadata[tranche];\\n        require(tm.rewardShare == 0, \\\"Tranche already initialized\\\");\\n        _setTrancheShare(tranche, share);\\n\\n        // simply initialize to 1.0\\n        tm.aggregateDailyRewardRateFP = FP32;\\n        allTranches.push(tranche);\\n    }\\n\\n    /// Start / increase amount of claim\\n    function addToClaimAmount(\\n        uint256 tranche,\\n        address recipient,\\n        uint256 claimAmount\\n    ) external {\\n        require(\\n            isIncentiveReporter(msg.sender),\\n            \\\"Contract not authorized to report incentives\\\"\\n        );\\n        if (currentDailyDistribution > 0) {\\n            TrancheMeta storage tm = trancheMetadata[tranche];\\n            Claim storage claim = tm.claims[recipient];\\n\\n            uint256 currentDay =\\n                claimAmount * (1 days - (block.timestamp % (1 days)));\\n\\n            tm.currentDayGains += currentDay;\\n            claim.intraDayGain += currentDay * currentDailyDistribution;\\n\\n            tm.tomorrowOngoingTotals += claimAmount * 1 days;\\n            updateAccruedReward(tm, recipient, claim);\\n\\n            claim.amount += claimAmount * (1 days);\\n        }\\n    }\\n\\n    /// Decrease amount of claim\\n    function subtractFromClaimAmount(\\n        uint256 tranche,\\n        address recipient,\\n        uint256 subtractAmount\\n    ) external {\\n        require(\\n            isIncentiveReporter(msg.sender),\\n            \\\"Contract not authorized to report incentives\\\"\\n        );\\n        uint256 currentDay = subtractAmount * (block.timestamp % (1 days));\\n\\n        TrancheMeta storage tm = trancheMetadata[tranche];\\n        Claim storage claim = tm.claims[recipient];\\n\\n        tm.currentDayLosses += currentDay;\\n        claim.intraDayLoss += currentDay * currentDailyDistribution;\\n\\n        tm.tomorrowOngoingTotals -= subtractAmount * 1 days;\\n\\n        updateAccruedReward(tm, recipient, claim);\\n        claim.amount -= subtractAmount * (1 days);\\n    }\\n\\n    function updateAccruedReward(\\n        TrancheMeta storage tm,\\n        address recipient,\\n        Claim storage claim\\n    ) internal returns (uint256 rewardDelta) {\\n        if (claim.startingRewardRateFP > 0) {\\n            rewardDelta = calcRewardAmount(tm, claim);\\n            accruedReward[recipient] += rewardDelta;\\n        }\\n        // don't reward for current day (approximately)\\n        claim.startingRewardRateFP =\\n            tm.yesterdayRewardRateFP +\\n            tm.aggregateDailyRewardRateFP;\\n    }\\n\\n    /// @dev additional reward accrued since last update\\n    function calcRewardAmount(TrancheMeta storage tm, Claim storage claim)\\n        internal\\n        view\\n        returns (uint256 rewardAmount)\\n    {\\n        uint256 ours = claim.startingRewardRateFP;\\n        uint256 aggregate = tm.aggregateDailyRewardRateFP;\\n        if (aggregate > ours) {\\n            rewardAmount = (claim.amount * (aggregate - ours)) / FP32;\\n        }\\n    }\\n\\n    function applyIntraDay(TrancheMeta storage tm, Claim storage claim)\\n        internal\\n        view\\n        returns (uint256 gainImpact, uint256 lossImpact)\\n    {\\n        uint256 gain = claim.intraDayGain;\\n        uint256 loss = claim.intraDayLoss;\\n\\n        if (gain + loss > 0) {\\n            gainImpact =\\n                (gain * tm.intraDayRewardGains) /\\n                (tm.intraDayGains + 1);\\n            lossImpact =\\n                (loss * tm.intraDayRewardLosses) /\\n                (tm.intraDayLosses + 1);\\n        }\\n    }\\n\\n    /// Get a view of reward amount\\n    function viewRewardAmount(uint256 tranche, address claimant)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        TrancheMeta storage tm = trancheMetadata[tranche];\\n        Claim storage claim = tm.claims[claimant];\\n\\n        uint256 rewardAmount =\\n            accruedReward[claimant] + calcRewardAmount(tm, claim);\\n        (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(tm, claim);\\n\\n        return rewardAmount + gainImpact - lossImpact;\\n    }\\n\\n    /// Withdraw current reward amount\\n    function withdrawReward(uint256[] calldata tranches)\\n        external\\n        returns (uint256 withdrawAmount)\\n    {\\n        require(\\n            isIncentiveReporter(msg.sender),\\n            \\\"Contract not authorized to report incentives\\\"\\n        );\\n\\n        updateDayTotals();\\n\\n        withdrawAmount = accruedReward[msg.sender];\\n        for (uint256 i; tranches.length > i; i++) {\\n            uint256 tranche = tranches[i];\\n\\n            TrancheMeta storage tm = trancheMetadata[tranche];\\n            Claim storage claim = tm.claims[msg.sender];\\n\\n            withdrawAmount += updateAccruedReward(tm, msg.sender, claim);\\n\\n            (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(tm, claim);\\n\\n            withdrawAmount = withdrawAmount + gainImpact - lossImpact;\\n\\n            tm.intraDayGains -= claim.intraDayGain;\\n            tm.intraDayLosses -= claim.intraDayLoss;\\n            tm.intraDayRewardGains -= gainImpact;\\n            tm.intraDayRewardLosses -= lossImpact;\\n\\n            claim.intraDayGain = 0;\\n        }\\n\\n        accruedReward[msg.sender] = 0;\\n\\n        Fund(fund()).withdraw(MFI, msg.sender, withdrawAmount);\\n    }\\n\\n    function updateDayTotals() internal {\\n        uint256 nowDay = block.timestamp / (1 days);\\n        uint256 dayDiff = nowDay - lastUpdatedDay;\\n\\n        // shrink the daily distribution for every day that has passed\\n        for (uint256 i = 0; i < dayDiff; i++) {\\n            _updateTrancheTotals();\\n\\n            currentDailyDistribution =\\n                (currentDailyDistribution * contractionPerMil) /\\n                1000;\\n\\n            lastUpdatedDay += 1;\\n        }\\n    }\\n\\n    function _updateTrancheTotals() internal {\\n        for (uint256 i; allTranches.length > i; i++) {\\n            uint256 tranche = allTranches[i];\\n            TrancheMeta storage tm = trancheMetadata[tranche];\\n\\n            uint256 todayTotal =\\n                tm.yesterdayOngoingTotals +\\n                    tm.currentDayGains -\\n                    tm.currentDayLosses;\\n\\n            uint256 todayRewardRateFP =\\n                (FP32 * (currentDailyDistribution * tm.rewardShare)) /\\n                    trancheShareTotal /\\n                    todayTotal;\\n\\n            tm.yesterdayRewardRateFP = todayRewardRateFP;\\n\\n            tm.aggregateDailyRewardRateFP += todayRewardRateFP;\\n\\n            tm.intraDayGains += tm.currentDayGains * currentDailyDistribution;\\n\\n            tm.intraDayLosses += tm.currentDayLosses * currentDailyDistribution;\\n\\n            tm.intraDayRewardGains +=\\n                (tm.currentDayGains * todayRewardRateFP) /\\n                FP32;\\n\\n            tm.intraDayRewardLosses +=\\n                (tm.currentDayLosses * todayRewardRateFP) /\\n                FP32;\\n\\n            tm.yesterdayOngoingTotals = tm.tomorrowOngoingTotals;\\n            tm.currentDayGains = 0;\\n            tm.currentDayLosses = 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x048cbccd9f32e7c9c76728d3fea561d04261529e75f6a8dfa8e5db6f33613956\",\"license\":\"BUSL-1.1\"},\"contracts/IncentivizedHolder.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IncentiveDistribution.sol\\\";\\nimport \\\"./RoleAware.sol\\\";\\n\\n/// @title helper class to facilitate staking and unstaking\\n/// within the incentive system.\\nabstract contract IncentivizedHolder is RoleAware {\\n    /// @dev here we cache incentive tranches to save on a bit of gas\\n    mapping(address => uint256) public incentiveTranches;\\n\\n    /// Set incentive tranche\\n    function setIncentiveTranche(address token, uint8 tranche)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        incentiveTranches[token] = tranche;\\n    }\\n\\n    function stakeClaim(\\n        address claimant,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        IncentiveDistribution iD =\\n            IncentiveDistribution(incentiveDistributor());\\n\\n        uint256 tranche = incentiveTranches[token];\\n\\n        iD.addToClaimAmount(tranche, claimant, amount);\\n    }\\n\\n    function withdrawClaim(\\n        address claimant,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        uint256 tranche = incentiveTranches[token];\\n\\n        IncentiveDistribution(incentiveDistributor()).subtractFromClaimAmount(\\n            tranche,\\n            claimant,\\n            amount\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x48565694d2ec02613f1268df73a9f42576c21a163aadfd75e67d0cc4952a240f\",\"license\":\"BUSL-1.1\"},\"contracts/Lending.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Fund.sol\\\";\\nimport \\\"./HourlyBondSubscriptionLending.sol\\\";\\nimport \\\"./BondLending.sol\\\";\\nimport \\\"./IncentivizedHolder.sol\\\";\\n\\n// TODO activate bonds for lending\\n\\n// TODO disburse token if isolated bond issuer\\n// and if isolated issuer, allow for haircuts\\n\\n/// @title Manage lending for a variety of bond issuers\\ncontract Lending is\\n    RoleAware,\\n    BaseLending,\\n    HourlyBondSubscriptionLending,\\n    BondLending,\\n    IncentivizedHolder\\n{\\n    /// @dev IDs for all bonds held by an address\\n    mapping(address => uint256[]) public bondIds;\\n\\n    /// mapping issuers to tokens\\n    /// (in crossmargin, the issuers are tokens  themselves)\\n    mapping(address => address) public issuerTokens;\\n\\n    /// In case of shortfall, adjust debt\\n    mapping(address => uint256) public haircuts;\\n\\n    /// map of available issuers\\n    mapping(address => bool) public activeIssuers;\\n\\n    constructor(address _roles) RoleAware(_roles) {\\n        uint256 APR = 899;\\n        maxHourlyYieldFP = (FP32 * APR) / 100 / (24 * 365);\\n\\n        uint256 aprChangePerMil = 3;\\n        yieldChangePerSecondFP = (FP32 * aprChangePerMil) / 1000;\\n    }\\n\\n    /// Make a issuer available for protocol\\n    function activateIssuer(address issuer) external {\\n        activateIssuer(issuer, issuer);\\n    }\\n\\n    /// Make issuer != token available for protocol (isol. margin)\\n    function activateIssuer(address issuer, address token)\\n        public\\n        onlyOwnerExecActivator\\n    {\\n        activeIssuers[issuer] = true;\\n        issuerTokens[issuer] = token;\\n    }\\n\\n    /// Remove a issuer from trading availability\\n    function deactivateIssuer(address issuer) external onlyOwnerExecActivator {\\n        activeIssuers[issuer] = false;\\n    }\\n\\n    /// Set lending cap\\n    function setLendingCap(address issuer, uint256 cap)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        lendingMeta[issuer].lendingCap = cap;\\n    }\\n\\n    /// Set lending buffer\\n    function setLendingBuffer(address issuer, uint256 buffer)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        lendingMeta[issuer].lendingBuffer = buffer;\\n    }\\n\\n    /// Set withdrawal window\\n    function setWithdrawalWindow(uint256 window) external onlyOwnerExec {\\n        withdrawalWindow = window;\\n    }\\n\\n    /// Set hourly yield APR for issuer\\n    function setHourlyYieldAPR(address issuer, uint256 aprPercent)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];\\n\\n        if (bondMeta.yieldAccumulator.accumulatorFP == 0) {\\n            bondMeta.yieldAccumulator = YieldAccumulator({\\n                accumulatorFP: FP32,\\n                lastUpdated: block.timestamp,\\n                hourlyYieldFP: (FP32 * (100 + aprPercent)) / 100 / (24 * 365)\\n            });\\n            bondMeta.buyingSpeed = 1;\\n            bondMeta.withdrawingSpeed = 1;\\n            bondMeta.lastBought = block.timestamp;\\n            bondMeta.lastWithdrawn = block.timestamp;\\n        } else {\\n            YieldAccumulator storage yA =\\n                getUpdatedHourlyYield(issuer, bondMeta);\\n            yA.hourlyYieldFP = (FP32 * (100 + aprPercent)) / 100 / (24 * 365);\\n        }\\n    }\\n\\n    /// Set maximum hourly yield in floating point\\n    function setMaxHourlyYieldFP(uint256 maxYieldFP) external onlyOwnerExec {\\n        maxHourlyYieldFP = maxYieldFP;\\n    }\\n\\n    /// Set yield change per second in floating point\\n    function setYieldChangePerSecondFP(uint256 changePerSecondFP)\\n        external\\n        onlyOwnerExec\\n    {\\n        yieldChangePerSecondFP = changePerSecondFP;\\n    }\\n\\n    /// Set runtime yields in floating point\\n    function setRuntimeYieldsFP(address issuer, uint256[] memory yieldsFP)\\n        external\\n        onlyOwnerExec\\n    {\\n        BondBucketMetadata[] storage bondMetas = bondBucketMetadata[issuer];\\n        for (uint256 i; bondMetas.length > i; i++) {\\n            bondMetas[i].runtimeYieldFP = yieldsFP[i];\\n        }\\n    }\\n\\n    /// Set miniumum runtime\\n    function setMinRuntime(uint256 runtime) external onlyOwnerExec {\\n        require(runtime > 1 hours, \\\"Min runtime needs to be at least 1 hour\\\");\\n        require(\\n            maxRuntime > runtime,\\n            \\\"Min runtime must be smaller than max runtime\\\"\\n        );\\n        minRuntime = runtime;\\n    }\\n\\n    /// Set maximum runtime\\n    function setMaxRuntime(uint256 runtime) external onlyOwnerExec {\\n        require(\\n            runtime > minRuntime,\\n            \\\"Max runtime must be greater than min runtime\\\"\\n        );\\n        maxRuntime = runtime;\\n    }\\n\\n    /// Set runtime weights in floating point\\n    function setRuntimeWeights(address issuer, uint256[] memory weights)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        BondBucketMetadata[] storage bondMetas = bondBucketMetadata[issuer];\\n\\n        if (bondMetas.length == 0) {\\n            // we are initializing\\n\\n            uint256 hourlyYieldFP = (110 * FP32) / 100 / (24 * 365);\\n            uint256 bucketSize = diffMaxMinRuntime / weights.length;\\n\\n            for (uint256 i; weights.length > i; i++) {\\n                uint256 runtime = minRuntime + bucketSize * i;\\n                bondMetas.push(\\n                    BondBucketMetadata({\\n                        runtimeYieldFP: (hourlyYieldFP * runtime) / (1 hours),\\n                        lastBought: block.timestamp,\\n                        lastWithdrawn: block.timestamp,\\n                        yieldLastUpdated: block.timestamp,\\n                        buyingSpeed: 1,\\n                        withdrawingSpeed: 1,\\n                        runtimeWeight: weights[i],\\n                        totalLending: 0\\n                    })\\n                );\\n            }\\n        } else {\\n            require(\\n                weights.length == bondMetas.length,\\n                \\\"Weights don't match buckets\\\"\\n            );\\n            for (uint256 i; weights.length > i; i++) {\\n                bondMetas[i].runtimeWeight = weights[i];\\n            }\\n        }\\n    }\\n\\n    /// @dev how much interest has accrued to a borrowed balance over time\\n    function applyBorrowInterest(\\n        uint256 balance,\\n        address issuer,\\n        uint256 yieldQuotientFP\\n    ) external returns (uint256 balanceWithInterest) {\\n        require(isBorrower(msg.sender), \\\"Not an approved borrower\\\");\\n\\n        YieldAccumulator storage yA = borrowYieldAccumulators[issuer];\\n        balanceWithInterest = applyInterest(\\n            balance,\\n            yA.accumulatorFP,\\n            yieldQuotientFP\\n        );\\n\\n        uint256 deltaAmount = balanceWithInterest - balance;\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        meta.totalBorrowed += deltaAmount;\\n    }\\n\\n    /// @dev view function to get current borrowing interest\\n    function viewBorrowInterest(\\n        uint256 balance,\\n        address issuer,\\n        uint256 yieldQuotientFP\\n    ) external view returns (uint256) {\\n        uint256 accumulatorFP =\\n            viewCumulativeYieldFP(\\n                borrowYieldAccumulators[issuer],\\n                block.timestamp\\n            );\\n        return applyInterest(balance, accumulatorFP, yieldQuotientFP);\\n    }\\n\\n    /// @dev gets called by router to register if a trader borrows issuers\\n    function registerBorrow(address issuer, uint256 amount) external {\\n        require(isBorrower(msg.sender), \\\"Not an approved borrower\\\");\\n        require(activeIssuers[issuer], \\\"Not an approved issuer\\\");\\n\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        meta.totalBorrowed += amount;\\n        require(\\n            meta.totalLending >= meta.totalBorrowed,\\n            \\\"Insufficient capital to lend, try again later!\\\"\\n        );\\n    }\\n\\n    /// @dev gets called by router if loan is extinguished\\n    function payOff(address issuer, uint256 amount) external {\\n        require(isBorrower(msg.sender), \\\"Not an approved borrower\\\");\\n        lendingMeta[issuer].totalBorrowed -= amount;\\n    }\\n\\n    /// @dev get the borrow yield\\n    function viewBorrowingYieldFP(address issuer)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            viewCumulativeYieldFP(\\n                borrowYieldAccumulators[issuer],\\n                block.timestamp\\n            );\\n    }\\n\\n    /// @dev In a liquidity crunch make a fallback bond until liquidity is good again\\n    function _makeFallbackBond(\\n        address issuer,\\n        address holder,\\n        uint256 amount\\n    ) internal override {\\n        _makeHourlyBond(issuer, holder, amount);\\n    }\\n\\n    /// @dev withdraw an hour bond\\n    function withdrawHourlyBond(address issuer, uint256 amount) external {\\n        HourlyBond storage bond = hourlyBondAccounts[issuer][msg.sender];\\n        // apply all interest\\n        updateHourlyBondAmount(issuer, bond);\\n        super._withdrawHourlyBond(issuer, bond, amount);\\n\\n        if (bond.amount == 0) {\\n            delete hourlyBondAccounts[issuer][msg.sender];\\n        }\\n\\n        disburse(issuer, msg.sender, amount);\\n\\n        withdrawClaim(msg.sender, issuer, amount);\\n    }\\n\\n    /// Shut down hourly bond account for `issuer`\\n    function closeHourlyBondAccount(address issuer) external {\\n        HourlyBond storage bond = hourlyBondAccounts[issuer][msg.sender];\\n        // apply all interest\\n        updateHourlyBondAmount(issuer, bond);\\n\\n        uint256 amount = bond.amount;\\n        super._withdrawHourlyBond(issuer, bond, amount);\\n\\n        disburse(issuer, msg.sender, amount);\\n\\n        delete hourlyBondAccounts[issuer][msg.sender];\\n\\n        withdrawClaim(msg.sender, issuer, amount);\\n    }\\n\\n    /// @dev buy hourly bond subscription\\n    function buyHourlyBondSubscription(address issuer, uint256 amount)\\n        external\\n    {\\n        require(activeIssuers[issuer], \\\"Not an approved issuer\\\");\\n\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        if (lendingTarget(meta) >= meta.totalLending + amount) {\\n            collectToken(issuer, msg.sender, amount);\\n\\n            super._makeHourlyBond(issuer, msg.sender, amount);\\n\\n            stakeClaim(msg.sender, issuer, amount);\\n        }\\n    }\\n\\n    /// @dev buy fixed term bond that does not renew\\n    function buyBond(\\n        address issuer,\\n        uint256 runtime,\\n        uint256 amount,\\n        uint256 minReturn\\n    ) external returns (uint256 bondIndex) {\\n        require(activeIssuers[issuer], \\\"Not an approved issuer\\\");\\n\\n        LendingMetadata storage meta = lendingMeta[issuer];\\n        if (\\n            lendingTarget(meta) >= meta.totalLending + amount &&\\n            maxRuntime >= runtime &&\\n            runtime >= minRuntime\\n        ) {\\n            bondIndex = super._makeBond(\\n                msg.sender,\\n                issuer,\\n                runtime,\\n                amount,\\n                minReturn\\n            );\\n            if (bondIndex > 0) {\\n                Fund(fund()).depositFor(msg.sender, issuer, amount);\\n                bondIds[msg.sender].push(bondIndex);\\n\\n                collectToken(issuer, msg.sender, amount);\\n                stakeClaim(msg.sender, issuer, amount);\\n            }\\n        }\\n    }\\n\\n    /// @dev send back funds of bond after maturity\\n    function withdrawBond(uint256 bondId) external {\\n        Bond storage bond = bonds[bondId];\\n        require(msg.sender == bond.holder, \\\"Not holder of bond\\\");\\n        require(\\n            block.timestamp > bond.maturityTimestamp,\\n            \\\"bond is still immature\\\"\\n        );\\n        // in case of a shortfall, governance can step in to provide\\n        // additonal compensation beyond the usual incentive which\\n        // gets withdrawn here\\n        withdrawClaim(msg.sender, bond.issuer, bond.originalPrice);\\n\\n        uint256 withdrawAmount = super._withdrawBond(bondId, bond);\\n        disburse(bond.issuer, msg.sender, withdrawAmount);\\n    }\\n\\n    function initBorrowYieldAccumulator(address issuer)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        require(\\n            borrowYieldAccumulators[issuer].accumulatorFP == 0,\\n            \\\"trying to re-initialize yield accumulator\\\"\\n        );\\n\\n        borrowYieldAccumulators[issuer].accumulatorFP = FP32;\\n    }\\n\\n    function setBorrowingFactorPercent(uint256 borrowingFactor)\\n        external\\n        onlyOwnerExec\\n    {\\n        borrowingFactorPercent = borrowingFactor;\\n    }\\n\\n    function issuanceBalance(address issuer)\\n        internal\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        address token = issuerTokens[issuer];\\n        if (token == issuer) {\\n            // cross margin\\n            return IERC20(token).balanceOf(fund());\\n        } else {\\n            return lendingMeta[issuer].totalLending - haircuts[issuer];\\n        }\\n    }\\n\\n    function disburse(\\n        address issuer,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        uint256 haircutAmount = haircuts[issuer];\\n        if (haircutAmount > 0 && amount > 0) {\\n            uint256 totalLending = lendingMeta[issuer].totalLending;\\n            uint256 adjustment =\\n                (amount * min(totalLending, haircutAmount)) / totalLending;\\n            amount = amount - adjustment;\\n            haircuts[issuer] -= adjustment;\\n        }\\n\\n        address token = issuerTokens[issuer];\\n        Fund(fund()).withdraw(token, recipient, amount);\\n    }\\n\\n    function collectToken(\\n        address issuer,\\n        address source,\\n        uint256 amount\\n    ) internal {\\n        Fund(fund()).depositFor(source, issuer, amount);\\n    }\\n\\n    function haircut(uint256 amount) external {\\n        haircuts[msg.sender] += amount;\\n    }\\n}\\n\",\"keccak256\":\"0xf2fef7022574e3302bbb5a8cac21d1016ebf8b4ea45a0dd6e23e70617361c89e\",\"license\":\"BUSL-1.1\"},\"contracts/MarginRouter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"../libraries/UniswapStyleLib.sol\\\";\\n\\nimport \\\"./RoleAware.sol\\\";\\nimport \\\"./Fund.sol\\\";\\nimport \\\"../interfaces/IMarginTrading.sol\\\";\\nimport \\\"./Lending.sol\\\";\\nimport \\\"./Admin.sol\\\";\\nimport \\\"./IncentivizedHolder.sol\\\";\\n\\n/// @title Top level transaction controller\\ncontract MarginRouter is RoleAware, IncentivizedHolder {\\n    /// @notice wrapped ETH ERC20 contract\\n    address public immutable WETH;\\n    uint256 public constant mswapFeesPer10k = 10;\\n\\n    /// emitted when a trader depoits on cross margin\\n    event CrossDeposit(\\n        address trader,\\n        address depositToken,\\n        uint256 depositAmount\\n    );\\n    /// emitted whenever a trade happens\\n    event CrossTrade(\\n        address trader,\\n        address inToken,\\n        uint256 inTokenAmount,\\n        uint256 inTokenBorrow,\\n        address outToken,\\n        uint256 outTokenAmount,\\n        uint256 outTokenExtinguish\\n    );\\n    /// emitted when a trader withdraws funds\\n    event CrossWithdraw(\\n        address trader,\\n        address withdrawToken,\\n        uint256 withdrawAmount\\n    );\\n    /// emitted upon sucessfully borrowing\\n    event CrossBorrow(\\n        address trader,\\n        address borrowToken,\\n        uint256 borrowAmount\\n    );\\n\\n    /// emmited on deposit-borrow-withdraw\\n    event CrossOvercollateralizedBorrow(\\n        address trader,\\n        address depositToken,\\n        uint256 depositAmount,\\n        address borrowToken,\\n        uint256 withdrawAmount\\n    );\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, \\\"Trade has expired\\\");\\n        _;\\n    }\\n\\n    constructor(address _WETH, address _roles) RoleAware(_roles) {\\n        WETH = _WETH;\\n    }\\n\\n    /// @notice traders call this to deposit funds on cross margin\\n    function crossDeposit(address depositToken, uint256 depositAmount)\\n        external\\n    {\\n        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);\\n\\n        uint256 extinguishAmount =\\n            IMarginTrading(marginTrading()).registerDeposit(\\n                msg.sender,\\n                depositToken,\\n                depositAmount\\n            );\\n        if (extinguishAmount > 0) {\\n            Lending(lending()).payOff(depositToken, extinguishAmount);\\n            withdrawClaim(msg.sender, depositToken, extinguishAmount);\\n        }\\n        emit CrossDeposit(msg.sender, depositToken, depositAmount);\\n    }\\n\\n    /// @notice deposit wrapped ehtereum into cross margin account\\n    function crossDepositETH() external payable {\\n        Fund(fund()).depositToWETH{value: msg.value}();\\n        uint256 extinguishAmount =\\n            IMarginTrading(marginTrading()).registerDeposit(\\n                msg.sender,\\n                WETH,\\n                msg.value\\n            );\\n        if (extinguishAmount > 0) {\\n            Lending(lending()).payOff(WETH, extinguishAmount);\\n            withdrawClaim(msg.sender, WETH, extinguishAmount);\\n        }\\n        emit CrossDeposit(msg.sender, WETH, msg.value);\\n    }\\n\\n    /// @notice withdraw deposits/earnings from cross margin account\\n    function crossWithdraw(address withdrawToken, uint256 withdrawAmount)\\n        external\\n    {\\n        IMarginTrading(marginTrading()).registerWithdrawal(\\n            msg.sender,\\n            withdrawToken,\\n            withdrawAmount\\n        );\\n        Fund(fund()).withdraw(withdrawToken, msg.sender, withdrawAmount);\\n        emit CrossWithdraw(msg.sender, withdrawToken, withdrawAmount);\\n    }\\n\\n    /// @notice withdraw ethereum from cross margin account\\n    function crossWithdrawETH(uint256 withdrawAmount) external {\\n        IMarginTrading(marginTrading()).registerWithdrawal(\\n            msg.sender,\\n            WETH,\\n            withdrawAmount\\n        );\\n        Fund(fund()).withdrawETH(msg.sender, withdrawAmount);\\n    }\\n\\n    /// @notice borrow into cross margin trading account\\n    function crossBorrow(address borrowToken, uint256 borrowAmount) external {\\n        Lending(lending()).registerBorrow(borrowToken, borrowAmount);\\n        IMarginTrading(marginTrading()).registerBorrow(\\n            msg.sender,\\n            borrowToken,\\n            borrowAmount\\n        );\\n\\n        stakeClaim(msg.sender, borrowToken, borrowAmount);\\n        emit CrossBorrow(msg.sender, borrowToken, borrowAmount);\\n    }\\n\\n    /// @notice convenience function to perform overcollateralized borrowing\\n    /// against a cross margin account.\\n    /// @dev caution: the account still has to have a positive balaance at the end\\n    /// of the withdraw. So an underwater account may not be able to withdraw\\n    function crossOvercollateralizedBorrow(\\n        address depositToken,\\n        uint256 depositAmount,\\n        address borrowToken,\\n        uint256 withdrawAmount\\n    ) external {\\n        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);\\n\\n        Lending(lending()).registerBorrow(borrowToken, withdrawAmount);\\n        IMarginTrading(marginTrading()).registerOvercollateralizedBorrow(\\n            msg.sender,\\n            depositToken,\\n            depositAmount,\\n            borrowToken,\\n            withdrawAmount\\n        );\\n\\n        Fund(fund()).withdraw(borrowToken, msg.sender, withdrawAmount);\\n        stakeClaim(msg.sender, borrowToken, withdrawAmount);\\n        emit CrossOvercollateralizedBorrow(\\n            msg.sender,\\n            depositToken,\\n            depositAmount,\\n            borrowToken,\\n            withdrawAmount\\n        );\\n    }\\n\\n    /// @notice close an account that is no longer borrowing and return gains\\n    function crossCloseAccount() external {\\n        (address[] memory holdingTokens, uint256[] memory holdingAmounts) =\\n            IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);\\n\\n        // requires all debts paid off\\n        IMarginTrading(marginTrading()).registerLiquidation(msg.sender);\\n\\n        for (uint256 i; holdingTokens.length > i; i++) {\\n            Fund(fund()).withdraw(\\n                holdingTokens[i],\\n                msg.sender,\\n                holdingAmounts[i]\\n            );\\n        }\\n    }\\n\\n    // **** SWAP ****\\n    /// @dev requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory pairs,\\n        address[] memory tokens,\\n        address _to\\n    ) internal virtual {\\n        address outToken = tokens[tokens.length - 1];\\n        uint256 startingBalance = IERC20(outToken).balanceOf(_to);\\n        for (uint256 i; i < pairs.length; i++) {\\n            (address input, address output) = (tokens[i], tokens[i + 1]);\\n            (address token0, ) = UniswapStyleLib.sortTokens(input, output);\\n\\n            uint256 amountOut = amounts[i + 1];\\n\\n            (uint256 amount0Out, uint256 amount1Out) =\\n                input == token0\\n                    ? (uint256(0), amountOut)\\n                    : (amountOut, uint256(0));\\n\\n            address to = i < pairs.length - 1 ? pairs[i + 1] : _to;\\n            IUniswapV2Pair pair = IUniswapV2Pair(pairs[i]);\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n        }\\n\\n        uint256 endingBalance = IERC20(outToken).balanceOf(_to);\\n        require(\\n            endingBalance >= startingBalance + amounts[amounts.length - 1],\\n            \\\"Defective AMM route; balances don't match\\\"\\n        );\\n    }\\n\\n    /// @dev internal helper swapping exact token for token on AMM\\n    function _swapExactT4T(\\n        uint256[] memory amounts,\\n        uint256 amountOutMin,\\n        address[] calldata pairs,\\n        address[] calldata tokens\\n    ) internal {\\n        require(\\n            amounts[amounts.length - 1] >= amountOutMin,\\n            \\\"MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\\n        _swap(amounts, pairs, tokens, fund());\\n    }\\n\\n    /// @notice make swaps on AMM using protocol funds, only for authorized contracts\\n    function authorizedSwapExactT4T(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata pairs,\\n        address[] calldata tokens\\n    ) external returns (uint256[] memory amounts) {\\n        require(\\n            isAuthorizedFundTrader(msg.sender),\\n            \\\"Calling contract is not authorized to trade with protocl funds\\\"\\n        );\\n        amounts = UniswapStyleLib.getAmountsOut(amountIn, pairs, tokens);\\n        _swapExactT4T(amounts, amountOutMin, pairs, tokens);\\n    }\\n\\n    // @dev internal helper swapping exact token for token on on AMM\\n    function _swapT4ExactT(\\n        uint256[] memory amounts,\\n        uint256 amountInMax,\\n        address[] calldata pairs,\\n        address[] calldata tokens\\n    ) internal {\\n        // TODO minimum trade?\\n        require(\\n            amounts[0] <= amountInMax,\\n            \\\"MarginRouter: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\\n        _swap(amounts, pairs, tokens, fund());\\n    }\\n\\n    //// @notice swap protocol funds on AMM, only for authorized\\n    function authorizedSwapT4ExactT(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata pairs,\\n        address[] calldata tokens\\n    ) external returns (uint256[] memory amounts) {\\n        require(\\n            isAuthorizedFundTrader(msg.sender),\\n            \\\"Calling contract is not authorized to trade with protocl funds\\\"\\n        );\\n        amounts = UniswapStyleLib.getAmountsIn(amountOut, pairs, tokens);\\n        _swapT4ExactT(amounts, amountInMax, pairs, tokens);\\n    }\\n\\n    /// @notice entry point for swapping tokens held in cross margin account\\n    function crossSwapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata pairs,\\n        address[] calldata tokens,\\n        uint256 deadline\\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\\n        // calc fees\\n        uint256 fees = takeFeesFromInput(amountIn);\\n\\n        // swap\\n        amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);\\n\\n        // checks that trader is within allowed lending bounds\\n        registerTrade(\\n            msg.sender,\\n            tokens[0],\\n            tokens[tokens.length - 1],\\n            amountIn,\\n            amounts[amounts.length - 1]\\n        );\\n\\n        _swapExactT4T(amounts, amountOutMin, pairs, tokens);\\n    }\\n\\n    /// @notice entry point for swapping tokens held in cross margin account\\n    function crossSwapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata pairs,\\n        address[] calldata tokens,\\n        uint256 deadline\\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\\n        // swap\\n        amounts = UniswapStyleLib.getAmountsIn(\\n            amountOut + takeFeesFromOutput(amountOut),\\n            pairs,\\n            tokens\\n        );\\n\\n        // checks that trader is within allowed lending bounds\\n        registerTrade(\\n            msg.sender,\\n            tokens[0],\\n            tokens[tokens.length - 1],\\n            amounts[0],\\n            amountOut\\n        );\\n\\n        _swapT4ExactT(amounts, amountInMax, pairs, tokens);\\n    }\\n\\n    /// @dev helper function does all the work of telling other contracts\\n    /// about a trade\\n    function registerTrade(\\n        address trader,\\n        address inToken,\\n        address outToken,\\n        uint256 inAmount,\\n        uint256 outAmount\\n    ) internal {\\n        (uint256 extinguishAmount, uint256 borrowAmount) =\\n            IMarginTrading(marginTrading()).registerTradeAndBorrow(\\n                trader,\\n                inToken,\\n                outToken,\\n                inAmount,\\n                outAmount\\n            );\\n        if (extinguishAmount > 0) {\\n            Lending(lending()).payOff(outToken, extinguishAmount);\\n            withdrawClaim(trader, outToken, extinguishAmount);\\n        }\\n        if (borrowAmount > 0) {\\n            Lending(lending()).registerBorrow(inToken, borrowAmount);\\n            stakeClaim(trader, inToken, borrowAmount);\\n        }\\n\\n        emit CrossTrade(\\n            trader,\\n            inToken,\\n            inAmount,\\n            borrowAmount,\\n            outToken,\\n            outAmount,\\n            extinguishAmount\\n        );\\n    }\\n\\n    function getAmountsOut(\\n        uint256 inAmount,\\n        address[] calldata pairs,\\n        address[] calldata tokens\\n    ) external view returns (uint256[] memory) {\\n        return UniswapStyleLib.getAmountsOut(inAmount, pairs, tokens);\\n    }\\n\\n    function getAmountsIn(\\n        uint256 outAmount,\\n        address[] calldata pairs,\\n        address[] calldata tokens\\n    ) external view returns (uint256[] memory) {\\n        return UniswapStyleLib.getAmountsIn(outAmount, pairs, tokens);\\n    }\\n\\n    function takeFeesFromOutput(uint256 amount)\\n        internal\\n        pure\\n        returns (uint256 fees)\\n    {\\n        fees = (mswapFeesPer10k * amount) / 10_000;\\n    }\\n\\n    function takeFeesFromInput(uint256 amount)\\n        internal\\n        pure\\n        returns (uint256 fees)\\n    {\\n        fees = (mswapFeesPer10k * amount) / (10_000 + mswapFeesPer10k);\\n    }\\n}\\n\",\"keccak256\":\"0x61b84d6fc3ced3b5208ca888b9719a7cedb00a2732d954bd638447dcc9191f92\",\"license\":\"BUSL-1.1\"},\"contracts/PriceAware.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RoleAware.sol\\\";\\nimport \\\"./MarginRouter.sol\\\";\\nimport \\\"../libraries/UniswapStyleLib.sol\\\";\\n\\n/// Stores how many of token you could get for 1k of peg\\nstruct TokenPrice {\\n    uint256 blockLastUpdated;\\n    uint256 tokenPer1k;\\n    address[] liquidationPairs;\\n    address[] inverseLiquidationPairs;\\n    address[] liquidationTokens;\\n    address[] inverseLiquidationTokens;\\n}\\n\\n/// @title The protocol features several mechanisms to prevent vulnerability to\\n/// price manipulation:\\n/// 1) global exposure caps on all tokens which need to be raised gradually\\n///    during the process of introducing a new token, making attacks unprofitable\\n///    due to lack  of scale\\n/// 2) Exponential moving average with cautious price update. Prices for estimating\\n///    how much a trader can borrow need not be extremely current and precise, mainly\\n///    they must be resilient against extreme manipulation\\n/// 3) Liquidators may not call from a contract address, to prevent extreme forms of\\n///    of front-running and other price manipulation.\\nabstract contract PriceAware is RoleAware {\\n    address public immutable peg;\\n    mapping(address => TokenPrice) public tokenPrices;\\n    /// update window in blocks\\n    uint16 public priceUpdateWindow = 8;\\n    uint256 public UPDATE_RATE_PERMIL = 80;\\n    uint256 public UPDATE_MAX_PEG_AMOUNT = 50_000;\\n    uint256 public UPDATE_MIN_PEG_AMOUNT = 1_000;\\n\\n    constructor(address _peg) {\\n        peg = _peg;\\n    }\\n\\n    /// Set window for price updates\\n    function setPriceUpdateWindow(uint16 window) external onlyOwnerExec {\\n        priceUpdateWindow = window;\\n    }\\n\\n    /// Set rate for updates\\n    function setUpdateRate(uint256 rate) external onlyOwnerExec {\\n        UPDATE_RATE_PERMIL = rate;\\n    }\\n\\n    function setUpdateMaxPegAmount(uint256 amount) external onlyOwnerExec {\\n        UPDATE_MAX_PEG_AMOUNT = amount;\\n    }\\n\\n    function setUpdateMinPegAmount(uint256 amount) external onlyOwnerExec {\\n        UPDATE_MIN_PEG_AMOUNT = amount;\\n    }\\n\\n    /// Get current price of token in peg\\n    function getCurrentPriceInPeg(\\n        address token,\\n        uint256 inAmount,\\n        bool forceCurBlock\\n    ) public returns (uint256) {\\n        TokenPrice storage tokenPrice = tokenPrices[token];\\n        if (forceCurBlock) {\\n            if (\\n                block.number - tokenPrice.blockLastUpdated > priceUpdateWindow\\n            ) {\\n                // update the currently cached price\\n                return getPriceFromAMM(token, inAmount);\\n            } else {\\n                // just get the current price from AMM\\n                return viewCurrentPriceInPeg(token, inAmount);\\n            }\\n        } else if (tokenPrice.tokenPer1k == 0) {\\n            // do the best we can if it's at zero\\n            return getPriceFromAMM(token, inAmount);\\n        }\\n\\n        if (block.number - tokenPrice.blockLastUpdated > priceUpdateWindow) {\\n            // update the price somewhat\\n            getPriceFromAMM(token, inAmount);\\n        }\\n\\n        return (inAmount * 1000 ether) / tokenPrice.tokenPer1k;\\n    }\\n\\n    /// Get view of current price of token in peg\\n    function viewCurrentPriceInPeg(address token, uint256 inAmount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (token == peg) {\\n            return inAmount;\\n        } else {\\n            TokenPrice storage tokenPrice = tokenPrices[token];\\n            uint256[] memory pathAmounts =\\n                UniswapStyleLib.getAmountsOut(\\n                    inAmount,\\n                    tokenPrice.liquidationPairs,\\n                    tokenPrice.liquidationTokens\\n                );\\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\\n            return outAmount;\\n        }\\n    }\\n\\n    /// @dev retrieves the price from the AMM\\n    function getPriceFromAMM(address token, uint256 inAmount)\\n        internal\\n        virtual\\n        returns (uint256)\\n    {\\n        if (token == peg) {\\n            return inAmount;\\n        } else {\\n            TokenPrice storage tokenPrice = tokenPrices[token];\\n            uint256[] memory pathAmounts =\\n                UniswapStyleLib.getAmountsOut(\\n                    inAmount,\\n                    tokenPrice.liquidationPairs,\\n                    tokenPrice.liquidationTokens\\n                );\\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\\n\\n            if (\\n                outAmount > UPDATE_MIN_PEG_AMOUNT &&\\n                outAmount < UPDATE_MAX_PEG_AMOUNT\\n            ) {\\n                setPriceVal(tokenPrice, inAmount, outAmount);\\n            }\\n\\n            return outAmount;\\n        }\\n    }\\n\\n    function setPriceVal(\\n        TokenPrice storage tokenPrice,\\n        uint256 inAmount,\\n        uint256 outAmount\\n    ) internal {\\n        _setPriceVal(tokenPrice, inAmount, outAmount, UPDATE_RATE_PERMIL);\\n        tokenPrice.blockLastUpdated = block.number;\\n    }\\n\\n    function _setPriceVal(\\n        TokenPrice storage tokenPrice,\\n        uint256 inAmount,\\n        uint256 outAmount,\\n        uint256 weightPerMil\\n    ) internal {\\n        uint256 updatePer1k = (1000 ether * inAmount) / (outAmount + 1);\\n        tokenPrice.tokenPer1k =\\n            (tokenPrice.tokenPer1k *\\n                (1000 - weightPerMil) +\\n                updatePer1k *\\n                weightPerMil) /\\n            1000;\\n    }\\n\\n    /// add path from token to current liquidation peg\\n    function setLiquidationPath(address[] memory path, address[] memory tokens)\\n        external\\n        onlyOwnerExecActivator\\n    {\\n        address token = tokens[0];\\n\\n        TokenPrice storage tokenPrice = tokenPrices[token];\\n        tokenPrice.liquidationPairs = new address[](path.length);\\n        tokenPrice.inverseLiquidationPairs = new address[](path.length);\\n        tokenPrice.liquidationTokens = new address[](tokens.length);\\n        tokenPrice.inverseLiquidationTokens = new address[](tokens.length);\\n\\n        for (uint256 i = 0; path.length > i; i++) {\\n            tokenPrice.liquidationPairs[i] = path[i];\\n            tokenPrice.inverseLiquidationPairs[i] = path[path.length - i - 1];\\n        }\\n\\n        for (uint256 i = 0; tokens.length > i; i++) {\\n            tokenPrice.liquidationTokens[i] = tokens[i];\\n            tokenPrice.inverseLiquidationTokens[i] = tokens[\\n                tokens.length - i - 1\\n            ];\\n        }\\n\\n        uint256[] memory pathAmounts =\\n            UniswapStyleLib.getAmountsIn(1000 ether, path, tokens);\\n        uint256 inAmount = pathAmounts[0];\\n        _setPriceVal(tokenPrice, inAmount, 1000 ether, 1000);\\n    }\\n\\n    function liquidateToPeg(address token, uint256 amount)\\n        internal\\n        returns (uint256)\\n    {\\n        if (token == peg) {\\n            return amount;\\n        } else {\\n            TokenPrice storage tP = tokenPrices[token];\\n            uint256[] memory amounts =\\n                MarginRouter(router()).authorizedSwapExactT4T(\\n                    amount,\\n                    0,\\n                    tP.liquidationPairs,\\n                    tP.liquidationTokens\\n                );\\n\\n            uint256 outAmount = amounts[amounts.length - 1];\\n\\n            return outAmount;\\n        }\\n    }\\n\\n    function liquidateFromPeg(address token, uint256 targetAmount)\\n        internal\\n        returns (uint256)\\n    {\\n        if (token == peg) {\\n            return targetAmount;\\n        } else {\\n            TokenPrice storage tP = tokenPrices[token];\\n            uint256[] memory amounts =\\n                MarginRouter(router()).authorizedSwapT4ExactT(\\n                    targetAmount,\\n                    type(uint256).max,\\n                    tP.inverseLiquidationPairs,\\n                    tP.inverseLiquidationTokens\\n                );\\n\\n            return amounts[0];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc0ccbbf7bd2c32500a6383883682811d56c430118d51b498f7a3629a38544061\",\"license\":\"BUSL-1.1\"},\"contracts/RoleAware.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\n/// @title Role management behavior\\n/// Main characters are for service discovery\\n/// Whereas roles are for access control\\ncontract RoleAware {\\n    Roles public immutable roles;\\n    mapping(uint256 => address) public mainCharacterCache;\\n    mapping(address => mapping(uint256 => bool)) public roleCache;\\n\\n    constructor(address _roles) {\\n        require(_roles != address(0), \\\"Please provide valid roles address\\\");\\n        roles = Roles(_roles);\\n    }\\n\\n    modifier noIntermediary() {\\n        require(\\n            msg.sender == tx.origin,\\n            \\\"Currently no intermediaries allowed for this function call\\\"\\n        );\\n        _;\\n    }\\n\\n    // @dev Throws if called by any account other than the owner or executor\\n    modifier onlyOwnerExec() {\\n        require(\\n            owner() == msg.sender || executor() == msg.sender,\\n            \\\"Roles: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwnerExecDisabler() {\\n        require(\\n            owner() == msg.sender ||\\n                executor() == msg.sender ||\\n                disabler() == msg.sender,\\n            \\\"Caller is not the owner, executor or authorized disabler\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwnerExecActivator() {\\n        require(\\n            owner() == msg.sender ||\\n                executor() == msg.sender ||\\n                isTokenActivator(msg.sender),\\n            \\\"Caller is not the owner, executor or authorized activator\\\"\\n        );\\n        _;\\n    }\\n\\n    function updateRoleCache(uint256 role, address contr) public virtual {\\n        roleCache[contr][role] = roles.getRole(role, contr);\\n    }\\n\\n    function updateMainCharacterCache(uint256 role) public virtual {\\n        mainCharacterCache[role] = roles.mainCharacters(role);\\n    }\\n\\n    function owner() internal view returns (address) {\\n        return roles.owner();\\n    }\\n\\n    function executor() internal returns (address) {\\n        return roles.executor();\\n    }\\n\\n    function disabler() internal view returns (address) {\\n        return mainCharacterCache[DISABLER];\\n    }\\n\\n    function fund() internal view returns (address) {\\n        return mainCharacterCache[FUND];\\n    }\\n\\n    function lending() internal view returns (address) {\\n        return mainCharacterCache[LENDING];\\n    }\\n\\n    function router() internal view returns (address) {\\n        return mainCharacterCache[ROUTER];\\n    }\\n\\n    function marginTrading() internal view returns (address) {\\n        return mainCharacterCache[MARGIN_TRADING];\\n    }\\n\\n    function feeController() internal view returns (address) {\\n        return mainCharacterCache[FEE_CONTROLLER];\\n    }\\n\\n    function price() internal view returns (address) {\\n        return mainCharacterCache[PRICE_CONTROLLER];\\n    }\\n\\n    function admin() internal view returns (address) {\\n        return mainCharacterCache[ADMIN];\\n    }\\n\\n    function incentiveDistributor() internal view returns (address) {\\n        return mainCharacterCache[INCENTIVE_DISTRIBUTION];\\n    }\\n\\n    function tokenAdmin() internal view returns (address) {\\n        return mainCharacterCache[TOKEN_ADMIN];\\n    }\\n\\n    function isBorrower(address contr) internal view returns (bool) {\\n        return roleCache[contr][BORROWER];\\n    }\\n\\n    function isFundTransferer(address contr) internal view returns (bool) {\\n        return roleCache[contr][FUND_TRANSFERER];\\n    }\\n\\n    function isMarginTrader(address contr) internal view returns (bool) {\\n        return roleCache[contr][MARGIN_TRADER];\\n    }\\n\\n    function isFeeSource(address contr) internal view returns (bool) {\\n        return roleCache[contr][FEE_SOURCE];\\n    }\\n\\n    function isMarginCaller(address contr) internal view returns (bool) {\\n        return roleCache[contr][MARGIN_CALLER];\\n    }\\n\\n    function isLiquidator(address contr) internal view returns (bool) {\\n        return roleCache[contr][LIQUIDATOR];\\n    }\\n\\n    function isAuthorizedFundTrader(address contr)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return roleCache[contr][AUTHORIZED_FUND_TRADER];\\n    }\\n\\n    function isIncentiveReporter(address contr) internal view returns (bool) {\\n        return roleCache[contr][INCENTIVE_REPORTER];\\n    }\\n\\n    function isTokenActivator(address contr) internal view returns (bool) {\\n        return roleCache[contr][TOKEN_ACTIVATOR];\\n    }\\n\\n    function isStakePenalizer(address contr) internal view returns (bool) {\\n        return roles.getRole(STAKE_PENALIZER, contr);\\n    }\\n}\\n\",\"keccak256\":\"0xbec30bf7e21852f2d60e7175c676fded93b67ca9f8347a0dbd437c07fbb5aa56\",\"license\":\"BUSL-1.1\"},\"contracts/Roles.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IDependencyController.sol\\\";\\n\\n// we chose not to go with an enum\\n// to make this list easy to extend\\nuint256 constant FUND_TRANSFERER = 1;\\nuint256 constant MARGIN_CALLER = 2;\\nuint256 constant BORROWER = 3;\\nuint256 constant MARGIN_TRADER = 4;\\nuint256 constant FEE_SOURCE = 5;\\nuint256 constant LIQUIDATOR = 6;\\nuint256 constant AUTHORIZED_FUND_TRADER = 7;\\nuint256 constant INCENTIVE_REPORTER = 8;\\nuint256 constant TOKEN_ACTIVATOR = 9;\\nuint256 constant STAKE_PENALIZER = 10;\\n\\nuint256 constant FUND = 101;\\nuint256 constant LENDING = 102;\\nuint256 constant ROUTER = 103;\\nuint256 constant MARGIN_TRADING = 104;\\nuint256 constant FEE_CONTROLLER = 105;\\nuint256 constant PRICE_CONTROLLER = 106;\\nuint256 constant ADMIN = 107;\\nuint256 constant INCENTIVE_DISTRIBUTION = 108;\\nuint256 constant TOKEN_ADMIN = 109;\\n\\nuint256 constant DISABLER = 1001;\\nuint256 constant DEPENDENCY_CONTROLLER = 1002;\\n\\n/// @title Manage permissions of contracts and ownership of everything\\n/// owned by a multisig wallet (0xEED9D1c6B4cdEcB3af070D85bfd394E7aF179CBd) during\\n/// beta and will then be transfered to governance\\n/// https://github.com/marginswap/governance\\ncontract Roles is Ownable {\\n    mapping(address => mapping(uint256 => bool)) public roles;\\n    mapping(uint256 => address) public mainCharacters;\\n\\n    constructor() Ownable() {\\n        // token activation from the get-go\\n        roles[msg.sender][TOKEN_ACTIVATOR] = true;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwnerExecDepController() {\\n        require(\\n            owner() == msg.sender ||\\n                executor() == msg.sender ||\\n                mainCharacters[DEPENDENCY_CONTROLLER] == msg.sender,\\n            \\\"Roles: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n    function giveRole(uint256 role, address actor)\\n        external\\n        onlyOwnerExecDepController\\n    {\\n        roles[actor][role] = true;\\n    }\\n\\n    function removeRole(uint256 role, address actor)\\n        external\\n        onlyOwnerExecDepController\\n    {\\n        roles[actor][role] = false;\\n    }\\n\\n    function setMainCharacter(uint256 role, address actor)\\n        external\\n        onlyOwnerExecDepController\\n    {\\n        mainCharacters[role] = actor;\\n    }\\n\\n    function getRole(uint256 role, address contr) external view returns (bool) {\\n        return roles[contr][role];\\n    }\\n\\n    /// @dev current executor\\n    function executor() public returns (address exec) {\\n        address depController = mainCharacters[DEPENDENCY_CONTROLLER];\\n        if (depController != address(0)) {\\n            exec = IDependencyController(depController).currentExecutor();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa97fcedfdf7d432ed60b49d499292200056d588200784aa412ca424c9213c55f\",\"license\":\"BUSL-1.1\"},\"interfaces/IDependencyController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IDependencyController {\\n    function currentExecutor() external returns (address);\\n}\\n\",\"keccak256\":\"0xc65a455a81ab4bc8e0737d03691c159f28bfd6885ef8b99ddd8dec558ccfeb32\",\"license\":\"BUSL-1.1\"},\"interfaces/IMarginTrading.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IMarginTrading {\\n    function registerDeposit(\\n        address trader,\\n        address token,\\n        uint256 amount\\n    ) external returns (uint256 extinguishAmount);\\n\\n    function registerWithdrawal(\\n        address trader,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function registerBorrow(\\n        address trader,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function registerTradeAndBorrow(\\n        address trader,\\n        address inToken,\\n        address outToken,\\n        uint256 inAmount,\\n        uint256 outAmount\\n    ) external returns (uint256 extinguishAmount, uint256 borrowAmount);\\n\\n    function registerOvercollateralizedBorrow(\\n        address trader,\\n        address depositToken,\\n        uint256 depositAmount,\\n        address borrowToken,\\n        uint256 withdrawAmount\\n    ) external;\\n\\n    function registerLiquidation(address trader) external;\\n\\n    function getHoldingAmounts(address trader)\\n        external\\n        view\\n        returns (\\n            address[] memory holdingTokens,\\n            uint256[] memory holdingAmounts\\n        );\\n\\n    function getBorrowAmounts(address trader)\\n        external\\n        view\\n        returns (address[] memory borrowTokens, uint256[] memory borrowAmounts);\\n}\\n\",\"keccak256\":\"0x973bc425f38651bd78c2cd4371d0a24b456117718bc3540c122bc81197197113\",\"license\":\"BUSL-1.1\"},\"interfaces/IWETH.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\",\"keccak256\":\"0xf85de70a597a9f21052bd1ad25c755cda197102f4aebdb3c3c20f2405bd7442b\"},\"libraries/UniswapStyleLib.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\nlibrary UniswapStyleLib {\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, \\\"Identical address!\\\");\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"Zero address!\\\");\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address pair,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) =\\n            IUniswapV2Pair(pair).getReserves();\\n        (reserveA, reserveB) = tokenA == token0\\n            ? (reserve0, reserve1)\\n            : (reserve1, reserve0);\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 amountInWithFee = amountIn * 997;\\n        uint256 numerator = amountInWithFee * reserveOut;\\n        uint256 denominator = reserveIn * 1_000 + amountInWithFee;\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 numerator = reserveIn * amountOut * 1_000;\\n        uint256 denominator = (reserveOut - amountOut) - 997;\\n        amountIn = (numerator / denominator) + 1;\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] memory pairs,\\n        address[] memory tokens\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(pairs.length >= 1, \\\"pairs is too short\\\");\\n\\n        amounts = new uint256[](tokens.length);\\n        amounts[0] = amountIn;\\n\\n        for (uint256 i; i < tokens.length - 1; i++) {\\n            address pair = pairs[i];\\n\\n            (uint256 reserveIn, uint256 reserveOut) =\\n                getReserves(pair, tokens[i], tokens[i + 1]);\\n\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] memory pairs,\\n        address[] memory tokens\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(pairs.length >= 1, \\\"pairs is too short\\\");\\n\\n        amounts = new uint256[](tokens.length);\\n        amounts[amounts.length - 1] = amountOut;\\n\\n        for (uint256 i = tokens.length - 1; i > 0; i--) {\\n            address pair = pairs[i - 1];\\n\\n            (uint256 reserveIn, uint256 reserveOut) =\\n                getReserves(pair, tokens[i - 1], tokens[i]);\\n\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x763d316ede8b580f3a637c9521959a0cbfcaba8fe3b53b30eaca2e8c85da7671\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162003e1038038062003e108339810160408190526200003491620000db565b806001600160a01b0381166200009b5760405162461bcd60e51b815260206004820152602260248201527f506c656173652070726f766964652076616c696420726f6c6573206164647265604482015261737360f01b606482015260840160405180910390fd5b6001600160601b0319606091821b811660805292901b90911660a0525062000112565b80516001600160a01b0381168114620000d657600080fd5b919050565b60008060408385031215620000ee578182fd5b620000f983620000be565b91506200010960208401620000be565b90509250929050565b60805160601c60a05160601c613c936200017d60003960008181610404015281816108c9015281816115140152818161160d0152818161168001526116ae015260008181610236015281816104eb01528181610ca501528181611fd4015261206c0152613c936000f3fe6080604052600436106101755760003560e01c80637a1a04df116100cb578063a8312b1d1161007f578063e3e0626b11610059578063e3e0626b14610446578063e9c3f77d14610466578063eedb97c71461049c57610175565b8063a8312b1d146103d2578063ad5c4648146103f2578063cb6067dd1461042657610175565b80638824cbba116100b05780638824cbba1461037d57806394427b20146103aa5780639e269b68146103b257610175565b80637a1a04df14610312578063808f67131461035d57610175565b8063392f5f641161012d5780634a297599116101075780634a297599146102bd578063612d1800146102dd57806369698670146102fd57610175565b8063392f5f64146102245780633ad4892414610270578063447d52ba1461029d57610175565b80631306d9021161015e5780631306d902146101c45780631dce3baa146101e45780632864f4011461020457610175565b8063071060a61461017a5780631084bd6d1461019c575b600080fd5b34801561018657600080fd5b5061019a6101953660046137e1565b6104bc565b005b3480156101a857600080fd5b506101b1600a81565b6040519081526020015b60405180910390f35b3480156101d057600080fd5b5061019a6101df3660046135fe565b6105b3565b3480156101f057600080fd5b5061019a6101ff3660046137e1565b61085e565b34801561021057600080fd5b5061019a61021f366004613670565b6109e9565b34801561023057600080fd5b506102587f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101bb565b34801561027c57600080fd5b5061029061028b36600461394f565b610abe565b6040516101bb91906139d8565b3480156102a957600080fd5b5061019a6102b8366004613811565b610c66565b3480156102c957600080fd5b506102906102d83660046138cf565b610d75565b3480156102e957600080fd5b506102906102f836600461394f565b610e91565b34801561030957600080fd5b5061019a611028565b34801561031e57600080fd5b5061034d61032d3660046135fe565b600160209081526000928352604080842090915290825290205460ff1681565b60405190151581526020016101bb565b34801561036957600080fd5b506102906103783660046138cf565b611307565b34801561038957600080fd5b506101b16103983660046135bf565b60026020526000908152604090205481565b61019a611419565b3480156103be57600080fd5b506102906103cd366004613835565b61170f565b3480156103de57600080fd5b506102906103ed366004613835565b61177f565b3480156103fe57600080fd5b506102587f000000000000000000000000000000000000000000000000000000000000000081565b34801561043257600080fd5b5061019a610441366004613629565b6117ef565b34801561045257600080fd5b5061019a6104613660046135fe565b611b40565b34801561047257600080fd5b506102586104813660046137e1565b6000602081905290815260409020546001600160a01b031681565b3480156104a857600080fd5b5061019a6104b73660046135fe565b611cff565b6040517fb4ed0b6d000000000000000000000000000000000000000000000000000000008152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063b4ed0b6d9060240160206040518083038186803b15801561053557600080fd5b505afa158015610549573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056d91906135e2565b60009182526020829052604090912080547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fb3db428b0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03848116602483015260448201849052919091169063b3db428b90606401600060405180830381600087803b15801561065357600080fd5b505af1158015610667573d6000803e3d6000fd5b5050505060006106a8606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f52a664d90000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b0385811660248301526044820185905291909116906352a664d990606401602060405180830381600087803b15801561071357600080fd5b505af1158015610727573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074b91906137f9565b9050801561081057606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517f2a6a897b0000000000000000000000000000000000000000000000000000000081526001600160a01b038581166004830152602482018490529190911690632a6a897b90604401600060405180830381600087803b1580156107ed57600080fd5b505af1158015610801573d6000803e3d6000fd5b50505050610810338483611ef2565b604080513381526001600160a01b03851660208201529081018390527f2f7971a38b280a622029ac616d8d562df278b4b5839a7b124c33a1715ae092999060600160405180910390a1505050565b606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517fd0eb66530000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116602483015260448201849052919091169063d0eb665390606401600060405180830381600087803b15801561091e57600080fd5b505af1158015610932573d6000803e3d6000fd5b50506065600090815260205250507f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517f4782f779000000000000000000000000000000000000000000000000000000008152336004820152602481018390526001600160a01b039190911690634782f77990604401600060405180830381600087803b1580156109ce57600080fd5b505af11580156109e2573d6000803e3d6000fd5b5050505050565b336109f2611fd0565b6001600160a01b03161480610a16575033610a0b612068565b6001600160a01b0316145b80610a255750610a25336120d9565b610a9c5760405162461bcd60e51b815260206004820152603960248201527f43616c6c6572206973206e6f7420746865206f776e65722c206578656375746f60448201527f72206f7220617574686f72697a656420616374697661746f720000000000000060648201526084015b60405180910390fd5b6001600160a01b03909116600090815260026020526040902060ff9091169055565b60608142811015610b115760405162461bcd60e51b815260206004820152601160248201527f54726164652068617320657870697265640000000000000000000000000000006044820152606401610a93565b6000610b1c8a612107565b9050610b95610b2b828c613b94565b89898080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525061213192505050565b9250610c4b3387876000818110610bbc57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610bd191906135bf565b8888610bde600182613b94565b818110610bfb57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610c1091906135bf565b8d8760018951610c209190613b94565b81518110610c3e57634e487b7160e01b600052603260045260246000fd5b602002602001015161233d565b610c59838a8a8a8a8a612629565b5050979650505050505050565b6040517f93552a3d000000000000000000000000000000000000000000000000000000008152600481018390526001600160a01b0382811660248301527f000000000000000000000000000000000000000000000000000000000000000016906393552a3d9060440160206040518083038186803b158015610ce757600080fd5b505afa158015610cfb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1f9190613773565b6001600160a01b039190911660009081526001602090815260408083209483529390529190912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b3360009081526001602090815260408083206007845290915290205460609060ff16610e095760405162461bcd60e51b815260206004820152603e60248201527f43616c6c696e6720636f6e7472616374206973206e6f7420617574686f72697a60448201527f656420746f20747261646520776974682070726f746f636c2066756e647300006064820152608401610a93565b610e778786868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a028281018201909352898252909350899250889182918501908490808284376000920191909152506128ac92505050565b9050610e87818787878787612aba565b9695505050505050565b60608142811015610ee45760405162461bcd60e51b815260206004820152601160248201527f54726164652068617320657870697265640000000000000000000000000000006044820152606401610a93565b610f64610ef08a612b57565b610efa908b613b1f565b88888080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808c0282810182019093528b82529093508b92508a9182918501908490808284376000920191909152506128ac92505050565b915061100e3386866000818110610f8b57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610fa091906135bf565b8787610fad600182613b94565b818110610fca57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610fdf91906135bf565b8560008151811061100057634e487b7160e01b600052603260045260246000fd5b60200260200101518d61233d565b61101c828989898989612aba565b50979650505050505050565b600080611066606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f409fdb720000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03919091169063409fdb729060240160006040518083038186803b1580156110c057600080fd5b505afa1580156110d4573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261111a91908101906136ad565b91509150611159606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517fdb2d904d0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03919091169063db2d904d90602401600060405180830381600087803b1580156111b557600080fd5b505af11580156111c9573d6000803e3d6000fd5b5050505060005b808351111561130257606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166001600160a01b031663d9caed1284838151811061123c57634e487b7160e01b600052603260045260246000fd5b60200260200101513385858151811061126557634e487b7160e01b600052603260045260246000fd5b60209081029190910101516040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b1681526001600160a01b0393841660048201529290911660248301526044820152606401600060405180830381600087803b1580156112d757600080fd5b505af11580156112eb573d6000803e3d6000fd5b5050505080806112fa90613be0565b9150506111d0565b505050565b3360009081526001602090815260408083206007845290915290205460609060ff1661139b5760405162461bcd60e51b815260206004820152603e60248201527f43616c6c696e6720636f6e7472616374206973206e6f7420617574686f72697a60448201527f656420746f20747261646520776974682070726f746f636c2066756e647300006064820152608401610a93565b6114098786868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a0282810182019093528982529093508992508891829185019084908082843760009201919091525061213192505050565b9050610e87818787878787612629565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166001600160a01b031663a6a5f9fe346040518263ffffffff1660e01b81526004016000604051808303818588803b15801561148857600080fd5b505af115801561149c573d6000803e3d6000fd5b505050505060006114de606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f52a664d90000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116602483015234604483015291909116906352a664d990606401602060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115a091906137f9565b905080156116a557606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517f2a6a897b0000000000000000000000000000000000000000000000000000000081526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018490529190911690632a6a897b90604401600060405180830381600087803b15801561166257600080fd5b505af1158015611676573d6000803e3d6000fd5b505050506116a5337f000000000000000000000000000000000000000000000000000000000000000083611ef2565b604080513381527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166020820152348183015290517f2f7971a38b280a622029ac616d8d562df278b4b5839a7b124c33a1715ae092999181900360600190a150565b6060610e878686868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a028281018201909352898252909350899250889182918501908490808284376000920191909152506128ac92505050565b6060610e878686868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a0282810182019093528982529093508992508891829185019084908082843760009201919091525061213192505050565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fb3db428b0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03868116602483015260448201869052919091169063b3db428b90606401600060405180830381600087803b15801561188f57600080fd5b505af11580156118a3573d6000803e3d6000fd5b50506066600090815260205250507f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517fee0862bf0000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015260248201849052919091169063ee0862bf90604401600060405180830381600087803b15801561194157600080fd5b505af1158015611955573d6000803e3d6000fd5b50506068600090815260205250507faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517f1d84cc180000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b038681166024830152604482018690528481166064830152608482018490529190911690631d84cc189060a401600060405180830381600087803b158015611a0857600080fd5b505af1158015611a1c573d6000803e3d6000fd5b50506065600090815260205250507f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fd9caed120000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015233602483015260448201849052919091169063d9caed1290606401600060405180830381600087803b158015611ac057600080fd5b505af1158015611ad4573d6000803e3d6000fd5b50505050611ae3338383612b67565b604080513381526001600160a01b038681166020830152818301869052841660608201526080810183905290517f59df04bd51ea0829a640c9b6be1da5e33d4d15160663510284a2b896670c305b9181900360a00190a150505050565b606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517fd0eb66530000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03848116602483015260448201849052919091169063d0eb665390606401600060405180830381600087803b158015611be057600080fd5b505af1158015611bf4573d6000803e3d6000fd5b50506065600090815260205250507f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fd9caed120000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015233602483015260448201849052919091169063d9caed1290606401600060405180830381600087803b158015611c9857600080fd5b505af1158015611cac573d6000803e3d6000fd5b5050604080513381526001600160a01b03861660208201529081018490527f69725482a69b3feb662528aa4b8028c1f9f6288b9ef746d5c84a847e05ad0d6b925060600190505b60405180910390a15050565b606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517fee0862bf0000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015260248201849052919091169063ee0862bf90604401600060405180830381600087803b158015611d9957600080fd5b505af1158015611dad573d6000803e3d6000fd5b50506068600090815260205250507faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517f498d55eb0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03848116602483015260448201849052919091169063498d55eb90606401600060405180830381600087803b158015611e5157600080fd5b505af1158015611e65573d6000803e3d6000fd5b50505050611e74338383612b67565b604080513381526001600160a01b03841660208201529081018290527fd160a035f47ba1f22446570a0c0f33960590c1e03b5ae81e67f8fdc4c721f4da90606001611cf3565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b031690565b6001600160a01b038216600090815260026020526040902054611f46606c60009081526020527f3c1fcba39712202dbd455253568bf32dd0a3bedb5c3ff0de4b22d4e45e50dc92546001600160a01b031690565b6040517fc6c9faa1000000000000000000000000000000000000000000000000000000008152600481018390526001600160a01b03868116602483015260448201859052919091169063c6c9faa190606401600060405180830381600087803b158015611fb257600080fd5b505af1158015611fc6573d6000803e3d6000fd5b5050505050505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638da5cb5b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561202b57600080fd5b505afa15801561203f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061206391906135e2565b905090565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c34c08e56040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156120c557600080fd5b505af115801561203f573d6000803e3d6000fd5b6001600160a01b03811660009081526001602090815260408083206009845290915290205460ff165b919050565b6000612116600a612710613b1f565b61212183600a613b57565b61212b9190613b37565b92915050565b60606001835110156121855760405162461bcd60e51b815260206004820152601260248201527f706169727320697320746f6f2073686f727400000000000000000000000000006044820152606401610a93565b815167ffffffffffffffff8111156121ad57634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156121d6578160200160208202803683370190505b50905083816000815181106121fb57634e487b7160e01b600052603260045260246000fd5b60200260200101818152505060005b600183516122189190613b94565b81101561233557600084828151811061224157634e487b7160e01b600052603260045260246000fd5b602002602001015190506000806122b38387868151811061227257634e487b7160e01b600052603260045260246000fd5b6020026020010151888760016122889190613b1f565b815181106122a657634e487b7160e01b600052603260045260246000fd5b6020026020010151612c45565b915091506122e98585815181106122da57634e487b7160e01b600052603260045260246000fd5b60200260200101518383612d22565b856122f5866001613b1f565b8151811061231357634e487b7160e01b600052603260045260246000fd5b602002602001018181525050505050808061232d90613be0565b91505061220a565b509392505050565b60008061237b606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f3500aa0b0000000000000000000000000000000000000000000000000000000081526001600160a01b0389811660048301528881166024830152878116604483015260648201879052608482018690529190911690633500aa0b9060a4016040805180830381600087803b1580156123f657600080fd5b505af115801561240a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061242e91906138ac565b909250905081156124f657606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517f2a6a897b0000000000000000000000000000000000000000000000000000000081526001600160a01b038781166004830152602482018590529190911690632a6a897b90604401600060405180830381600087803b1580156124d357600080fd5b505af11580156124e7573d6000803e3d6000fd5b505050506124f6878684611ef2565b80156125b957606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517fee0862bf0000000000000000000000000000000000000000000000000000000081526001600160a01b03888116600483015260248201849052919091169063ee0862bf90604401600060405180830381600087803b15801561259657600080fd5b505af11580156125aa573d6000803e3d6000fd5b505050506125b9878783612b67565b604080516001600160a01b0389811682528881166020830152818301879052606082018490528716608082015260a0810185905260c0810184905290517ffda7842105bd0ae9d4c9616a1d48b1e9f17e2d97cb890d021c291e7d1b53929f9181900360e00190a150505050505050565b8486600188516126399190613b94565b8151811061265757634e487b7160e01b600052603260045260246000fd5b602002602001015110156126d35760405162461bcd60e51b815260206004820152602860248201527f4d617267696e526f757465723a20494e53554646494349454e545f4f5554505560448201527f545f414d4f554e540000000000000000000000000000000000000000000000006064820152608401610a93565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166001600160a01b031663d9caed128383600081811061273757634e487b7160e01b600052603260045260246000fd5b905060200201602081019061274c91906135bf565b8686600081811061276d57634e487b7160e01b600052603260045260246000fd5b905060200201602081019061278291906135bf565b896000815181106127a357634e487b7160e01b600052603260045260246000fd5b60209081029190910101516040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b1681526001600160a01b0393841660048201529290911660248301526044820152606401600060405180830381600087803b15801561281557600080fd5b505af1158015612829573d6000803e3d6000fd5b505050506128a4868585808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152505060408051602080890282810182019093528882529093508892508791829185019084908082843760009201919091525061289f9250611eba915050565b612e69565b505050505050565b60606001835110156129005760405162461bcd60e51b815260206004820152601260248201527f706169727320697320746f6f2073686f727400000000000000000000000000006044820152606401610a93565b815167ffffffffffffffff81111561292857634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015612951578160200160208202803683370190505b5090508381600183516129649190613b94565b8151811061298257634e487b7160e01b600052603260045260246000fd5b60200260200101818152505060006001835161299e9190613b94565b90505b8015612335576000846129b5600184613b94565b815181106129d357634e487b7160e01b600052603260045260246000fd5b60200260200101519050600080612a3883876001876129f29190613b94565b81518110612a1057634e487b7160e01b600052603260045260246000fd5b60200260200101518887815181106122a657634e487b7160e01b600052603260045260246000fd5b91509150612a6e858581518110612a5f57634e487b7160e01b600052603260045260246000fd5b602002602001015183836132c2565b85612a7a600187613b94565b81518110612a9857634e487b7160e01b600052603260045260246000fd5b6020026020010181815250505050508080612ab290613bab565b9150506129a1565b8486600081518110612adc57634e487b7160e01b600052603260045260246000fd5b602002602001015111156126d35760405162461bcd60e51b8152602060048201526024808201527f4d617267696e526f757465723a204558434553534956455f494e5055545f414d60448201527f4f554e54000000000000000000000000000000000000000000000000000000006064820152608401610a93565b600061271061212183600a613b57565b6000612ba4606c60009081526020527f3c1fcba39712202dbd455253568bf32dd0a3bedb5c3ff0de4b22d4e45e50dc92546001600160a01b031690565b6001600160a01b03848116600090815260026020526040908190205490517f2b5de286000000000000000000000000000000000000000000000000000000008152600481018290528783166024820152604481018690529293509190831690632b5de28690606401600060405180830381600087803b158015612c2657600080fd5b505af1158015612c3a573d6000803e3d6000fd5b505050505050505050565b6000806000612c548585613405565b509050600080876001600160a01b0316630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b158015612c9357600080fd5b505afa158015612ca7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ccb9190613793565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150826001600160a01b0316876001600160a01b031614612d10578082612d13565b81815b90999098509650505050505050565b6000808411612d995760405162461bcd60e51b815260206004820152602b60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4960448201527f4e5055545f414d4f554e540000000000000000000000000000000000000000006064820152608401610a93565b600083118015612da95750600082115b612e1b5760405162461bcd60e51b815260206004820152602860248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4c60448201527f49515549444954590000000000000000000000000000000000000000000000006064820152608401610a93565b6000612e29856103e5613b57565b90506000612e378483613b57565b9050600082612e48876103e8613b57565b612e529190613b1f565b9050612e5e8183613b37565b979650505050505050565b60008260018451612e7a9190613b94565b81518110612e9857634e487b7160e01b600052603260045260246000fd5b60209081029190910101516040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301529192506000918316906370a082319060240160206040518083038186803b158015612f0357600080fd5b505afa158015612f17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f3b91906137f9565b905060005b855181101561316b57600080868381518110612f6c57634e487b7160e01b600052603260045260246000fd5b602002602001015187846001612f829190613b1f565b81518110612fa057634e487b7160e01b600052603260045260246000fd5b6020026020010151915091506000612fb88383613405565b50905060008a612fc9866001613b1f565b81518110612fe757634e487b7160e01b600052603260045260246000fd5b60200260200101519050600080836001600160a01b0316866001600160a01b03161461301557826000613019565b6000835b91509150600060018d5161302d9190613b94565b8810613039578a61306c565b8c613045896001613b1f565b8151811061306357634e487b7160e01b600052603260045260246000fd5b60200260200101515b905060008d898151811061309057634e487b7160e01b600052603260045260246000fd5b60200260200101519050806001600160a01b031663022c0d9f858585600067ffffffffffffffff8111156130d457634e487b7160e01b600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156130fe576020820181803683370190505b506040518563ffffffff1660e01b815260040161311e9493929190613a1c565b600060405180830381600087803b15801561313857600080fd5b505af115801561314c573d6000803e3d6000fd5b505050505050505050505050808061316390613be0565b915050612f40565b506040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b038481166004830152600091908416906370a082319060240160206040518083038186803b1580156131ca57600080fd5b505afa1580156131de573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061320291906137f9565b905086600188516132139190613b94565b8151811061323157634e487b7160e01b600052603260045260246000fd5b6020026020010151826132449190613b1f565b8110156132b95760405162461bcd60e51b815260206004820152602960248201527f44656665637469766520414d4d20726f7574653b2062616c616e63657320646f60448201527f6e2774206d6174636800000000000000000000000000000000000000000000006064820152608401610a93565b50505050505050565b60008084116133395760405162461bcd60e51b815260206004820152602c60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4f60448201527f55545055545f414d4f554e5400000000000000000000000000000000000000006064820152608401610a93565b6000831180156133495750600082115b6133bb5760405162461bcd60e51b815260206004820152602860248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4c60448201527f49515549444954590000000000000000000000000000000000000000000000006064820152608401610a93565b60006133c78585613b57565b6133d3906103e8613b57565b905060006103e56133e48786613b94565b6133ee9190613b94565b90506133fa8183613b37565b610e87906001613b1f565b600080826001600160a01b0316846001600160a01b0316141561346a5760405162461bcd60e51b815260206004820152601260248201527f4964656e746963616c20616464726573732100000000000000000000000000006044820152606401610a93565b826001600160a01b0316846001600160a01b03161061348a57828461348d565b83835b90925090506001600160a01b0382166134e85760405162461bcd60e51b815260206004820152600d60248201527f5a65726f206164647265737321000000000000000000000000000000000000006044820152606401610a93565b9250929050565b60008083601f840112613500578182fd5b50813567ffffffffffffffff811115613517578182fd5b6020830191508360208260051b85010111156134e857600080fd5b600082601f830112613542578081fd5b8151602061355761355283613afb565b613aac565b80838252828201915082860187848660051b8901011115613576578586fd5b855b8581101561359457815184529284019290840190600101613578565b5090979650505050505050565b80516dffffffffffffffffffffffffffff8116811461210257600080fd5b6000602082840312156135d0578081fd5b81356135db81613c45565b9392505050565b6000602082840312156135f3578081fd5b81516135db81613c45565b60008060408385031215613610578081fd5b823561361b81613c45565b946020939093013593505050565b6000806000806080858703121561363e578182fd5b843561364981613c45565b935060208501359250604085013561366081613c45565b9396929550929360600135925050565b60008060408385031215613682578182fd5b823561368d81613c45565b9150602083013560ff811681146136a2578182fd5b809150509250929050565b600080604083850312156136bf578182fd5b825167ffffffffffffffff808211156136d6578384fd5b818501915085601f8301126136e9578384fd5b815160206136f961355283613afb565b8083825282820191508286018a848660051b8901011115613718578889fd5b8896505b8487101561374357805161372f81613c45565b83526001969096019591830191830161371c565b509188015191965090935050508082111561375c578283fd5b5061376985828601613532565b9150509250929050565b600060208284031215613784578081fd5b815180151581146135db578182fd5b6000806000606084860312156137a7578283fd5b6137b0846135a1565b92506137be602085016135a1565b9150604084015163ffffffff811681146137d6578182fd5b809150509250925092565b6000602082840312156137f2578081fd5b5035919050565b60006020828403121561380a578081fd5b5051919050565b60008060408385031215613823578182fd5b8235915060208301356136a281613c45565b60008060008060006060868803121561384c578283fd5b85359450602086013567ffffffffffffffff8082111561386a578485fd5b61387689838a016134ef565b9096509450604088013591508082111561388e578283fd5b5061389b888289016134ef565b969995985093965092949392505050565b600080604083850312156138be578182fd5b505080516020909101519092909150565b600080600080600080608087890312156138e7578384fd5b8635955060208701359450604087013567ffffffffffffffff8082111561390c578586fd5b6139188a838b016134ef565b90965094506060890135915080821115613930578283fd5b5061393d89828a016134ef565b979a9699509497509295939492505050565b600080600080600080600060a0888a031215613969578485fd5b8735965060208801359550604088013567ffffffffffffffff8082111561398e578687fd5b61399a8b838c016134ef565b909750955060608a01359150808211156139b2578283fd5b506139bf8a828b016134ef565b989b979a50959894979596608090950135949350505050565b6020808252825182820181905260009190848201906040850190845b81811015613a10578351835292840192918401916001016139f4565b50909695505050505050565b6000858252602085818401526001600160a01b0385166040840152608060608401528351806080850152825b81811015613a645785810183015185820160a001528201613a48565b81811115613a75578360a083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160a0019695505050505050565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613af357613af3613c2f565b604052919050565b600067ffffffffffffffff821115613b1557613b15613c2f565b5060051b60200190565b60008219821115613b3257613b32613c19565b500190565b600082613b5257634e487b7160e01b81526012600452602481fd5b500490565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615613b8f57613b8f613c19565b500290565b600082821015613ba657613ba6613c19565b500390565b600081613bba57613bba613c19565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613c1257613c12613c19565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114613c5a57600080fd5b5056fea2646970667358221220b5e264b4e20ab16528c859fec22b2954f653d97838be4960fc04a8cacd13d0e764736f6c63430008030033",
  "deployedBytecode": "0x6080604052600436106101755760003560e01c80637a1a04df116100cb578063a8312b1d1161007f578063e3e0626b11610059578063e3e0626b14610446578063e9c3f77d14610466578063eedb97c71461049c57610175565b8063a8312b1d146103d2578063ad5c4648146103f2578063cb6067dd1461042657610175565b80638824cbba116100b05780638824cbba1461037d57806394427b20146103aa5780639e269b68146103b257610175565b80637a1a04df14610312578063808f67131461035d57610175565b8063392f5f641161012d5780634a297599116101075780634a297599146102bd578063612d1800146102dd57806369698670146102fd57610175565b8063392f5f64146102245780633ad4892414610270578063447d52ba1461029d57610175565b80631306d9021161015e5780631306d902146101c45780631dce3baa146101e45780632864f4011461020457610175565b8063071060a61461017a5780631084bd6d1461019c575b600080fd5b34801561018657600080fd5b5061019a6101953660046137e1565b6104bc565b005b3480156101a857600080fd5b506101b1600a81565b6040519081526020015b60405180910390f35b3480156101d057600080fd5b5061019a6101df3660046135fe565b6105b3565b3480156101f057600080fd5b5061019a6101ff3660046137e1565b61085e565b34801561021057600080fd5b5061019a61021f366004613670565b6109e9565b34801561023057600080fd5b506102587f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101bb565b34801561027c57600080fd5b5061029061028b36600461394f565b610abe565b6040516101bb91906139d8565b3480156102a957600080fd5b5061019a6102b8366004613811565b610c66565b3480156102c957600080fd5b506102906102d83660046138cf565b610d75565b3480156102e957600080fd5b506102906102f836600461394f565b610e91565b34801561030957600080fd5b5061019a611028565b34801561031e57600080fd5b5061034d61032d3660046135fe565b600160209081526000928352604080842090915290825290205460ff1681565b60405190151581526020016101bb565b34801561036957600080fd5b506102906103783660046138cf565b611307565b34801561038957600080fd5b506101b16103983660046135bf565b60026020526000908152604090205481565b61019a611419565b3480156103be57600080fd5b506102906103cd366004613835565b61170f565b3480156103de57600080fd5b506102906103ed366004613835565b61177f565b3480156103fe57600080fd5b506102587f000000000000000000000000000000000000000000000000000000000000000081565b34801561043257600080fd5b5061019a610441366004613629565b6117ef565b34801561045257600080fd5b5061019a6104613660046135fe565b611b40565b34801561047257600080fd5b506102586104813660046137e1565b6000602081905290815260409020546001600160a01b031681565b3480156104a857600080fd5b5061019a6104b73660046135fe565b611cff565b6040517fb4ed0b6d000000000000000000000000000000000000000000000000000000008152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063b4ed0b6d9060240160206040518083038186803b15801561053557600080fd5b505afa158015610549573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056d91906135e2565b60009182526020829052604090912080547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b03909216919091179055565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fb3db428b0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03848116602483015260448201849052919091169063b3db428b90606401600060405180830381600087803b15801561065357600080fd5b505af1158015610667573d6000803e3d6000fd5b5050505060006106a8606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f52a664d90000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b0385811660248301526044820185905291909116906352a664d990606401602060405180830381600087803b15801561071357600080fd5b505af1158015610727573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074b91906137f9565b9050801561081057606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517f2a6a897b0000000000000000000000000000000000000000000000000000000081526001600160a01b038581166004830152602482018490529190911690632a6a897b90604401600060405180830381600087803b1580156107ed57600080fd5b505af1158015610801573d6000803e3d6000fd5b50505050610810338483611ef2565b604080513381526001600160a01b03851660208201529081018390527f2f7971a38b280a622029ac616d8d562df278b4b5839a7b124c33a1715ae092999060600160405180910390a1505050565b606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517fd0eb66530000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116602483015260448201849052919091169063d0eb665390606401600060405180830381600087803b15801561091e57600080fd5b505af1158015610932573d6000803e3d6000fd5b50506065600090815260205250507f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517f4782f779000000000000000000000000000000000000000000000000000000008152336004820152602481018390526001600160a01b039190911690634782f77990604401600060405180830381600087803b1580156109ce57600080fd5b505af11580156109e2573d6000803e3d6000fd5b5050505050565b336109f2611fd0565b6001600160a01b03161480610a16575033610a0b612068565b6001600160a01b0316145b80610a255750610a25336120d9565b610a9c5760405162461bcd60e51b815260206004820152603960248201527f43616c6c6572206973206e6f7420746865206f776e65722c206578656375746f60448201527f72206f7220617574686f72697a656420616374697661746f720000000000000060648201526084015b60405180910390fd5b6001600160a01b03909116600090815260026020526040902060ff9091169055565b60608142811015610b115760405162461bcd60e51b815260206004820152601160248201527f54726164652068617320657870697265640000000000000000000000000000006044820152606401610a93565b6000610b1c8a612107565b9050610b95610b2b828c613b94565b89898080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525061213192505050565b9250610c4b3387876000818110610bbc57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610bd191906135bf565b8888610bde600182613b94565b818110610bfb57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610c1091906135bf565b8d8760018951610c209190613b94565b81518110610c3e57634e487b7160e01b600052603260045260246000fd5b602002602001015161233d565b610c59838a8a8a8a8a612629565b5050979650505050505050565b6040517f93552a3d000000000000000000000000000000000000000000000000000000008152600481018390526001600160a01b0382811660248301527f000000000000000000000000000000000000000000000000000000000000000016906393552a3d9060440160206040518083038186803b158015610ce757600080fd5b505afa158015610cfb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1f9190613773565b6001600160a01b039190911660009081526001602090815260408083209483529390529190912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b3360009081526001602090815260408083206007845290915290205460609060ff16610e095760405162461bcd60e51b815260206004820152603e60248201527f43616c6c696e6720636f6e7472616374206973206e6f7420617574686f72697a60448201527f656420746f20747261646520776974682070726f746f636c2066756e647300006064820152608401610a93565b610e778786868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a028281018201909352898252909350899250889182918501908490808284376000920191909152506128ac92505050565b9050610e87818787878787612aba565b9695505050505050565b60608142811015610ee45760405162461bcd60e51b815260206004820152601160248201527f54726164652068617320657870697265640000000000000000000000000000006044820152606401610a93565b610f64610ef08a612b57565b610efa908b613b1f565b88888080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808c0282810182019093528b82529093508b92508a9182918501908490808284376000920191909152506128ac92505050565b915061100e3386866000818110610f8b57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610fa091906135bf565b8787610fad600182613b94565b818110610fca57634e487b7160e01b600052603260045260246000fd5b9050602002016020810190610fdf91906135bf565b8560008151811061100057634e487b7160e01b600052603260045260246000fd5b60200260200101518d61233d565b61101c828989898989612aba565b50979650505050505050565b600080611066606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f409fdb720000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03919091169063409fdb729060240160006040518083038186803b1580156110c057600080fd5b505afa1580156110d4573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261111a91908101906136ad565b91509150611159606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517fdb2d904d0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03919091169063db2d904d90602401600060405180830381600087803b1580156111b557600080fd5b505af11580156111c9573d6000803e3d6000fd5b5050505060005b808351111561130257606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166001600160a01b031663d9caed1284838151811061123c57634e487b7160e01b600052603260045260246000fd5b60200260200101513385858151811061126557634e487b7160e01b600052603260045260246000fd5b60209081029190910101516040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b1681526001600160a01b0393841660048201529290911660248301526044820152606401600060405180830381600087803b1580156112d757600080fd5b505af11580156112eb573d6000803e3d6000fd5b5050505080806112fa90613be0565b9150506111d0565b505050565b3360009081526001602090815260408083206007845290915290205460609060ff1661139b5760405162461bcd60e51b815260206004820152603e60248201527f43616c6c696e6720636f6e7472616374206973206e6f7420617574686f72697a60448201527f656420746f20747261646520776974682070726f746f636c2066756e647300006064820152608401610a93565b6114098786868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a0282810182019093528982529093508992508891829185019084908082843760009201919091525061213192505050565b9050610e87818787878787612629565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166001600160a01b031663a6a5f9fe346040518263ffffffff1660e01b81526004016000604051808303818588803b15801561148857600080fd5b505af115801561149c573d6000803e3d6000fd5b505050505060006114de606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f52a664d90000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116602483015234604483015291909116906352a664d990606401602060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115a091906137f9565b905080156116a557606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517f2a6a897b0000000000000000000000000000000000000000000000000000000081526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018490529190911690632a6a897b90604401600060405180830381600087803b15801561166257600080fd5b505af1158015611676573d6000803e3d6000fd5b505050506116a5337f000000000000000000000000000000000000000000000000000000000000000083611ef2565b604080513381527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166020820152348183015290517f2f7971a38b280a622029ac616d8d562df278b4b5839a7b124c33a1715ae092999181900360600190a150565b6060610e878686868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a028281018201909352898252909350899250889182918501908490808284376000920191909152506128ac92505050565b6060610e878686868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808a0282810182019093528982529093508992508891829185019084908082843760009201919091525061213192505050565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fb3db428b0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03868116602483015260448201869052919091169063b3db428b90606401600060405180830381600087803b15801561188f57600080fd5b505af11580156118a3573d6000803e3d6000fd5b50506066600090815260205250507f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517fee0862bf0000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015260248201849052919091169063ee0862bf90604401600060405180830381600087803b15801561194157600080fd5b505af1158015611955573d6000803e3d6000fd5b50506068600090815260205250507faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517f1d84cc180000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b038681166024830152604482018690528481166064830152608482018490529190911690631d84cc189060a401600060405180830381600087803b158015611a0857600080fd5b505af1158015611a1c573d6000803e3d6000fd5b50506065600090815260205250507f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fd9caed120000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015233602483015260448201849052919091169063d9caed1290606401600060405180830381600087803b158015611ac057600080fd5b505af1158015611ad4573d6000803e3d6000fd5b50505050611ae3338383612b67565b604080513381526001600160a01b038681166020830152818301869052841660608201526080810183905290517f59df04bd51ea0829a640c9b6be1da5e33d4d15160663510284a2b896670c305b9181900360a00190a150505050565b606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517fd0eb66530000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03848116602483015260448201849052919091169063d0eb665390606401600060405180830381600087803b158015611be057600080fd5b505af1158015611bf4573d6000803e3d6000fd5b50506065600090815260205250507f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166040517fd9caed120000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015233602483015260448201849052919091169063d9caed1290606401600060405180830381600087803b158015611c9857600080fd5b505af1158015611cac573d6000803e3d6000fd5b5050604080513381526001600160a01b03861660208201529081018490527f69725482a69b3feb662528aa4b8028c1f9f6288b9ef746d5c84a847e05ad0d6b925060600190505b60405180910390a15050565b606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517fee0862bf0000000000000000000000000000000000000000000000000000000081526001600160a01b03848116600483015260248201849052919091169063ee0862bf90604401600060405180830381600087803b158015611d9957600080fd5b505af1158015611dad573d6000803e3d6000fd5b50506068600090815260205250507faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b03166040517f498d55eb0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03848116602483015260448201849052919091169063498d55eb90606401600060405180830381600087803b158015611e5157600080fd5b505af1158015611e65573d6000803e3d6000fd5b50505050611e74338383612b67565b604080513381526001600160a01b03841660208201529081018290527fd160a035f47ba1f22446570a0c0f33960590c1e03b5ae81e67f8fdc4c721f4da90606001611cf3565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b031690565b6001600160a01b038216600090815260026020526040902054611f46606c60009081526020527f3c1fcba39712202dbd455253568bf32dd0a3bedb5c3ff0de4b22d4e45e50dc92546001600160a01b031690565b6040517fc6c9faa1000000000000000000000000000000000000000000000000000000008152600481018390526001600160a01b03868116602483015260448201859052919091169063c6c9faa190606401600060405180830381600087803b158015611fb257600080fd5b505af1158015611fc6573d6000803e3d6000fd5b5050505050505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638da5cb5b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561202b57600080fd5b505afa15801561203f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061206391906135e2565b905090565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c34c08e56040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156120c557600080fd5b505af115801561203f573d6000803e3d6000fd5b6001600160a01b03811660009081526001602090815260408083206009845290915290205460ff165b919050565b6000612116600a612710613b1f565b61212183600a613b57565b61212b9190613b37565b92915050565b60606001835110156121855760405162461bcd60e51b815260206004820152601260248201527f706169727320697320746f6f2073686f727400000000000000000000000000006044820152606401610a93565b815167ffffffffffffffff8111156121ad57634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156121d6578160200160208202803683370190505b50905083816000815181106121fb57634e487b7160e01b600052603260045260246000fd5b60200260200101818152505060005b600183516122189190613b94565b81101561233557600084828151811061224157634e487b7160e01b600052603260045260246000fd5b602002602001015190506000806122b38387868151811061227257634e487b7160e01b600052603260045260246000fd5b6020026020010151888760016122889190613b1f565b815181106122a657634e487b7160e01b600052603260045260246000fd5b6020026020010151612c45565b915091506122e98585815181106122da57634e487b7160e01b600052603260045260246000fd5b60200260200101518383612d22565b856122f5866001613b1f565b8151811061231357634e487b7160e01b600052603260045260246000fd5b602002602001018181525050505050808061232d90613be0565b91505061220a565b509392505050565b60008061237b606860009081526020527faa071f48f62aaaa1f6320aaa7bd2ad2d552d05160892c14d699d38c9920d5f99546001600160a01b031690565b6040517f3500aa0b0000000000000000000000000000000000000000000000000000000081526001600160a01b0389811660048301528881166024830152878116604483015260648201879052608482018690529190911690633500aa0b9060a4016040805180830381600087803b1580156123f657600080fd5b505af115801561240a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061242e91906138ac565b909250905081156124f657606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517f2a6a897b0000000000000000000000000000000000000000000000000000000081526001600160a01b038781166004830152602482018590529190911690632a6a897b90604401600060405180830381600087803b1580156124d357600080fd5b505af11580156124e7573d6000803e3d6000fd5b505050506124f6878684611ef2565b80156125b957606660009081526020527f422cccb7cea5c0e46f340bb7b21b81debac329f72e31669c20ff0f3a05cc2b5b546001600160a01b03166040517fee0862bf0000000000000000000000000000000000000000000000000000000081526001600160a01b03888116600483015260248201849052919091169063ee0862bf90604401600060405180830381600087803b15801561259657600080fd5b505af11580156125aa573d6000803e3d6000fd5b505050506125b9878783612b67565b604080516001600160a01b0389811682528881166020830152818301879052606082018490528716608082015260a0810185905260c0810184905290517ffda7842105bd0ae9d4c9616a1d48b1e9f17e2d97cb890d021c291e7d1b53929f9181900360e00190a150505050505050565b8486600188516126399190613b94565b8151811061265757634e487b7160e01b600052603260045260246000fd5b602002602001015110156126d35760405162461bcd60e51b815260206004820152602860248201527f4d617267696e526f757465723a20494e53554646494349454e545f4f5554505560448201527f545f414d4f554e540000000000000000000000000000000000000000000000006064820152608401610a93565b606560009081526020527f4a7203f705e51df4a56139a9b86b4a0970bed7ab7a3446eaffe2289989c1645c546001600160a01b03166001600160a01b031663d9caed128383600081811061273757634e487b7160e01b600052603260045260246000fd5b905060200201602081019061274c91906135bf565b8686600081811061276d57634e487b7160e01b600052603260045260246000fd5b905060200201602081019061278291906135bf565b896000815181106127a357634e487b7160e01b600052603260045260246000fd5b60209081029190910101516040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b1681526001600160a01b0393841660048201529290911660248301526044820152606401600060405180830381600087803b15801561281557600080fd5b505af1158015612829573d6000803e3d6000fd5b505050506128a4868585808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152505060408051602080890282810182019093528882529093508892508791829185019084908082843760009201919091525061289f9250611eba915050565b612e69565b505050505050565b60606001835110156129005760405162461bcd60e51b815260206004820152601260248201527f706169727320697320746f6f2073686f727400000000000000000000000000006044820152606401610a93565b815167ffffffffffffffff81111561292857634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015612951578160200160208202803683370190505b5090508381600183516129649190613b94565b8151811061298257634e487b7160e01b600052603260045260246000fd5b60200260200101818152505060006001835161299e9190613b94565b90505b8015612335576000846129b5600184613b94565b815181106129d357634e487b7160e01b600052603260045260246000fd5b60200260200101519050600080612a3883876001876129f29190613b94565b81518110612a1057634e487b7160e01b600052603260045260246000fd5b60200260200101518887815181106122a657634e487b7160e01b600052603260045260246000fd5b91509150612a6e858581518110612a5f57634e487b7160e01b600052603260045260246000fd5b602002602001015183836132c2565b85612a7a600187613b94565b81518110612a9857634e487b7160e01b600052603260045260246000fd5b6020026020010181815250505050508080612ab290613bab565b9150506129a1565b8486600081518110612adc57634e487b7160e01b600052603260045260246000fd5b602002602001015111156126d35760405162461bcd60e51b8152602060048201526024808201527f4d617267696e526f757465723a204558434553534956455f494e5055545f414d60448201527f4f554e54000000000000000000000000000000000000000000000000000000006064820152608401610a93565b600061271061212183600a613b57565b6000612ba4606c60009081526020527f3c1fcba39712202dbd455253568bf32dd0a3bedb5c3ff0de4b22d4e45e50dc92546001600160a01b031690565b6001600160a01b03848116600090815260026020526040908190205490517f2b5de286000000000000000000000000000000000000000000000000000000008152600481018290528783166024820152604481018690529293509190831690632b5de28690606401600060405180830381600087803b158015612c2657600080fd5b505af1158015612c3a573d6000803e3d6000fd5b505050505050505050565b6000806000612c548585613405565b509050600080876001600160a01b0316630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b158015612c9357600080fd5b505afa158015612ca7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ccb9190613793565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150826001600160a01b0316876001600160a01b031614612d10578082612d13565b81815b90999098509650505050505050565b6000808411612d995760405162461bcd60e51b815260206004820152602b60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4960448201527f4e5055545f414d4f554e540000000000000000000000000000000000000000006064820152608401610a93565b600083118015612da95750600082115b612e1b5760405162461bcd60e51b815260206004820152602860248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4c60448201527f49515549444954590000000000000000000000000000000000000000000000006064820152608401610a93565b6000612e29856103e5613b57565b90506000612e378483613b57565b9050600082612e48876103e8613b57565b612e529190613b1f565b9050612e5e8183613b37565b979650505050505050565b60008260018451612e7a9190613b94565b81518110612e9857634e487b7160e01b600052603260045260246000fd5b60209081029190910101516040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301529192506000918316906370a082319060240160206040518083038186803b158015612f0357600080fd5b505afa158015612f17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f3b91906137f9565b905060005b855181101561316b57600080868381518110612f6c57634e487b7160e01b600052603260045260246000fd5b602002602001015187846001612f829190613b1f565b81518110612fa057634e487b7160e01b600052603260045260246000fd5b6020026020010151915091506000612fb88383613405565b50905060008a612fc9866001613b1f565b81518110612fe757634e487b7160e01b600052603260045260246000fd5b60200260200101519050600080836001600160a01b0316866001600160a01b03161461301557826000613019565b6000835b91509150600060018d5161302d9190613b94565b8810613039578a61306c565b8c613045896001613b1f565b8151811061306357634e487b7160e01b600052603260045260246000fd5b60200260200101515b905060008d898151811061309057634e487b7160e01b600052603260045260246000fd5b60200260200101519050806001600160a01b031663022c0d9f858585600067ffffffffffffffff8111156130d457634e487b7160e01b600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156130fe576020820181803683370190505b506040518563ffffffff1660e01b815260040161311e9493929190613a1c565b600060405180830381600087803b15801561313857600080fd5b505af115801561314c573d6000803e3d6000fd5b505050505050505050505050808061316390613be0565b915050612f40565b506040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b038481166004830152600091908416906370a082319060240160206040518083038186803b1580156131ca57600080fd5b505afa1580156131de573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061320291906137f9565b905086600188516132139190613b94565b8151811061323157634e487b7160e01b600052603260045260246000fd5b6020026020010151826132449190613b1f565b8110156132b95760405162461bcd60e51b815260206004820152602960248201527f44656665637469766520414d4d20726f7574653b2062616c616e63657320646f60448201527f6e2774206d6174636800000000000000000000000000000000000000000000006064820152608401610a93565b50505050505050565b60008084116133395760405162461bcd60e51b815260206004820152602c60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4f60448201527f55545055545f414d4f554e5400000000000000000000000000000000000000006064820152608401610a93565b6000831180156133495750600082115b6133bb5760405162461bcd60e51b815260206004820152602860248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4c60448201527f49515549444954590000000000000000000000000000000000000000000000006064820152608401610a93565b60006133c78585613b57565b6133d3906103e8613b57565b905060006103e56133e48786613b94565b6133ee9190613b94565b90506133fa8183613b37565b610e87906001613b1f565b600080826001600160a01b0316846001600160a01b0316141561346a5760405162461bcd60e51b815260206004820152601260248201527f4964656e746963616c20616464726573732100000000000000000000000000006044820152606401610a93565b826001600160a01b0316846001600160a01b03161061348a57828461348d565b83835b90925090506001600160a01b0382166134e85760405162461bcd60e51b815260206004820152600d60248201527f5a65726f206164647265737321000000000000000000000000000000000000006044820152606401610a93565b9250929050565b60008083601f840112613500578182fd5b50813567ffffffffffffffff811115613517578182fd5b6020830191508360208260051b85010111156134e857600080fd5b600082601f830112613542578081fd5b8151602061355761355283613afb565b613aac565b80838252828201915082860187848660051b8901011115613576578586fd5b855b8581101561359457815184529284019290840190600101613578565b5090979650505050505050565b80516dffffffffffffffffffffffffffff8116811461210257600080fd5b6000602082840312156135d0578081fd5b81356135db81613c45565b9392505050565b6000602082840312156135f3578081fd5b81516135db81613c45565b60008060408385031215613610578081fd5b823561361b81613c45565b946020939093013593505050565b6000806000806080858703121561363e578182fd5b843561364981613c45565b935060208501359250604085013561366081613c45565b9396929550929360600135925050565b60008060408385031215613682578182fd5b823561368d81613c45565b9150602083013560ff811681146136a2578182fd5b809150509250929050565b600080604083850312156136bf578182fd5b825167ffffffffffffffff808211156136d6578384fd5b818501915085601f8301126136e9578384fd5b815160206136f961355283613afb565b8083825282820191508286018a848660051b8901011115613718578889fd5b8896505b8487101561374357805161372f81613c45565b83526001969096019591830191830161371c565b509188015191965090935050508082111561375c578283fd5b5061376985828601613532565b9150509250929050565b600060208284031215613784578081fd5b815180151581146135db578182fd5b6000806000606084860312156137a7578283fd5b6137b0846135a1565b92506137be602085016135a1565b9150604084015163ffffffff811681146137d6578182fd5b809150509250925092565b6000602082840312156137f2578081fd5b5035919050565b60006020828403121561380a578081fd5b5051919050565b60008060408385031215613823578182fd5b8235915060208301356136a281613c45565b60008060008060006060868803121561384c578283fd5b85359450602086013567ffffffffffffffff8082111561386a578485fd5b61387689838a016134ef565b9096509450604088013591508082111561388e578283fd5b5061389b888289016134ef565b969995985093965092949392505050565b600080604083850312156138be578182fd5b505080516020909101519092909150565b600080600080600080608087890312156138e7578384fd5b8635955060208701359450604087013567ffffffffffffffff8082111561390c578586fd5b6139188a838b016134ef565b90965094506060890135915080821115613930578283fd5b5061393d89828a016134ef565b979a9699509497509295939492505050565b600080600080600080600060a0888a031215613969578485fd5b8735965060208801359550604088013567ffffffffffffffff8082111561398e578687fd5b61399a8b838c016134ef565b909750955060608a01359150808211156139b2578283fd5b506139bf8a828b016134ef565b989b979a50959894979596608090950135949350505050565b6020808252825182820181905260009190848201906040850190845b81811015613a10578351835292840192918401916001016139f4565b50909695505050505050565b6000858252602085818401526001600160a01b0385166040840152608060608401528351806080850152825b81811015613a645785810183015185820160a001528201613a48565b81811115613a75578360a083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160a0019695505050505050565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613af357613af3613c2f565b604052919050565b600067ffffffffffffffff821115613b1557613b15613c2f565b5060051b60200190565b60008219821115613b3257613b32613c19565b500190565b600082613b5257634e487b7160e01b81526012600452602481fd5b500490565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615613b8f57613b8f613c19565b500290565b600082821015613ba657613ba6613c19565b500390565b600081613bba57613bba613c19565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613c1257613c12613c19565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114613c5a57600080fd5b5056fea2646970667358221220b5e264b4e20ab16528c859fec22b2954f653d97838be4960fc04a8cacd13d0e764736f6c63430008030033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "crossOvercollateralizedBorrow(address,uint256,address,uint256)": {
        "details": "caution: the account still has to have a positive balaance at the end of the withdraw. So an underwater account may not be able to withdraw"
      }
    },
    "title": "Top level transaction controller",
    "version": 1
  },
  "userdoc": {
    "events": {
      "CrossBorrow(address,address,uint256)": {
        "notice": "emitted upon sucessfully borrowing"
      },
      "CrossDeposit(address,address,uint256)": {
        "notice": "emitted when a trader depoits on cross margin"
      },
      "CrossOvercollateralizedBorrow(address,address,uint256,address,uint256)": {
        "notice": "emmited on deposit-borrow-withdraw"
      },
      "CrossTrade(address,address,uint256,uint256,address,uint256,uint256)": {
        "notice": "emitted whenever a trade happens"
      },
      "CrossWithdraw(address,address,uint256)": {
        "notice": "emitted when a trader withdraws funds"
      }
    },
    "kind": "user",
    "methods": {
      "WETH()": {
        "notice": "wrapped ETH ERC20 contract"
      },
      "authorizedSwapExactT4T(uint256,uint256,address[],address[])": {
        "notice": "make swaps on AMM using protocol funds, only for authorized contracts"
      },
      "crossBorrow(address,uint256)": {
        "notice": "borrow into cross margin trading account"
      },
      "crossCloseAccount()": {
        "notice": "close an account that is no longer borrowing and return gains"
      },
      "crossDeposit(address,uint256)": {
        "notice": "traders call this to deposit funds on cross margin"
      },
      "crossDepositETH()": {
        "notice": "deposit wrapped ehtereum into cross margin account"
      },
      "crossOvercollateralizedBorrow(address,uint256,address,uint256)": {
        "notice": "convenience function to perform overcollateralized borrowing against a cross margin account."
      },
      "crossSwapExactTokensForTokens(uint256,uint256,address[],address[],uint256)": {
        "notice": "entry point for swapping tokens held in cross margin account"
      },
      "crossSwapTokensForExactTokens(uint256,uint256,address[],address[],uint256)": {
        "notice": "entry point for swapping tokens held in cross margin account"
      },
      "crossWithdraw(address,uint256)": {
        "notice": "withdraw deposits/earnings from cross margin account"
      },
      "crossWithdrawETH(uint256)": {
        "notice": "withdraw ethereum from cross margin account"
      },
      "setIncentiveTranche(address,uint8)": {
        "notice": "Set incentive tranche"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11650,
        "contract": "contracts/MarginRouter.sol:MarginRouter",
        "label": "mainCharacterCache",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 11656,
        "contract": "contracts/MarginRouter.sol:MarginRouter",
        "label": "roleCache",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bool))"
      },
      {
        "astId": 7260,
        "contract": "contracts/MarginRouter.sol:MarginRouter",
        "label": "incentiveTranches",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bool)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}